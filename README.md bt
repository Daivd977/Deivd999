local WindUI = loadstring(game:HttpGet("https://tree-hub.vercel.app/api/UI/WindUI"))()
local Version = "1.4.0"

local Window = WindUI:CreateWindow({
    Title = "Lolyta troll 666",
    Icon = "door-open",
    Author = "Lolycon666",
    Folder = "Lolyta 666",
    Size = UDim2.fromOffset(580, 460),
    KeySystem = {
        Key = "666",
        Note = "pode nao man",
        URL = "",
        SaveKey = true,
    },
    Transparent = true,
    Theme = "Dark",
    SideBarWidth = 200,
    HasOutline = false,
})

Window:EditOpenButton({
    Title = "Lolyta troll",
    Icon = "align-justify",
    CornerRadius = UDim.new(0, 10),
    StrokeThickness = 3,
    Color = ColorSequence.new(Color3.fromHex("FF0F7B"), Color3.fromHex("F89B29"))
})

-- === Abas da Interface === --
local Tab1 = Window:Tab({ Title = "troll", Icon = "Ball" })

-----------------------------------------------------------------------------------------------------------------------------------------
                                          -- === Tab 1: Troll === --
-----------------------------------------------------------------------------------------------------------------------------------------

-- Carregar a biblioteca UI
local success, Library = pcall(function()
    return loadstring(game:HttpGet("https://raw.githubusercontent.com/Robojini/Destiny/main/UILIB_V3"))()
end)
if not success or not Library then
    error("Falha ao carregar a biblioteca UI. Verifique a conexão ou a URL.")
end

-- Criar a janela e a aba
local Window = Library:Create({Name = "Troll Hub", Theme = "Dark"})
local Tab1 = Window:Tab({Name = "troll"})

-- Verificar se Tab1 foi criado
if not Tab1 then
    error("Falha ao criar a aba 'troll'. Verifique a biblioteca UI.")
end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

-- Variáveis compartilhadas
local selectedPlayer = nil
local isFollowingKill = false
local isFollowingPull = false
local running = false
local connection = nil
local flingConnection = nil
local originalPosition = nil
local savedPosition = nil
local originalProperties = {}
local selectedKillPullMethod = nil
local selectedFlingMethod = nil
local soccerBall = nil
local couch = nil
local isSpectating = false
local spectatedPlayer = nil
local characterConnection = nil

-- Cria um RemoteEvent para comunicação com o servidor
local SetNetworkOwnerEvent = Instance.new("RemoteEvent")
SetNetworkOwnerEvent.Name = "SetNetworkOwnerEvent_" .. tostring(math.random(1000, 9999))
SetNetworkOwnerEvent.Parent = ReplicatedStorage

-- Cria um script no servidor para lidar com o RemoteEvent
local serverScriptCode = [[
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local event = ReplicatedStorage:WaitForChild("]] .. SetNetworkOwnerEvent.Name .. [[")
    
    event.OnServerEvent:Connect(function(player, part, networkOwner)
        if part and part:IsA("BasePart") then
            pcall(function()
                part:SetNetworkOwner(networkOwner)
                part.Anchored = false
                part.CanCollide = true
                part.CanTouch = true
            end)
        end
    end)
]]

local success = pcall(loadstring(serverScriptCode))
if not success then
    error("Falha ao criar script no servidor. Verifique a conexão com ReplicatedStorage.")
end

-- Função para obter os nomes dos jogadores, excluindo o jogador local
local function getPlayerNames()
    local playerNames = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playerNames, player.Name)
        end
    end
    return playerNames
end

-- Função para atualizar o dropdown
local function updateDropdown(dropdown)
    pcall(function()
        local playerNames = getPlayerNames()
        dropdown:Refresh(playerNames)
        if selectedPlayer and not table.find(playerNames, selectedPlayer.Name) then
            dropdown:SetValue("")
            selectedPlayer = nil
            if isSpectating then
                stopSpectating()
            end
        end
    end)
end

-- Função para visualizar um jogador
local function spectatePlayer(playerName)
    if characterConnection then
        characterConnection:Disconnect()
        characterConnection = nil
    end

    local targetPlayer = Players:FindFirstChild(playerName)
    if targetPlayer and targetPlayer ~= LocalPlayer then
        spectatedPlayer = targetPlayer
        isSpectating = true

        local function updateCamera()
            if not isSpectating or not spectatedPlayer then
                return
            end
            if spectatedPlayer.Character and spectatedPlayer.Character:FindFirstChild("Humanoid") then
                Workspace.CurrentCamera.CameraSubject = spectatedPlayer.Character.Humanoid
            else
                Workspace.CurrentCamera.CameraSubject = nil
            end
        end

        pcall(updateCamera)

        characterConnection = RunService.Heartbeat:Connect(function()
            if not isSpectating then
                characterConnection:Disconnect()
                characterConnection = nil
                return
            end
            pcall(updateCamera)
        end)

        spectatedPlayer.CharacterAdded:Connect(function()
            if isSpectating then
                pcall(updateCamera)
            end
        end)
    else
        isSpectating = false
        spectatedPlayer = nil
    end
end

-- Função para parar de visualizar
local function stopSpectating()
    if characterConnection then
        characterConnection:Disconnect()
        characterConnection = nil
    end

    isSpectating = false
    spectatedPlayer = nil

    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        Workspace.CurrentCamera.CameraSubject = LocalPlayer.Character.Humanoid
        Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
    else
        Workspace.CurrentCamera.CameraSubject = nil
        Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
    end
end

-- Detecta quando o jogador local morre e reseta a câmera
LocalPlayer.CharacterAdded:Connect(function()
    if isSpectating then
        stopSpectating()
    end
end)

-- Criar elementos da UI com depuração
local DropdownPlayer
local success, err = pcall(function()
    DropdownPlayer = Tab1:Dropdown({
        Title = "Selecionar Jogador",
        Desc = "Escolha um jogador para matar, puxar, visualizar ou aplicar fling",
        Value = "",
        Multi = false,
        AllowNone = true,
        Values = getPlayerNames(),
        Callback = function(selectedPlayerName)
            if selectedPlayerName == "" or selectedPlayerName == nil then
                selectedPlayer = nil
                if running or isFollowingKill or isFollowingPull then
                    running = false
                    isFollowingKill = false
                    isFollowingPull = false
                    if connection then connection:Disconnect() end
                    if flingConnection then flingConnection:Disconnect() end
                end
                if isSpectating then
                    stopSpectating()
                end
            else
                selectedPlayer = Players:FindFirstChild(selectedPlayerName)
                if isSpectating then
                    stopSpectating()
                    spectatePlayer(selectedPlayerName)
                end
            end
        end
    })
end)
if not success then
    print("Erro ao criar DropdownPlayer: " .. tostring(err))
end

local UpdateButton
success, err = pcall(function()
    UpdateButton = Tab1:Button({
        Title = "Atualizar Lista de Jogadores",
        Desc = "Atualiza a lista de jogadores no dropdown",
        Callback = function()
            updateDropdown(DropdownPlayer)
        end
    })
end)
if not success then
    print("Erro ao criar UpdateButton: " .. tostring(err))
end

local SpectateToggle
success, err = pcall(function()
    SpectateToggle = Tab1:Toggle({
        Title = "Visualizar Jogador",
        Desc = "Ativa/desativa a visualização do jogador selecionado",
        Default = false,
        Callback = function(state)
            if state then
                if selectedPlayer then
                    pcall(spectatePlayer, selectedPlayer.Name)
                else
                    SpectateToggle:SetValue(false)
                end
            else
                pcall(stopSpectating)
            end
        end
    })
end)
if not success then
    print("Erro ao criar SpectateToggle: " .. tostring(err))
end

-- Remove jogadores que saem do servidor
Players.PlayerRemoving:Connect(function(player)
    if selectedPlayer == player then
        selectedPlayer = nil
        if isSpectating then
            stopSpectating()
        end
    end
    updateDropdown(DropdownPlayer)
end)

-- Inicializa o dropdown
if DropdownPlayer then
    updateDropdown(DropdownPlayer)
else
    print("DropdownPlayer não foi criado. Verifique a biblioteca UI.")
end

-- Dropdown para selecionar método de matar/puxar
local DropdownKillPullMethod
success, err = pcall(function()
    DropdownKillPullMethod = Tab1:Dropdown({
        Title = "Selecionar Método (Matar/Puxar)",
        Desc = "Escolha o método para matar ou puxar",
        Values = {"Sofá", "Ônibus"},
        Callback = function(value)
            selectedKillPullMethod = value
        end
    })
end)
if not success then
    print("Erro ao criar DropdownKillPullMethod: " .. tostring(err))
end

-- Função para equipar o sofá
local function equipSofa()
    local backpack = LocalPlayer:WaitForChild("Backpack")
    local sofa = backpack:FindFirstChild("Couch") or LocalPlayer.Character:FindFirstChild("Couch")
    if not sofa then
        local args = { [1] = "PickingTools", [2] = "Couch" }
        local success = pcall(function()
            ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Too1l"):InvokeServer(unpack(args))
        end)
        if not success then
            return false
        end
        local timeout = tick() + 5
        repeat
            sofa = backpack:FindFirstChild("Couch")
            task.wait()
        until sofa or tick() > timeout
        if not sofa then
            return false
        end
    end
    if sofa.Parent ~= LocalPlayer.Character then
        sofa.Parent = LocalPlayer.Character
    end
    return true
end

-- Função para matar com sofá
local function killWithSofa(targetPlayer)
    if not targetPlayer or not targetPlayer.Character or not LocalPlayer.Character then
        return
    end
    if not equipSofa() then return end
    isFollowingKill = true
    originalPosition = LocalPlayer.Character:FindFirstChild("HumanoidRootPart").Position
end

-- Função para puxar com sofá
local function pullWithSofa(targetPlayer)
    if not targetPlayer or not targetPlayer.Character or not LocalPlayer.Character then
        return
    end
    if not equipSofa() then return end
    isFollowingPull = true
    originalPosition = LocalPlayer.Character:FindFirstChild("HumanoidRootPart").Position
end

-- Função para matar com ônibus
local function killWithBus(targetPlayer)
    if not targetPlayer or not targetPlayer.Character or not LocalPlayer.Character then return end
    local character = LocalPlayer.Character
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local myHRP = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not myHRP then return end
    savedPosition = myHRP.Position
    pcall(function()
        myHRP.Anchored = true
        myHRP.CFrame = CFrame.new(Vector3.new(1181.83, 76.08, -1158.83))
        task.wait(0.2)
        myHRP.Velocity = Vector3.zero
        myHRP.RotVelocity = Vector3.zero
        myHRP.Anchored = false
        humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
    end)
    task.wait(0.5)
    local args = { [1] = "DeleteAllVehicles" }
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
    end)
    args = { [1] = "PickingCar", [2] = "SchoolBus" }
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
    end)
    task.wait(2) -- Aumentado para evitar erro do CarClient
    local vehiclesFolder = Workspace:FindFirstChild("Vehicles")
    if not vehiclesFolder then return end
    local busName = LocalPlayer.Name .. "Car"
    local bus = vehiclesFolder:FindFirstChild(busName)
    if not bus then return end
    pcall(function()
        myHRP.Anchored = true
        myHRP.CFrame = CFrame.new(Vector3.new(1171.15, 79.45, -1166.2))
        task.wait(0.2)
        myHRP.Velocity = Vector3.zero
        myHRP.RotVelocity = Vector3.zero
        myHRP.Anchored = false
        humanoid:ChangeState(Enum.HumanoidStateType.Seated)
    end)
    local sitStart = tick()
    repeat
        task.wait()
        if tick() - sitStart > 10 then return end
    until humanoid.Sit
    running = true
    connection = RunService.Stepped:Connect(function()
        if not running then return end
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                pcall(function() part.CanCollide = false end)
            end
        end
    end)
    local lastUpdate = tick()
    local updateInterval = 0.15 -- Aumentado para reduzir carga
    flingConnection = RunService.Heartbeat:Connect(function()
        if not running then return end
        local targetCharacter = targetPlayer.Character or targetPlayer.CharacterAdded:Wait()
        local newTargetHRP = targetCharacter:FindFirstChild("HumanoidRootPart")
        local newTargetHumanoid = targetCharacter:FindFirstChild("Humanoid")
        if not newTargetHRP or not newTargetHumanoid then return end
        if not myHRP or not humanoid then
            running = false
            return
        end
        if tick() - lastUpdate < updateInterval then return end
        lastUpdate = tick()
        local offset = Vector3.new(math.random(-10, 10), 0, math.random(-10, 10))
        pcall(function()
            local targetPosition = newTargetHRP.Position + offset
            bus:PivotTo(
                CFrame.new(targetPosition) * CFrame.Angles(
                    math.rad(Workspace.DistributedGameTime * 4000),
                    math.rad(Workspace.DistributedGameTime * 5000),
                    math.rad(Workspace.DistributedGameTime * 6000)
                )
            )
        end)
        local playerSeated = false
        for _, seat in ipairs(bus:GetDescendants()) do
            if (seat:IsA("Seat") or seat:IsA("VehicleSeat")) and seat.Name ~= "VehicleSeat" then
                if seat.Occupant == newTargetHumanoid then
                    playerSeated = true
                    break
                end
            end
        end
        if playerSeated then
            running = false
            if connection then connection:Disconnect() connection = nil end
            if flingConnection then flingConnection:Disconnect() flingConnection = nil end
            pcall(function()
                bus:PivotTo(CFrame.new(Vector3.new(-76.6, -401.97, -84.26)))
            end)
            task.wait(0.5)
            local args = { [1] = "DeleteAllVehicles" }
            pcall(function()
                ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
            end)
            if character then
                local myHRP = character:FindFirstChild("HumanoidRootPart")
                if myHRP and savedPosition then
                    pcall(function()
                        myHRP.Anchored = true
                        myHRP.CFrame = CFrame.new(savedPosition + Vector3.new(0, 5, 0))
                        task.wait(0.2)
                        myHRP.Velocity = Vector3.zero
                        myHRP.RotVelocity = Vector3.zero
                        myHRP.Anchored = false
                        if humanoid then
                            humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                        end
                    end)
                end
            end
            if character then
                for _, part in ipairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        pcall(function()
                            part.CanCollide = true
                            part.Velocity = Vector3.zero
                            part.RotVelocity = Vector3.zero
                        end)
                    end
                end
            end
            local myHumanoid = character and character:FindFirstChild("Humanoid")
            if myHumanoid then
                pcall(function()
                    myHumanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
                end)
            end
            for _, seat in ipairs(Workspace:GetDescendants()) do
                if seat:IsA("Seat") or seat:IsA("VehicleSeat") then
                    pcall(function() seat.Disabled = false end)
                end
            end
            pcall(function()
                ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Clothe1s"):FireServer("CharacterSizeUp", 1)
            end)
        end
    end)
end

-- Lógica de matar e puxar
local followConnection
if followConnection then followConnection:Disconnect() end
followConnection = RunService.Heartbeat:Connect(function()
    if (isFollowingKill or isFollowingPull) and selectedPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and selectedPlayer.Character and selectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
        pcall(function()
            local targetPosition = selectedPlayer.Character.HumanoidRootPart.Position
            LocalPlayer.Character:SetPrimaryPartCFrame(
                CFrame.new(targetPosition) * CFrame.Angles(
                    math.rad(Workspace.DistributedGameTime * 4000),
                    math.rad(Workspace.DistributedGameTime * 5000),
                    math.rad(Workspace.DistributedGameTime * 6000)
                )
            )
        end)
    end
end)

local sitCheckConnection
if sitCheckConnection then sitCheckConnection:Disconnect() end
sitCheckConnection = RunService.Heartbeat:Connect(function()
    if (isFollowingKill or isFollowingPull) and selectedPlayer and selectedPlayer.Character and selectedPlayer.Character:FindFirstChild("Humanoid") then
        pcall(function()
            if selectedPlayer.Character.Humanoid.Sit then
                if isFollowingKill then
                    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        LocalPlayer.Character:SetPrimaryPartCFrame(CFrame.new(0, -500, 0))
                        task.wait(0.5)
                        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Too1l"):InvokeServer("PickingTools", "Couch")
                        task.wait(1)
                    end
                end
                isFollowingKill = false
                isFollowingPull = false
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and originalPosition then
                    local myHRP = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    local myHumanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
                    if myHRP then
                        pcall(function()
                            myHRP.Anchored = true
                            myHRP.CFrame = CFrame.new(originalPosition + Vector3.new(0, 5, 0))
                            task.wait(0.2)
                            myHRP.Velocity = Vector3.zero
                            myHRP.RotVelocity = Vector3.zero
                            myHRP.Anchored = false
                            if myHumanoid then
                                myHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                            end
                        end)
                    end
                    originalPosition = nil
                end
            end
        end)
    end
end)

-- Botão para iniciar matar
local KillButton
success, err = pcall(function()
    KillButton = Tab1:Button({
        Title = "Matar",
        Desc = "Inicia o matar com o método selecionado",
        Callback = function()
            if isFollowingKill or isFollowingPull or running then
                return
            end
            if not selectedPlayer then
                return
            end
            if not selectedKillPullMethod then
                return
            end
            if selectedKillPullMethod == "Sofá" then
                killWithSofa(selectedPlayer)
            elseif selectedKillPullMethod == "Ônibus" then
                killWithBus(selectedPlayer)
            end
        end
    })
end)
if not success then
    print("Erro ao criar KillButton: " .. tostring(err))
end

-- Botão para iniciar puxar
local PullButton
success, err = pcall(function()
    PullButton = Tab1:Button({
        Title = "Puxar",
        Desc = "Inicia o puxar com o método selecionado",
        Callback = function()
            if isFollowingKill or isFollowingPull or running then
                return
            end
            if not selectedPlayer then
                return
            end
            if not selectedKillPullMethod then
                return
            end
            if selectedKillPullMethod == "Sofá" then
                pullWithSofa(selectedPlayer)
            end
        end
    })
end)
if not success then
    print("Erro ao criar PullButton: " .. tostring(err))
end

-- Botão para parar matar ou puxar
local StopKillPullButton
success, err = pcall(function()
    StopKillPullButton = Tab1:Button({
        Title = "Parar (Matar ou Puxar)",
        Desc = "Para o movimento de matar ou puxar",
        Callback = function()
            isFollowingKill = false
            isFollowingPull = false
            local character = LocalPlayer.Character
            if character then
                for _, part in ipairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        pcall(function()
                            part.CanCollide = true
                            part.Velocity = Vector3.zero
                            part.RotVelocity = Vector3.zero
                        end)
                    end
                end
            end
            local myHumanoid = character and character:FindFirstChild("Humanoid")
            if myHumanoid then
                pcall(function()
                    myHumanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
                end)
            end
            for _, seat in ipairs(Workspace:GetDescendants()) do
                if seat:IsA("Seat") or seat:IsA("VehicleSeat") then
                    pcall(function() seat.Disabled = false end)
                end
            end
            if originalPosition then
                local myHRP = character and character:FindFirstChild("HumanoidRootPart")
                if myHRP then
                    pcall(function()
                        myHRP.Anchored = true
                        myHRP.CFrame = CFrame.new(originalPosition + Vector3.new(0, 5, 0))
                        task.wait(0.2)
                        myHRP.Velocity = Vector3.zero
                        myHRP.RotVelocity = Vector3.zero
                        myHRP.Anchored = false
                        if myHumanoid then
                            myHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                        end
                    end)
                end
                originalPosition = nil
            end
            local args = { [1] = "DeleteAllVehicles" }
            pcall(function()
                ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
            end)
        end
    })
end)
if not success then
    print("Erro ao criar StopKillPullButton: " .. tostring(err))
end

-- Dropdown para selecionar método de fling
local DropdownFlingMethod
success, err = pcall(function()
    DropdownFlingMethod = Tab1:Dropdown({
        Title = "Selecionar Método de Fling",
        Desc = "Escolha o método para aplicar fling",
        Values = {"Sofá", "Ônibus", "Bola", "Barco"},
        Callback = function(value)
            selectedFlingMethod = value
        end
    })
end)
if not success then
    print("Erro ao criar DropdownFlingMethod: " .. tostring(err))
end

-- Função para equipar a bola
local function equipBola()
    local backpack = LocalPlayer:WaitForChild("Backpack")
    local bola = backpack:FindFirstChild("SoccerBall") or LocalPlayer.Character:FindFirstChild("SoccerBall")
    if not bola then
        local args = { [1] = "PickingTools", [2] = "SoccerBall" }
        local success = pcall(function()
            ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Too1l"):InvokeServer(unpack(args))
        end)
        if not success then
            return false
        end
        local timeout = tick() + 5
        repeat
            bola = backpack:FindFirstChild("SoccerBall")
            task.wait()
        until bola or tick() > timeout
        if not bola then
            return false
        end
    end
    if bola.Parent ~= LocalPlayer.Character then
        bola.Parent = LocalPlayer.Character
    end
    return true
end

-- Função para fling com bola
local function flingWithBall(targetPlayer)
    if not targetPlayer or not targetPlayer.Character then
        return
    end
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local myHRP = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not myHRP then
        return
    end
    if not equipBola() then return end
    task.wait(0.5)
    local args = { [1] = "PlayerWantsToDeleteTool", [2] = "SoccerBall" }
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Clea1rTool1s"):FireServer(unpack(args))
    end)
    local workspaceCom = Workspace:FindFirstChild("WorkspaceCom")
    if not workspaceCom then return end
    local soccerBalls = workspaceCom:FindFirstChild("001_SoccerBalls")
    if not soccerBalls then return end
    soccerBall = soccerBalls:FindFirstChild("Soccer" .. LocalPlayer.Name)
    if not soccerBall then return end
    originalProperties = {
        Anchored = soccerBall.Anchored,
        CanCollide = soccerBall.CanCollide,
        CanTouch = soccerBall.CanTouch
    }
    pcall(function()
        soccerBall.Anchored = false
        soccerBall.CanCollide = true
        soccerBall.CanTouch = true
    end)
    savedPosition = myHRP.Position
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            pcall(function() part.CanCollide = false end)
        end
    end
    if humanoid then
        pcall(function()
            humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
            humanoid.Sit = false
        end)
    end
    for _, seat in ipairs(Workspace:GetDescendants()) do
        if seat:IsA("Seat") or seat:IsA("VehicleSeat") then
            pcall(function() seat.Disabled = true end)
        end
    end
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Clothe1s"):FireServer("CharacterSizeDown", 4)
    end)
    running = true
    local lastFlingTime = 0
    connection = RunService.Heartbeat:Connect(function()
        if not running or not targetPlayer.Character then return end
        local hrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        local hum = targetPlayer.Character:FindFirstChild("Humanoid")
        local myHRP = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp or not hum or not myHRP then return end
        local moveDir = hum.MoveDirection
        local isStill = moveDir.Magnitude < 0.1
        local isSitting = hum.Sit
        pcall(function()
            if isSitting then
                local y = math.sin(tick() * 50) * 2
                soccerBall.CFrame = CFrame.new(hrp.Position + Vector3.new(0, 0.75 + y, 0))
            elseif isStill then
                local z = math.sin(tick() * 50) * 3
                soccerBall.CFrame = CFrame.new(hrp.Position + Vector3.new(0, 0.75, z))
            else
                local offset = moveDir.Unit * math.clamp(hrp.Velocity.Magnitude * 0.15, 5, 12)
                soccerBall.CFrame = CFrame.new(hrp.Position + offset + Vector3.new(0, 0.75, 0))
            end
            myHRP.CFrame = CFrame.new(soccerBall.Position + Vector3.new(0, 1, 0))
        end)
    end)
    flingConnection = RunService.Heartbeat:Connect(function()
        if not running or not targetPlayer.Character then return end
        local hrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        local dist = (soccerBall.Position - hrp.Position).Magnitude
        if dist < 4 and tick() - lastFlingTime > 0.4 then
            lastFlingTime = tick()
            for _, part in ipairs(targetPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    pcall(function() part.CanCollide = false end)
                end
            end
            local fling = Instance.new("BodyVelocity")
            fling.MaxForce = Vector3.new(1e9, 1e9, 1e9)
            fling.Velocity = Vector3.new(math.random(-3, 3), 1, math.random(-3, 3)).Unit * 12000 + Vector3.new(0, 12000, 0)
            fling.Parent = hrp
            task.delay(0.3, function()
                fling:Destroy()
                for _, part in ipairs(targetPlayer.Character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        pcall(function() part.CanCollide = true end)
                    end
                end
            end)
        end
    end)
end

-- Função para fling com sofá
local function flingWithSofa(targetPlayer)
    if not targetPlayer or not targetPlayer.Character or not LocalPlayer.Character then
        return
    end
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local myHRP = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not myHRP then
        return
    end
    savedPosition = myHRP.Position
    if not equipSofa() then return end
    task.wait(0.5)
    couch = character:FindFirstChild("Couch")
    if not couch then
        for _, obj in ipairs(Workspace:GetDescendants()) do
            if (obj.Name == "Couch" or obj.Name == "Couch" .. LocalPlayer.Name) and (obj:IsA("BasePart") or obj:IsA("Tool")) then
                couch = obj
                break
            end
        end
    end
    if not couch then return end
    if couch:IsA("BasePart") then
        originalProperties = {
            Anchored = couch.Anchored,
            CanCollide = couch.CanCollide,
            CanTouch = couch.CanTouch
        }
        pcall(function()
            couch.Anchored = false
            couch.CanCollide = true
            couch.CanTouch = true
        end)
    end
    running = true
    connection = RunService.Stepped:Connect(function()
        if not running then return end
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                pcall(function() part.CanCollide = false end)
            end
        end
    end)
    local startTime = tick()
    local walkFlingInstance = nil
    flingConnection = RunService.Heartbeat:Connect(function()
        if not running then return end
        if not targetPlayer or not targetPlayer.Character then
            running = false
            return
        end
        local newTargetHRP = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        local newTargetHumanoid = targetPlayer.Character:FindFirstChild("Humanoid")
        if not newTargetHRP or not newTargetHumanoid then
            running = false
            return
        end
        if not myHRP or not humanoid then
            running = false
            return
        end
        pcall(function()
            local targetPosition = newTargetHRP.Position
            character:SetPrimaryPartCFrame(
                CFrame.new(targetPosition) * CFrame.Angles(
                    math.rad(Workspace.DistributedGameTime * 4000),
                    math.rad(Workspace.DistributedGameTime * 5000),
                    math.rad(Workspace.DistributedGameTime * 6000)
                )
            )
        end)
        if newTargetHumanoid.Sit then
            running = false
            flingConnection:Disconnect()
            flingConnection = nil
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    pcall(function() part.CanCollide = false end)
                end
            end
            walkFlingInstance = Instance.new("BodyVelocity")
            walkFlingInstance.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            walkFlingInstance.Velocity = Vector3.new(math.random(-5, 5), 5, math.random(-5, 5)).Unit * 1000000 + Vector3.new(0, 1000000, 0)
            walkFlingInstance.Parent = myHRP
            pcall(function()
                myHRP.Anchored = true
                myHRP.CFrame = CFrame.new(Vector3.new(-59599.73, 2040070.50, -293391.16))
                myHRP.Anchored = false
            end)
            local spinStart = tick()
            local spinConnection
            spinConnection = RunService.Heartbeat:Connect(function()
                if tick() - spinStart >= 0.5 then
                    spinConnection:Disconnect()
                    return
                end
                pcall(function()
                    character:SetPrimaryPartCFrame(
                        myHRP.CFrame * CFrame.Angles(
                            math.rad(Workspace.DistributedGameTime * 4000),
                            math.rad(Workspace.DistributedGameTime * 5000),
                            math.rad(Workspace.DistributedGameTime * 6000)
                        )
                    )
                end)
            end)
            task.wait(0.5)
            local args = { [1] = "PlayerWantsToDeleteTool", [2] = "Couch" }
            pcall(function()
                ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Clea1rTool1s"):FireServer(unpack(args))
            end)
            pcall(function()
                myHRP.Anchored = true
                myHRP.CFrame = CFrame.new(savedPosition + Vector3.new(0, 5, 0))
                task.wait(0.2)
                myHRP.Velocity = Vector3.zero
                myHRP.RotVelocity = Vector3.zero
                myHRP.Anchored = false
                if humanoid then
                    humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                end
            end)
            if walkFlingInstance then
                walkFlingInstance:Destroy()
                for _, part in ipairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        pcall(function() part.CanCollide = true end)
                    end
                end
            end
        end
    end)
end

-- Função para fling com ônibus
local function flingWithBus(targetPlayer)
    if not targetPlayer or not targetPlayer.Character or not LocalPlayer.Character then
        return
    end
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local myHRP = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not myHRP then
        return
    end
    savedPosition = myHRP.Position
    pcall(function()
        myHRP.Anchored = true
        myHRP.CFrame = CFrame.new(Vector3.new(1181.83, 76.08, -1158.83))
        task.wait(0.2)
        myHRP.Velocity = Vector3.zero
        myHRP.RotVelocity = Vector3.zero
        myHRP.Anchored = false
        humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
    end)
    task.wait(0.5)
    local args = { [1] = "DeleteAllVehicles" }
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
    end)
    args = { [1] = "PickingCar", [2] = "SchoolBus" }
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
    end)
    task.wait(2) -- Aumentado para evitar erro do CarClient
    local vehiclesFolder = Workspace:FindFirstChild("Vehicles")
    if not vehiclesFolder then return end
    local busName = LocalPlayer.Name .. "Car"
    local bus = vehiclesFolder:FindFirstChild(busName)
    if not bus then return end
    pcall(function()
        myHRP.Anchored = true
        myHRP.CFrame = CFrame.new(Vector3.new(1171.15, 79.45, -1166.2))
        task.wait(0.2)
        myHRP.Velocity = Vector3.zero
        myHRP.RotVelocity = Vector3.zero
        myHRP.Anchored = false
        humanoid:ChangeState(Enum.HumanoidStateType.Seated)
    end)
    local sitStart = tick()
    repeat
        task.wait()
        if tick() - sitStart > 10 then return end
    until humanoid.Sit
    running = true
    connection = RunService.Stepped:Connect(function()
        if not running then return end
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                pcall(function() part.CanCollide = false end)
            end
        end
    end)
    local startTime = tick()
    local walkFlingInstanceBus = nil
    local walkFlingInstancePlayer = nil
    flingConnection = RunService.Heartbeat:Connect(function()
        if not running then return end
        if not targetPlayer or not targetPlayer.Character then
            running = false
            return
        end
        local newTargetHRP = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        local newTargetHumanoid = targetPlayer.Character:FindFirstChild("Humanoid")
        if not newTargetHRP or not newTargetHumanoid then
            running = false
            return
        end
        if not myHRP or not humanoid then
            running = false
            return
        end
        local offset = Vector3.new(math.random(-10, 10), 0, math.random(-10, 10))
        pcall(function()
            local targetPosition = newTargetHRP.Position + offset
            bus:PivotTo(
                CFrame.new(targetPosition) * CFrame.Angles(
                    math.rad(Workspace.DistributedGameTime * 4000),
                    math.rad(Workspace.DistributedGameTime * 5000),
                    math.rad(Workspace.DistributedGameTime * 6000)
                )
            )
        end)
        local playerSeated = false
        for _, seat in ipairs(bus:GetDescendants()) do
            if (seat:IsA("Seat") or seat:IsA("VehicleSeat")) and seat.Name ~= "VehicleSeat" then
                if seat.Occupant == newTargetHumanoid then
                    playerSeated = true
                    break
                end
            end
        end
        if playerSeated then
            running = false
            flingConnection:Disconnect()
            flingConnection = nil
            pcall(function()
                bus:PivotTo(CFrame.new(Vector3.new(-59599.73, 2040070.50, -293391.16)))
            end)
            local busHRP = bus:FindFirstChild("Body") and bus.Body:FindFirstChild("BusBody")
            if busHRP then
                walkFlingInstanceBus = Instance.new("BodyVelocity")
                walkFlingInstanceBus.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                walkFlingInstanceBus.Velocity = Vector3.new(math.random(-5, 5), 5, math.random(-5, 5)).Unit * 1000000 + Vector3.new(0, 1000000, 0)
                walkFlingInstanceBus.Parent = busHRP
            end
            walkFlingInstancePlayer = Instance.new("BodyVelocity")
            walkFlingInstancePlayer.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            walkFlingInstancePlayer.Velocity = Vector3.new(math.random(-5, 5), 5, math.random(-5, 5)).Unit * 1000000 + Vector3.new(0, 1000000, 0)
            walkFlingInstancePlayer.Parent = myHRP
            task.wait(0.5)
            local args = { [1] = "DeleteAllVehicles" }
            pcall(function()
                ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
            end)
            if walkFlingInstanceBus then
                walkFlingInstanceBus:Destroy()
            end
            if walkFlingInstancePlayer then
                walkFlingInstancePlayer:Destroy()
                for _, part in ipairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        pcall(function() part.CanCollide = true end)
                    end
                end
            end
            pcall(function()
                myHRP.Anchored = true
                myHRP.CFrame = CFrame.new(savedPosition + Vector3.new(0, 5, 0))
                task.wait(0.2)
                myHRP.Velocity = Vector3.zero
                myHRP.RotVelocity = Vector3.zero
                myHRP.Anchored = false
                if humanoid then
                    humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                end
            end)
        end
    end)
end

-- Função para fling com barco (mais potente e contínuo)
local function flingWithBoat(targetPlayer)
    if not targetPlayer or not targetPlayer.Character or not LocalPlayer.Character then return end
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local myHRP = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not myHRP then return end
    savedPosition = myHRP.Position
    pcall(function()
        myHRP.Anchored = true
        myHRP.CFrame = CFrame.new(Vector3.new(-3359.52, -5.05, -501.94))
        task.wait(0.2)
        myHRP.Velocity = Vector3.zero
        myHRP.RotVelocity = Vector3.zero
        myHRP.Anchored = false
        humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
    end)
    local args = { [1] = "DeleteAllVehicles" }
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
    end)
    task.wait(0.4)
    args = { [1] = "PickingBoat", [2] = "MilitaryBoatFree" }
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
    end)
    task.wait(2) -- Aumentado para evitar erro do CarClient
Infinity Yield is a powerful, open-source Roblox admin command script that provides a wide range of commands for manipulating the game environment, managing players, and debugging scripts. It is widely used by developers and players for testing, trolling, or managing game instances in Roblox. Below is a detailed guide on how to use Infinity Yield, including setup, commands, and troubleshooting.

---

## Table of Contents
1. [What is Infinity Yield?](#what-is-infinity-yield)
2. [How to Install Infinity Yield](#how-to-install-infinity-yield)
3. [Using Infinity Yield](#using-infinity-yield)
   - [Opening the Command Bar](#opening-the-command-bar)
   - [Command Syntax](#command-syntax)
4. [Common Commands](#common-commands)
   - [Player Manipulation](#player-manipulation)
   - [Teleportation](#teleportation)
   - [Game Manipulation](#game-manipulation)
   - [Trolling Commands](#trolling-commands)
   - [Utility Commands](#utility-commands)
5. [Troubleshooting](#troubleshooting)
6. [Tips and Best Practices](#tips-and-best-practices)
7. [Frequently Asked Questions](#frequently-asked-questions)

---

## What is Infinity Yield?

Infinity Yield is a Lua-based Roblox admin script created by EdgeIY and contributors. It allows users to execute commands in Roblox games to control players, modify the environment, and perform various actions without needing server-side admin privileges. It is executed through a Roblox script executor like Synapse X, Krnl, or Fluxus.

**Key Features:**
- Over 200 commands for player control, teleportation, game manipulation, and more.
- Works in most Roblox games, even those without built-in admin systems.
- Open-source and regularly updated.
- Lightweight and easy to use with a command bar interface.

**Note:** Using Infinity Yield in games may violate Roblox's Terms of Service, potentially leading to bans. Use it responsibly, preferably in private servers or games where you have permission.

---

## How to Install Infinity Yield

To use Infinity Yield, you need a Roblox script executor and the Infinity Yield script. Follow these steps:

1. **Install a Script Executor**:
   - Download a trusted executor such as:
     - **Synapse X** (paid, highly reliable)
     - **Krnl** (free, good performance)
     - **Fluxus** (free, beginner-friendly)
     - **JJSploit** (free, but less reliable)
   - Ensure the executor is compatible with your system (Windows/Mac).
   - Install the executor following its official instructions.

2. **Download Infinity Yield**:
   - Get the script from the official source:
     ```lua
     loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
     ```
   - Copy this script to your clipboard.

3. **Inject the Script**:
   - Launch Roblox and join a game.
   - Open your script executor.
   - Paste the Infinity Yield script into the executor's script editor.
   - Click "Execute" or "Inject" to run the script.

4. **Verify Installation**:
   - If successful, you should see a notification in the game chat or a command bar appear (depending on the executor).
   - Type a command like `;version` to confirm Infinity Yield is running.

---

## Using Infinity Yield

### Opening the Command Bar

Once Infinity Yield is injected, you can access the command bar:
- **Default Method**: Press the **semicolon (`;`)** key to open the command bar.
- Alternatively, some executors display a GUI with a text box for entering commands.
- If the command bar doesn't appear, check your executor's keybinds or try re-injecting the script.

### Command Syntax

Infinity Yield commands follow a simple syntax:
