local WindUI = loadstring(game:HttpGet("https://tree-hub.vercel.app/api/UI/WindUI"))()
local Version = "1.4.0"

local Window = WindUI:CreateWindow({
    Title = "Lolyta troll78",
    Icon = "door-open",
    Author = "Lolycon666",
    Folder = "Lolyta 666",
    Size = UDim2.fromOffset(580, 460),
    KeySystem = {
        Key = "666",
        Note = "pode nao man",
        URL = "",
        SaveKey = true,
    },
    Transparent = true,
    Theme = "Dark",
    SideBarWidth = 200,
    HasOutline = false,
})

Window:EditOpenButton({
    Title = "Lolyta troll",
    Icon = "align-justify",
    CornerRadius = UDim.new(0, 10),
    StrokeThickness = 3,
    Color = ColorSequence.new(Color3.fromHex("FF0F7B"), Color3.fromHex("F89B29"))
})

-- === Abas da Interface === --
local Tab1 = Window:Tab({ Title = "troll", Icon = "Ball" })

-----------------------------------------------------------------------------------------------------------------------------------------
                                          -- === Tab 1: Troll === --
-----------------------------------------------------------------------------------------------------------------------------------------

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

-- Variáveis compartilhadas
local selectedPlayer = nil
local isFollowingKill = false
local isFollowingPull = false
local originalPosition = nil
local isSpectating = false
local spectatedPlayer = nil
local characterConnection = nil
local soccerBall = nil
local running = false
local connection, flingConnection
local originalProperties = {}
local savedPosition = nil

-- Cria um RemoteEvent para comunicação com o servidor
local SetNetworkOwnerEvent = Instance.new("RemoteEvent")
SetNetworkOwnerEvent.Name = "SetNetworkOwnerEvent_" .. tostring(math.random(1000, 9999))
SetNetworkOwnerEvent.Parent = ReplicatedStorage

-- Cria um script no servidor para lidar com o RemoteEvent
local serverScriptCode = [[
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local event = ReplicatedStorage:WaitForChild("]] .. SetNetworkOwnerEvent.Name .. [[")
    
    event.OnServerEvent:Connect(function(player, part, networkOwner)
        if part and part:IsA("BasePart") then
            pcall(function()
                part:SetNetworkOwner(networkOwner)
                part.Anchored = false
                part.CanCollide = true
                part.CanTouch = true
            end)
        end
    end)
]]

local success, errorMessage = pcall(function()
    loadstring(serverScriptCode)()
end)
if not success then
    warn("Erro ao criar script no servidor: " .. tostring(errorMessage))
end

-- Função para obter os nomes dos jogadores, excluindo o jogador local
local function getPlayerNames()
    local playerNames = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playerNames, player.Name)
        end
    end
    return playerNames
end

-- Função para atualizar o dropdown
local function updateDropdown(dropdown)
    local success, errorMessage = pcall(function()
        local playerNames = getPlayerNames()
        dropdown:Refresh(playerNames)
        if selectedPlayer and not table.find(playerNames, selectedPlayer.Name) then
            dropdown:SetValue("")
            selectedPlayer = nil
            print("Jogador anterior saiu do jogo. Seleção resetada.")
        end
    end)
    if not success then
        warn("Erro ao atualizar dropdown: " .. tostring(errorMessage))
    end
end

-- Função para visualizar um jogador
local function spectatePlayer(playerName)
    if characterConnection then
        characterConnection:Disconnect()
        characterConnection = nil
    end

    local targetPlayer = Players:FindFirstChild(playerName)
    if targetPlayer and targetPlayer ~= LocalPlayer then
        spectatedPlayer = targetPlayer
        isSpectating = true
        print("Visualizando jogador: " .. targetPlayer.Name)

        local function updateCamera()
            if not isSpectating or not spectatedPlayer then
                return
            end
            if spectatedPlayer.Character and spectatedPlayer.Character:FindFirstChild("Humanoid") then
                Workspace.CurrentCamera.CameraSubject = spectatedPlayer.Character.Humanoid
            else
                Workspace.CurrentCamera.CameraSubject = nil
            end
        end

        updateCamera()

        characterConnection = RunService.Heartbeat:Connect(function()
            if not isSpectating then
                characterConnection:Disconnect()
                characterConnection = nil
                return
            end
            local success, errorMessage = pcall(updateCamera)
            if not success then
                warn("Erro ao atualizar câmera no modo visualização: " .. tostring(errorMessage))
                stopSpectating()
            end
        end)

        spectatedPlayer.CharacterAdded:Connect(function()
            if isSpectating then
                updateCamera()
            end
        end)
    else
        print("Jogador inválido ou não encontrado para modo visualização.")
        isSpectating = false
        spectatedPlayer = nil
    end
end

-- Função para parar de visualizar
local function stopSpectating()
    if characterConnection then
        characterConnection:Disconnect()
        characterConnection = nil
    end

    isSpectating = false
    spectatedPlayer = nil

    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        Workspace.CurrentCamera.CameraSubject = LocalPlayer.Character.Humanoid
        Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
        print("Parando de visualizar. Voltando à visão do jogador local.")
    else
        Workspace.CurrentCamera.CameraSubject = nil
        Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
        print("Nenhum personagem local encontrado. Câmera redefinida.")
    end
end

-- Detecta quando o jogador local morre e reseta a câmera
LocalPlayer.CharacterAdded:Connect(function(character)
    if isSpectating then
        stopSpectating()
        print("Você morreu. Câmera voltou para o seu personagem.")
    end
end)

-- Botão System Broken
Tab1:Button({
    Title = "System Broken",
    Desc = "Universal",
    Callback = function()
        local success, errorMessage = pcall(function()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/H20CalibreYT/SystemBroken/main/script"))()
        end)
        if not success then
            warn("Erro ao carregar System Broken: " .. tostring(errorMessage))
        end
    end,
})

Tab1:Paragraph({ 
    Title = "Execute o System Broken e ative o VoidProtection", 
    Desc = "Faça isso antes de usar as funções abaixo!!!"
})

-- Dropdown para selecionar jogador
local DropdownPlayer = Tab1:Dropdown({
    Title = "Selecionar Jogador",
    Desc = "Escolha um jogador para matar, puxar ou aplicar fling",
    Value = "",
    Multi = false,
    AllowNone = true,
    Values = getPlayerNames(),
    Callback = function(selectedPlayerName)
        if selectedPlayerName == "" or selectedPlayerName == nil then
            selectedPlayer = nil
            print("Nenhum jogador selecionado.")
            if running then
                running = false
                if connection then connection:Disconnect() end
                if flingConnection then flingConnection:Disconnect() end
                stopSpectating()
            end
            isFollowingKill = false
            isFollowingPull = false
        else
            selectedPlayer = Players:FindFirstChild(selectedPlayerName)
            print("Jogador selecionado: " .. selectedPlayerName)
            if isSpectating then
                stopSpectating()
                spectatePlayer(selectedPlayerName)
            end
            if running then
                print("Jogador do fling atualizado para: " .. selectedPlayerName)
            end
        end
    end,
})

-- Botão para atualizar a lista de jogadores
Tab1:Button({
    Title = "Atualizar Lista de Jogadores",
    Desc = "Atualiza a lista de jogadores no dropdown",
    Callback = function()
        updateDropdown(DropdownPlayer)
        print("Lista de jogadores atualizada!")
    end,
})

-- Toggle para visualizar jogador
local SpectateToggle = Tab1:Toggle({
    Title = "Visualizar Jogador",
    Desc = "Ativa/desativa a visualização do jogador selecionado",
    Default = false,
    Callback = function(state)
        if state then
            if selectedPlayer then
                local success, errorMessage = pcall(spectatePlayer, selectedPlayer.Name)
                if not success then
                    warn("Erro ao ativar modo visualização: " .. tostring(errorMessage))
                    SpectateToggle:SetValue(false)
                end
            else
                print("Selecione um jogador antes de ativar a visualização.")
                SpectateToggle:SetValue(false)
            end
        else
            local success, errorMessage = pcall(stopSpectating)
            if not success then
                warn("Erro ao desativar modo visualização: " .. tostring(errorMessage))
            end
        end
    end,
})

-- Botão para iniciar matar
Tab1:Button({
    Title = "Iniciar Matar com o Sofá",
    Desc = "Clique para começar a matar o jogador selecionado",
    Callback = function()
        if isFollowingKill or isFollowingPull then
            print("Uma ação (matar ou puxar) já está ativa. Use o botão Parar primeiro.")
            return
        end
        if not selectedPlayer or not selectedPlayer.Character or not LocalPlayer.Character then
            warn("Selecione um jogador válido antes de iniciar!")
            return
        end

        -- Verifica se o sofá está no inventário
        local backpack = LocalPlayer:WaitForChild("Backpack")
        local sofa = backpack:FindFirstChild("Couch")

        if not sofa then
            -- Pega o sofá se não estiver na mochila
            local args = { [1] = "PickingTools", [2] = "Couch" }
            ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Too1l"):InvokeServer(unpack(args))

            repeat
                sofa = backpack:FindFirstChild("Couch")
                task.wait()
            until sofa or task.wait(5) -- Timeout de 5 segundos
            if not sofa then
                warn("Falha ao pegar o sofá!")
                return
            end
        end

        -- Equipa o sofá
        sofa.Parent = LocalPlayer.Character
        print("Sofá equipado!")

        isFollowingKill = true
        originalPosition = LocalPlayer.Character:FindFirstChild("HumanoidRootPart").Position
        print("Iniciando matar para: " .. selectedPlayer.Name)
    end,
})

-- Botão para iniciar puxar
Tab1:Button({
    Title = "Iniciar Puxar",
    Desc = "Clique para começar a puxar o jogador selecionado",
    Callback = function()
        if isFollowingKill or isFollowingPull then
            print("Uma ação (matar ou puxar) já está ativa. Use o botão Parar primeiro.")
            return
        end
        if not selectedPlayer or not selectedPlayer.Character or not LocalPlayer.Character then
            warn("Selecione um jogador válido antes de iniciar!")
            return
        end

        -- Verifica se o sofá está no inventário
        local backpack = LocalPlayer:WaitForChild("Backpack")
        local sofa = backpack:FindFirstChild("Couch")

        if not sofa then
            -- Pega o sofá se não estiver na mochila
            local args = { [1] = "PickingTools", [2] = "Couch" }
            ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Too1l"):InvokeServer(unpack(args))

            repeat
                sofa = backpack:FindFirstChild("Couch")
                task.wait()
            until sofa or task.wait(5) -- Timeout de 5 segundos
            if not sofa then
                warn("Falha ao pegar o sofá!")
                return
            end
        end

        -- Equipa o sofá
        sofa.Parent = LocalPlayer.Character
        print("Sofá equipado!")

        isFollowingPull = true
        originalPosition = LocalPlayer.Character:FindFirstChild("HumanoidRootPart").Position
        print("Iniciando puxar para: " .. selectedPlayer.Name)
    end,
})

-- Botão para parar matar ou puxar
Tab1:Button({
    Title = "Parar (Matar ou Puxar)",
    Desc = "Para o movimento de matar ou puxar",
    Callback = function()
        isFollowingKill = false
        isFollowingPull = false

        for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
                part.Velocity = Vector3.zero
                part.RotVelocity = Vector3.zero
            end
        end

        -- Restaura a capacidade de sentar
        local myHumanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
        if myHumanoid then
            myHumanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        end

        for _, seat in ipairs(Workspace:GetDescendants()) do
            if seat:IsA("Seat") or seat:IsA("VehicleSeat") then
                seat.Disabled = false
            end
        end

        -- Teleporta com segurança
        if originalPosition then
            local myHRP = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if myHRP then
                myHRP.Anchored = true
                myHRP.CFrame = CFrame.new(originalPosition + Vector3.new(0, 5, 0))
                task.wait(0.2)
                myHRP.Velocity = Vector3.zero
                myHRP.RotVelocity = Vector3.zero
                myHRP.Anchored = false
                if myHumanoid then
                    myHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                end
            end
            originalPosition = nil
        end
        print("Movimento parado. Personagem voltou à posição original.")
    end,
})

-- Lógica de matar e puxar
local followConnection
if followConnection then followConnection:Disconnect() end
followConnection = RunService.Heartbeat:Connect(function()
    if (isFollowingKill or isFollowingPull) and selectedPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and selectedPlayer.Character and selectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local success, errorMessage = pcall(function()
            local targetPosition = selectedPlayer.Character.HumanoidRootPart.Position
            LocalPlayer.Character:SetPrimaryPartCFrame(
                CFrame.new(targetPosition) * CFrame.Angles(
                    math.rad(Workspace.DistributedGameTime * 12000),
                    math.rad(Workspace.DistributedGameTime * 15000),
                    math.rad(Workspace.DistributedGameTime * 18000)
                )
            )
        end)
        if not success then
            warn("Erro no loop de matar/puxar: " .. tostring(errorMessage))
            isFollowingKill = false
            isFollowingPull = false
        end
    end
end)

local sitCheckConnection
if sitCheckConnection then sitCheckConnection:Disconnect() end
sitCheckConnection = RunService.Heartbeat:Connect(function()
    if (isFollowingKill or isFollowingPull) and selectedPlayer and selectedPlayer.Character and selectedPlayer.Character:FindFirstChild("Humanoid") then
        local success, errorMessage = pcall(function()
            if selectedPlayer.Character.Humanoid.Sit then
                print("Jogador sentado! Interrompendo ação...")
                
                if isFollowingKill then
                    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        LocalPlayer.Character:SetPrimaryPartCFrame(CFrame.new(0, -500, 0))
                        task.wait(0.5)
                        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Too1l"):InvokeServer("PickingTools", "Couch")
                        task.wait(1)
                    end
                end
                
                isFollowingKill = false
                isFollowingPull = false
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and originalPosition then
                    local myHRP = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    local myHumanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
                    if myHRP then
                        myHRP.Anchored = true
                        myHRP.CFrame = CFrame.new(originalPosition + Vector3.new(0, 5, 0))
                        task.wait(0.2)
                        myHRP.Velocity = Vector3.zero
                        myHRP.RotVelocity = Vector3.zero
                        myHRP.Anchored = false
                        if myHumanoid then
                            myHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                        end
                    end
                    print("Personagem voltou à posição original em pé!")
                end
                originalPosition = nil
            end
        end)
        if not success then
            warn("Erro na verificação de assento: " .. tostring(errorMessage))
            isFollowingKill = false
            isFollowingPull = false
        end
    end
end)



-----------------------------------------------------------------------------------------------------


-- BOTÃO INICIAR FLING
Tab1:Button({
    Title = "Iniciar Fling",
    Desc = "Inicia o fling no jogador selecionado",
    Callback = function()
        if running then
            print("O fling já está ativo. Use o botão 'Parar Fling' primeiro.")
            return
        end
        if not selectedPlayer or not selectedPlayer.Character then
            warn("Selecione um jogador válido antes de iniciar o fling!")
            return
        end

        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local myHRP = character:FindFirstChild("HumanoidRootPart")
        if not humanoid or not myHRP then
            warn("Seu personagem ainda não está totalmente carregado.")
            return
        end

        -- Função para equipar a bola
        local function equipBola()
            local backpack = LocalPlayer:WaitForChild("Backpack")
            local bola = backpack:FindFirstChild("SoccerBall") or character:FindFirstChild("SoccerBall")

            if not bola then
                -- Pega a bola se não estiver no inventário ou equipada
                local args = {
                    [1] = "PickingTools",
                    [2] = "SoccerBall"
                }
                local success, err = pcall(function()
                    ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Too1l"):InvokeServer(unpack(args))
                end)
                if not success then
                    warn("Erro ao pegar a bola: " .. tostring(err))
                    return false
                end

                -- Espera a bola aparecer na mochila
                repeat
                    bola = backpack:FindFirstChild("SoccerBall")
                    task.wait()
                until bola or task.wait(5) -- Timeout de 5 segundos
                if not bola then
                    warn("Falha ao pegar a bola!")
                    return false
                end
            end

            -- Se a bola não estiver equipada, equipa
            if bola.Parent ~= character then
                bola.Parent = character
                print("Bola equipada!")
            else
                print("Bola já está equipada!")
            end
            return true
        end

        -- Equipa a bola
        if not equipBola() then
            return
        end

        -- Espera 0.5 segundos
        task.wait(0.5)

        -- Deleta a bola do inventário
        local args = {
            [1] = "PlayerWantsToDeleteTool",
            [2] = "SoccerBall"
        }
        pcall(function()
            ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Clea1rTool1s"):FireServer(unpack(args))
        end)
        print("Bola removida do inventário!")

        -- Encontra a bola no Workspace
        local workspaceCom = Workspace:FindFirstChild("WorkspaceCom")
        if not workspaceCom then
            warn("WorkspaceCom não encontrado!")
            return
        end
        local soccerBalls = workspaceCom:FindFirstChild("001_SoccerBalls")
        if not soccerBalls then
            warn("001_SoccerBalls não encontrado!")
            return
        end

        soccerBall = soccerBalls:FindFirstChild("Soccer" .. LocalPlayer.Name)
        if not soccerBall then
            warn("Bola de futebol não encontrada em Workspace.WorkspaceCom.001_SoccerBalls.Soccer" .. LocalPlayer.Name)
            return
        end

        -- Configura a bola
        originalProperties = {
            Anchored = soccerBall.Anchored,
            CanCollide = soccerBall.CanCollide,
            CanTouch = soccerBall.CanTouch
        }
        soccerBall.Anchored = false
        soccerBall.CanCollide = true
        soccerBall.CanTouch = true
        pcall(function() soccerBall:SetNetworkOwner(nil) end)

        -- Salva a posição inicial
        savedPosition = myHRP.Position

        -- Ativa o NoClip
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end

        -- Desativa capacidade de sentar
        if humanoid then
            humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
            humanoid.Sit = false
        end

        -- Bloqueia interações com assentos
        for _, seat in ipairs(Workspace:GetDescendants()) do
            if seat:IsA("Seat") or seat:IsA("VehicleSeat") then
                seat.Disabled = true
            end
        end

        -- Reduz o tamanho do personagem
        pcall(function()
            ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Clothe1s"):FireServer("CharacterSizeDown", 4)
        end)

        running = true
        local lastFlingTime = 0

        -- Loop de movimento da bola
        connection = RunService.Heartbeat:Connect(function()
            if not running or not selectedPlayer.Character then return end
            local hrp = selectedPlayer.Character:FindFirstChild("HumanoidRootPart")
            local hum = selectedPlayer.Character:FindFirstChild("Humanoid")
            local myHRP = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if not hrp or not hum or not myHRP then return end

            local moveDir = hum.MoveDirection
            local isStill = moveDir.Magnitude < 0.1
            local isSitting = hum.Sit

            if isSitting then
                -- Bola se move rapidamente para cima e para baixo
                local y = math.sin(tick() * 50) * 2
                soccerBall.CFrame = CFrame.new(hrp.Position + Vector3.new(0, 0.75 + y, 0))
            elseif isStill then
                -- Bola se move rapidamente para frente e para trás
                local z = math.sin(tick() * 50) * 3
                soccerBall.CFrame = CFrame.new(hrp.Position + Vector3.new(0, 0.75, z))
            else
                local offset = moveDir.Unit * math.clamp(hrp.Velocity.Magnitude * 0.15, 5, 12)
                soccerBall.CFrame = CFrame.new(hrp.Position + offset + Vector3.new(0, 0.75, 0))
            end

            myHRP.CFrame = CFrame.new(soccerBall.Position + Vector3.new(0, 1, 0))
        end)

        -- Loop de fling
        flingConnection = RunService.Heartbeat:Connect(function()
            if not running or not selectedPlayer.Character then return end
            local hrp = selectedPlayer.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end

            local dist = (soccerBall.Position - hrp.Position).Magnitude
            if dist < 4 and tick() - lastFlingTime > 0.4 then
                lastFlingTime = tick()

                for _, part in ipairs(selectedPlayer.Character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end

                local fling = Instance.new("BodyVelocity")
                fling.MaxForce = Vector3.new(1e9, 1e9, 1e9)
                fling.Velocity = Vector3.new(math.random(-3, 3), 1, math.random(-3, 3)).Unit * 12000 + Vector3.new(0, 12000, 0)
                fling.Parent = hrp

                task.delay(0.3, function()
                    fling:Destroy()
                    for _, part in ipairs(selectedPlayer.Character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = true
                        end
                    end
                end)
            end
        end)
        print("Fling iniciado com sucesso!")
    end,
})

-- BOTÃO PARAR FLING
Tab1:Button({
    Title = "Parar Fling",
    Desc = "Para o fling no jogador selecionado",
    Callback = function()
        running = false
        if connection then
            connection:Disconnect()
            connection = nil
        end
        if flingConnection then
            flingConnection:Disconnect()
            flingConnection = nil
        end

        -- Restaura as propriedades da bola
        if soccerBall then
            soccerBall.Anchored = originalProperties.Anchored
            soccerBall.CanCollide = originalProperties.CanCollide
            soccerBall.CanTouch = originalProperties.CanTouch
        end

        -- Desativa o NoClip
        local character = LocalPlayer.Character
        if character then
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = true
                    part.Velocity = Vector3.zero
                    part.RotVelocity = Vector3.zero
                end
            end
        end

        -- Restaura a capacidade de sentar
        local myHumanoid = character and character:FindFirstChild("Humanoid")
        if myHumanoid then
            myHumanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        end

        -- Reativa assentos
        for _, seat in ipairs(Workspace:GetDescendants()) do
            if seat:IsA("Seat") or seat:IsA("VehicleSeat") then
                seat.Disabled = false
            end
        end

        -- Restaura o tamanho do personagem
        pcall(function()
            ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Clothe1s"):FireServer("CharacterSizeUp", 1)
        end)

        -- Teleporta com segurança
        if savedPosition then
            local myHRP = character and character:FindFirstChild("HumanoidRootPart")
            if myHRP then
                myHRP.Anchored = true
                myHRP.CFrame = CFrame.new(savedPosition + Vector3.new(0, 5, 0))
                task.wait(0.2)
                myHRP.Velocity = Vector3.zero
                myHRP.RotVelocity = Vector3.zero
                myHRP.Anchored = false
                if myHumanoid then
                    myHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                end
            end
        end
        print("Fling parado. Personagem voltou à posição original.")
    end,
})
