-- lolyta hub version olisinal

-- === Configura√ß√µes Iniciais === --
local AllowedUsers = {
    "rtrt967",
    "kaio_lg1",
    "Higor_hg5",
    "QUEROBOVO",
    "guga_10plays",
    "pzinrlk929",
    "Tataizin_021",
    "Lolytateste666",
    "rafainha4002",
    "Tiago_RJ4",
    "lacradoor123",
    "enzin12346BR",
    "RED_MIGZINN",
    "",
    "",
}

-- Servi√ßos do Roblox
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

-- Verifica√ß√£o de permiss√£o do jogador
local LocalPlayer = Players.LocalPlayer
local PlayerName = LocalPlayer.Name
local isAllowed = false

for _, user in pairs(AllowedUsers) do
    if user == PlayerName then
        isAllowed = true
        break
    end
end

if not isAllowed then
    game.StarterGui:SetCore("SendNotification", {
        Title = "Acesso Negado",
        Text = "Voc√™ n√£o tem permiss√£o para usar o Lolyta Hub 3.1 Contate o criador para ser adicionado √† lista.",
        Duration = 5
    })
    return
end

-- Tela de carregamento com imagem funcional e texto "Carregando..."
local imageId = "rbxassetid://76308195683050" -- ‚úÖ Imagem testada e garantida funcional

-- Remove GUI antiga se j√° existir
local oldGui = game:GetService("CoreGui"):FindFirstChild("LoadingScreen")
if oldGui then oldGui:Destroy() end

-- Cria a nova tela
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "LoadingScreen"
screenGui.IgnoreGuiInset = true
screenGui.ResetOnSpawn = false
screenGui.Parent = game:GetService("CoreGui")

-- Imagem no centro da tela
local imageLabel = Instance.new("ImageLabel")
imageLabel.Size = UDim2.new(0, 300, 0, 300)
imageLabel.Position = UDim2.new(0.5, -150, 0.5, -150)
imageLabel.BackgroundTransparency = 1
imageLabel.Image = imageId
imageLabel.Parent = screenGui

-- Texto "Carregando..."
local textLabel = Instance.new("TextLabel")
textLabel.Size = UDim2.new(0, 300, 0, 50)
textLabel.Position = UDim2.new(0.5, -150, 0.5, 180)
textLabel.BackgroundTransparency = 1
textLabel.Text = "Carregando..."
textLabel.TextColor3 = Color3.new(1, 1, 1)
textLabel.TextStrokeTransparency = 0
textLabel.Font = Enum.Font.FredokaOne
textLabel.TextScaled = true
textLabel.Parent = screenGui

-- Fun√ß√£o que define o RolePlayName e a bio
local function setupRolePlay()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local RE = ReplicatedStorage:WaitForChild("RE", 5) -- Aguarda at√© 5 segundos
    if not RE then
        warn("Erro: ReplicatedStorage.RE n√£o encontrado!")
        return false
    end

    local function fireServer(eventName, args)
        local event = RE:FindFirstChild(eventName)
        if event then
            local success, err = pcall(function()
                event:FireServer(unpack(args))
            end)
            if not success then
                warn("Erro ao disparar evento " .. eventName .. ": " .. tostring(err))
                return false
            else
                print("Evento " .. eventName .. " disparado com sucesso!")
                return true
            end
        else
            warn("Erro: Evento remoto " .. eventName .. " n√£o encontrado!")
            return false
        end
    end

    -- Define o RolePlayName como "Lolyta Hub üíñ"
    local success = fireServer("1RPNam1eTex1t", {
        [1] = "RolePlayName",
        [2] = "Lolyta Hub \240\159\146\150"
    })
    if not success then return false end

    -- Define a cor do RolePlayName como rosa
    success = fireServer("1RPNam1eColo1r", {
        [1] = "PickingRPNameColor",
        [2] = Color3.new(1, 0, 0.9187874794006348)
    })
    if not success then return false end

    -- Define a bio como "scripter"
    success = fireServer("1RPNam1eTex1t", {
        [1] = "RolePlayBio",
        [2] = "scripter "
    })
    if not success then return false end

    -- Define a cor da bio como preta
    success = fireServer("1RPNam1eColo1r", {
        [1] = "PickingRPBioColor",
        [2] = Color3.new(0, 0, 0)
    })
    if not success then return false end

    return true
end

-- Fun√ß√£o para inicializar a interface WindUI
local function initializeUI()
    local success, WindUI = pcall(function()
        return loadstring(game:HttpGet("https://tree-hub.vercel.app/api/UI/WindUI"))()
    end)

    if not success then
        warn("Erro ao carregar WindUI: " .. tostring(WindUI))
        return false
    end

    local Version = "1.4.0"
    local Window = WindUI:CreateWindow({
        Title = "Lolyta Hub 3.1,.__._.__.",
        Icon = "door-open",
        Author = "Lolycon666",
        Folder = "Lolyta hub v.1.666",
        Size = UDim2.fromOffset(580, 460),
        KeySystem = {
            Key = "666",
            Note = "pode nao man",
            URL = "",
            SaveKey = true,
        },
        Transparent = true,
        Theme = "Dark",
        SideBarWidth = 200,
        HasOutline = false,
    })

    Window:EditOpenButton({
        Title = "Lolyta",
        Icon = "align-justify",
        CornerRadius = UDim.new(0, 10),
        StrokeThickness = 3,
        Color = ColorSequence.new(Color3.fromHex("FF0F7B"), Color3.fromHex("F89B29"))
    })

    -- Abas da Interface
    local Tab1 = Window:Tab({ Title = "Main", Icon = "house-plus" })
    local Tab2 = Window:Tab({ Title = "Casa", Icon = "house" })
    local Tab3 = Window:Tab({ Title = "Carro", Icon = "car" })
    local Tab4 = Window:Tab({ Title = "RGB Color", Icon = "palette" })
    local Tab5 = Window:Tab({ Title = "Troll Musica", Icon = "music" })
    local Tab6 = Window:Tab({ Title = "Music All", Icon = "audio-lines" })
    local Tab7 = Window:Tab({ Title = "Scripts", Icon = "layers" })
    local Tab8 = Window:Tab({ Title = "Jogadores", Icon = "users" })
    local Tab9 = Window:Tab({ Title = "Teleportes", Icon = "map-pin" })
    local Tab10 = Window:Tab({ Title = "Troll", Icon = "skull" })

    -- Exemplo de conte√∫do para a aba Main
    Tab1:Button({
        Title = "Teste",
        Description = "Bot√£o de teste",
        Callback = function()
            print("Bot√£o de teste clicado!")
        end
    })

    return true
end


---------------------------------------------------------------------------------------------------------------------------------
                                                   -- === Tab 1: Main === --
---------------------------------------------------------------------------------------------------------------------------------


--------------------------------------------------------------------------------------------------------------------------------------------------


-------------------------------------------------------------------------------------------------------------------------------------------------------

Tab1:Button({
    Title = "Pegar sof√°",
    Desc = "Brookhaven",
    Callback = function()
        invokeServer("1Too1l", {"PickingTools", "Couch"})
    end,
})


--------------------------------------------------------------------------------------------------------------------------------------------------


Tab1:Button({
    Title = "TP ALL",
    Desc = "Teleporte para todos os players",
    Callback = function()
        local startingPosition = LocalPlayer.Character:GetPrimaryPartCFrame()
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                LocalPlayer.Character:SetPrimaryPartCFrame(player.Character:GetPrimaryPartCFrame())
                wait(1)
            end
        end
        LocalPlayer.Character:SetPrimaryPartCFrame(startingPosition)
    end,
})


--------------------------------------------------------------------------------------------------------------------------------------------------


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

Tab1:Toggle({
    Title = "ESP",
    Desc = "Para visualizar jogadores",
    Value = false,
    Callback = function(state)
        local connections = {} -- Tabela para armazenar as conex√µes dos eventos
        local espEnabled = state -- Estado do ESP para controle
        local billboardGuis = {} -- Tabela para rastrear os BillboardGuis de cada jogador

        -- Fun√ß√£o para criar ou atualizar o ESP de um jogador
        local function updateESP(player)
            if player == Players.LocalPlayer then return end -- Ignora o jogador local
            if not espEnabled then return end -- Evita criar ESP se desativado

            local character = player.Character
            if character then
                local head = character:FindFirstChild("Head")
                if head then
                    -- Remove ESP existente, se houver
                    if billboardGuis[player] then
                        billboardGuis[player]:Destroy()
                        billboardGuis[player] = nil
                    end

                    -- Cria um novo BillboardGui
                    local billboard = Instance.new("BillboardGui")
                    billboard.Name = "ESP_Billboard"
                    billboard.Parent = head
                    billboard.Adornee = head
                    billboard.Size = UDim2.new(0, 200, 0, 50)
                    billboard.StudsOffset = Vector3.new(0, 3, 0)
                    billboard.AlwaysOnTop = true

                    -- Cria o TextLabel
                    local textLabel = Instance.new("TextLabel")
                    textLabel.Parent = billboard
                    textLabel.Size = UDim2.new(1, 0, 1, 0)
                    textLabel.BackgroundTransparency = 1
                    textLabel.TextStrokeTransparency = 0.5
                    textLabel.Font = Enum.Font.SourceSansBold
                    textLabel.TextSize = 14

                    -- Define a cor com base na equipe do jogador (se aplic√°vel)
                    if player.Team then
                        textLabel.TextColor3 = player.TeamColor.Color
                    else
                        textLabel.TextColor3 = Color3.new(1, 1, 1) -- Branco padr√£o
                    end

                    -- Atualiza o texto com o nome e a idade da conta
                    textLabel.Text = player.Name .. " | " .. player.AccountAge .. " dias"

                    -- Armazena o BillboardGui na tabela
                    billboardGuis[player] = billboard
                end
            end
        end

        -- Fun√ß√£o para remover o ESP de um jogador
        local function removeESP(player)
            if billboardGuis[player] then
                billboardGuis[player]:Destroy()
                billboardGuis[player] = nil
            end
        end

        if state then
            -- Loop para atualizar o ESP continuamente
            local updateConnection = RunService.Heartbeat:Connect(function()
                if not espEnabled then
                    -- Desconecta o loop se o ESP for desativado
                    updateConnection:Disconnect()
                    return
                end

                -- Atualiza o ESP para todos os jogadores
                for _, player in pairs(Players:GetPlayers()) do
                    updateESP(player)
                end
            end)
            table.insert(connections, updateConnection)

            -- Conecta evento para novos jogadores
            local playerAddedConnection = Players.PlayerAdded:Connect(function(player)
                if not espEnabled then return end
                updateESP(player)

                -- Conecta o evento CharacterAdded para reaplicar o ESP ao respawn
                local charAddedConnection = player.CharacterAdded:Connect(function()
                    if not espEnabled then return end
                    updateESP(player)
                end)
                table.insert(connections, charAddedConnection)

                -- Conecta o evento TeamChanged para atualizar a cor do ESP
                local teamChangedConnection = player:GetPropertyChangedSignal("Team"):Connect(function()
                    if not espEnabled then return end
                    updateESP(player)
                end)
                table.insert(connections, teamChangedConnection)
            end)
            table.insert(connections, playerAddedConnection)

            -- Conecta evento para jogadores que saem
            local playerRemovingConnection = Players.PlayerRemoving:Connect(function(player)
                removeESP(player)
            end)
            table.insert(connections, playerRemovingConnection)

            -- Inicializa o ESP para jogadores existentes
            for _, player in pairs(Players:GetPlayers()) do
                updateESP(player)
            end

            print("ESP ativado!")
        else
            -- Remove o ESP de todos os jogadores
            for player, _ in pairs(billboardGuis) do
                removeESP(player)
            end

            -- Desconecta todos os eventos
            for _, connection in ipairs(connections) do
                connection:Disconnect()
            end
            connections = {}

            -- Limpa a tabela de BillboardGuis
            billboardGuis = {}

            espEnabled = false -- Garante que o estado est√° desativado
            print("ESP desativado!")
        end
    end,
})
--------------------------------------------------------------------------------------------------------------------------------------------------


-----------------------------------------------------------------------------------------------------------------------------------------------
Tab1:Paragraph({ Title = "Jogador", Desc = "fun√ßoes paara o jogador no caso vo√ße" })

-- Vari√°veis para o noclip
local noclipEnabled = false
local noclipConnections = {}
local LocalPlayer = game:GetService("Players").LocalPlayer
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

-- Fun√ß√£o para ativar/desativar o noclip
local function setNoclip(state)
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        print("Personagem ou HumanoidRootPart n√£o encontrado ao tentar ativar/desativar o Noclip!")
        return
    end

    local humanoid = character:FindFirstChild("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")

    if not humanoid or not rootPart then
        print("Humanoid ou RootPart n√£o encontrado ao tentar ativar/desativar o Noclip!")
        return
    end

    noclipEnabled = state -- Define o estado do noclip com base no toggle

    if noclipEnabled then
        -- Desativa as colis√µes do personagem para atravessar objetos
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end

        -- Mant√©m todas as propriedades normais do Humanoid (pulo, movimento, etc.)
        humanoid.PlatformStand = false -- Garante que o personagem pode se mover normalmente
        humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true) -- Mant√©m o estado de queda ativo
        humanoid:ChangeState(Enum.HumanoidStateType.Running) -- Garante que o personagem pode andar normalmente

        -- Loop para manter o noclip ativo e evitar revers√£o pelo servidor
        local connection = RunService.Heartbeat:Connect(function()
            if not noclipEnabled or not character or not character.Parent then
                connection:Disconnect()
                return
            end
            -- Garante que as colis√µes permane√ßam desativadas
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
            -- Verifica se o personagem est√° caindo no void e o reposiciona
            if rootPart.Position.Y < -500 then -- Altura considerada como "void"
                local rayOrigin = rootPart.Position
                local rayDirection = Vector3.new(0, 500, 0) -- Raycast para cima
                local raycastParams = RaycastParams.new()
                raycastParams.FilterDescendantsInstances = {character}
                raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                local raycastResult = Workspace:Raycast(rayOrigin, rayDirection, raycastParams)

                if raycastResult then
                    rootPart.CFrame = CFrame.new(raycastResult.Position + Vector3.new(0, 3, 0)) -- Reposiciona acima do ch√£o
                    print("Personagem estava caindo no void, reposicionado acima do ch√£o!")
                else
                    -- Se n√£o encontrar o ch√£o, reposiciona em uma posi√ß√£o segura
                    rootPart.CFrame = CFrame.new(Vector3.new(0, 50, 0))
                    print("Ch√£o n√£o encontrado, personagem movido para uma posi√ß√£o segura!")
                end
            end
        end)
        table.insert(noclipConnections, connection)

        print("Noclip ativado! Voc√™ pode atravessar objetos e se mover normalmente.")
    else
        -- Desativa o noclip e restaura as propriedades do personagem
        for _, connection in pairs(noclipConnections) do
            connection:Disconnect()
        end
        noclipConnections = {}

        -- Ancorar temporariamente para evitar quedas ou movimento indesejado
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Anchored = true
            end
        end

        -- Restaura as colis√µes e corrige a f√≠sica
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true -- Reativa colis√µes
                part.Velocity = Vector3.new(0, 0, 0) -- Zera a velocidade
                part.RotVelocity = Vector3.new(0, 0, 0) -- Zera a rota√ß√£o
            end
        end

        -- Restaura o estado do Humanoid
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.GettingUp) -- For√ßa o personagem a "se levantar"
            humanoid.PlatformStand = false -- Desativa PlatformStand, se ativo
        end

        -- Corrige a posi√ß√£o para evitar ficar preso
        if rootPart then
            local rayOrigin = rootPart.Position
            local rayDirection = Vector3.new(0, -50, 0) -- Raycast mais longo para baixo
            local raycastParams = RaycastParams.new()
            raycastParams.FilterDescendantsInstances = {character}
            raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
            local raycastResult = Workspace:Raycast(rayOrigin, rayDirection, raycastParams)

            if raycastResult then
                rootPart.CFrame = CFrame.new(raycastResult.Position + Vector3.new(0, 3, 0)) -- Coloca o personagem acima do ch√£o
                print("Personagem reposicionado acima do ch√£o ap√≥s desativar o Noclip!")
            else
                -- Se n√£o encontrar o ch√£o, tenta encontrar uma posi√ß√£o segura acima
                rootPart.CFrame = CFrame.new(rootPart.Position + Vector3.new(0, 10, 0))
                print("Ch√£o n√£o encontrado, personagem movido para uma posi√ß√£o segura!")
            end
        end

        -- Desancora o personagem ap√≥s reposicionar
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Anchored = false
            end
        end

        print("Noclip desativado! Comportamento normal restaurado.")
    end
end

-- Garante que o noclip comece desativado ao carregar o hub
setNoclip(false)

-- Toggle para ativar/desativar o noclip
Tab1:Toggle({
    Title = "Noclip",
    Desc = "Ativa/desativa o noclip para atravessar paredes",
    Default = false,
    Callback = function(value)
        setNoclip(value)
    end,
})

-- Reconecta o noclip ao respawn do personagem
LocalPlayer.CharacterAdded:Connect(function(character)
    if noclipEnabled then
        -- Espera o personagem carregar completamente
        local humanoid = character:WaitForChild("Humanoid", 5)
        local rootPart = character:WaitForChild("HumanoidRootPart", 5)
        if humanoid and rootPart then
            task.wait(0.2) -- Atraso maior para garantir que o personagem esteja pronto
            setNoclip(true) -- Reaplica o noclip se estava ativado
            print("Noclip reaplicado ap√≥s respawn!")
        else
            print("Humanoid ou RootPart n√£o encontrado ao reaplicar Noclip ap√≥s respawn!")
        end
    end
end)
---------------------------------------------------------------------------------------------------------------------------------------------


-- Bot√£o para executar o script de fly
Tab1:Button({
    Title = "Ativar Fly GUI",
    Desc = "Carrega um GUI de fly universal",
    Callback = function()
        local success, errorMessage = pcall(function()
            loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Fly-gui-v3-30439"))()
        end)

        if success then
            game.StarterGui:SetCore("SendNotification", {
                Title = "Sucesso",
                Text = "Fly GUI carregado!",
                Duration = 5
            })
        else
            game.StarterGui:SetCore("SendNotification", {
                Title = "Erro",
                Text = "Falha ao carregar o Fly GUI.",
                Duration = 5
            })
        end
    end,
})

----------------------------------------------------------------------------------------------------------------------------------------------

local SpeedInput = Tab1:Input({
    Title = "Definir a velocidade do jogador",
    Desc = "Insira a velocidade (m√≠nimo 1, sem limite m√°ximo)",
    Value = "70", -- Valor padr√£o como string
    PlaceholderText = "Digite um n√∫mero maior que 1...",
    ClearTextOnFocus = false,
    Callback = function(Text)
        local value = tonumber(Text) -- Converte o texto para n√∫mero
        if value then
            -- Garante que o valor seja pelo menos 1
            value = math.max(value, 1)
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                LocalPlayer.Character.Humanoid.WalkSpeed = value
                print("Velocidade definida para: " .. value)
            else
                warn("Personagem ou Humanoid n√£o encontrado!")
            end
        else
            warn("Por favor, insira um n√∫mero v√°lido!")
        end
    end
})

local ResetSpeedButton = Tab1:Button({
    Title = "Restaurar velocidade padr√£o",
    Desc = "Retorna a velocidade para 16 (padr√£o do Roblox)",
    Callback = function()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
            LocalPlayer.Character.Humanoid.WalkSpeed = 16
            print("Velocidade restaurada para 16!")
        else
            warn("Personagem ou Humanoid n√£o encontrado!")
        end
    end,
})

--------------------------------------------------------------------------------------------------------------------------------------------------

local JumpInput = Tab1:Input({
    Title = "Definir o tamanho do salto do jogador",
    Desc = "Insira o salto (m√≠nimo 1, sem limite m√°ximo)",
    Value = "70", -- Valor padr√£o como string
    PlaceholderText = "Digite um n√∫mero maior que 1...",
    ClearTextOnFocus = false,
    Callback = function(Text)
        local value = tonumber(Text) -- Converte o texto para n√∫mero
        if value then
            -- Garante que o valor seja pelo menos 1
            value = math.max(value, 1)
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                LocalPlayer.Character.Humanoid.JumpPower = value
                print("Tamanho do salto definido para: " .. value)
            else
                warn("Personagem ou Humanoid n√£o encontrado!")
            end
        else
            warn("Por favor, insira um n√∫mero v√°lido!")
        end
    end
})

local ResetJumpButton = Tab1:Button({
    Title = "Restaurar salto padr√£o",
    Desc = "Retorna o salto para 50 (padr√£o do Roblox)",
    Callback = function()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
            LocalPlayer.Character.Humanoid.JumpPower = 50
            print("Tamanho do salto restaurado para 50!")
        else
            warn("Personagem ou Humanoid n√£o encontrado!")
        end
    end,
})

--------------------------------------------------------------------------------------------------------------------------------------------------

-- Vari√°veis para armazenar as conex√µes
local antiSitConnection = nil
local characterAddedConnection = nil
local antiSitEnabled = false

Tab1:Toggle({
    Title = "Anti-Sit",
    Desc = "Impede o jogador de sentar em qualquer assento e evita a anima√ß√£o de sentar",
    Value = false,
    Callback = function(state)
        antiSitEnabled = state
        local LocalPlayer = game:GetService("Players").LocalPlayer

        if state then
            -- Fun√ß√£o para aplicar o Anti-Sit a um personagem
            local function applyAntiSit(character)
                local humanoid = character:FindFirstChild("Humanoid")
                if humanoid then
                    -- For√ßa o jogador a n√£o estar sentado
                    humanoid.Sit = false
                    -- Desativa o estado de sentado e a anima√ß√£o associada
                    humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
                    -- Conecta o evento Seated para impedir tentativas de sentar
                    if antiSitConnection then
                        antiSitConnection:Disconnect()
                    end
                    antiSitConnection = humanoid.Seated:Connect(function(isSeated, seat)
                        if isSeated then
                            humanoid.Sit = false -- Levanta o jogador imediatamente
                            humanoid:ChangeState(Enum.HumanoidStateType.GettingUp) -- For√ßa o estado "em p√©"
                            print("Tentativa de sentar bloqueada!")
                        end
                    end)
                    print("Anti-Sit aplicado ao personagem!")
                else
                    warn("Humanoid n√£o encontrado ao aplicar Anti-Sit!")
                end
            end

            -- Aplica o Anti-Sit ao personagem atual, se existir
            if LocalPlayer.Character then
                applyAntiSit(LocalPlayer.Character)
            end

            -- Conecta o evento CharacterAdded para aplicar o Anti-Sit ao respawn
            if characterAddedConnection then
                characterAddedConnection:Disconnect()
            end
            characterAddedConnection = LocalPlayer.CharacterAdded:Connect(function(character)
                -- Espera o Humanoid carregar
                local humanoid = character:WaitForChild("Humanoid", 5)
                if humanoid and antiSitEnabled then
                    applyAntiSit(character)
                    print("Anti-Sit reaplicado ap√≥s respawn!")
                else
                    warn("Humanoid n√£o encontrado ou Anti-Sit desativado ao respawn!")
                end
            end)

            print("Anti-Sit ativado!")
        else
            -- Desativa o Anti-Sit
            if antiSitConnection then
                antiSitConnection:Disconnect()
                antiSitConnection = nil
            end
            if characterAddedConnection then
                characterAddedConnection:Disconnect()
                characterAddedConnection = nil
            end

            -- Reativa o estado de sentado no Humanoid
            if LocalPlayer.Character then
                local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
                if humanoid then
                    humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
                    print("Estado de sentado reativado!")
                end
            end

            print("Anti-Sit desativado!")
        end
    end,
})

---------------------------------------------------------------------------------------------------------------------------------
                                          -- === Tab 2: casa === --
---------------------------------------------------------------------------------------------------------------------------------

Tab2:Paragraph({ Title = "fun√ßoes para voce usar em voce", Desc = "" })


-- Bot√£o para remover ban de todas as casas (vers√£o ajustada)
Tab2:Button({
    Title = "Remover Ban de Todas as Casas",
    Desc = "Tenta remover o ban de todas as casas (1 a 37)",
    Callback = function()
        local successCount = 0
        local failCount = 0
        -- Verifica se h√° algum BannedBlock no Workspace
        print("Procurando por BannedBlocks no Workspace...")
        for i = 1, 37 do
            local bannedBlockName = "BannedBlock" .. i
            local bannedBlock = Workspace:FindFirstChild(bannedBlockName, true) -- Busca recursiva no Workspace
            if bannedBlock then
                local success, errorMessage = pcall(function()
                    bannedBlock:Destroy()
                end)
                if success then
                    successCount = successCount + 1
                    print("Ban removido da casa " .. i .. " com sucesso!")
                else
                    failCount = failCount + 1
                    warn("Erro ao remover ban da casa " .. i .. ": " .. tostring(errorMessage))
                end
            else
                print("Nenhum ban encontrado para a casa " .. i .. " (BannedBlock" .. i .. " n√£o existe).")
            end
        end
        -- Tenta procurar em outros lugares (por exemplo, dentro das casas)
        print("Procurando por BannedBlocks dentro das casas...")
        for _, house in pairs(Workspace:GetDescendants()) do
            if house.Name:match("BannedBlock") then
                local success, errorMessage = pcall(function()
                    house:Destroy()
                end)
                if success then
                    successCount = successCount + 1
                    print("Ban removido: " .. house.Name .. " em " .. house:GetFullName())
                else
                    failCount = failCount + 1
                    warn("Erro ao remover ban " .. house.Name .. ": " .. tostring(errorMessage))
                end
            end
        end
        -- Resumo do resultado
        print("Resumo: " .. successCount .. " bans removidos com sucesso, " .. failCount .. " falhas.")
        if successCount > 0 then
            game.StarterGui:SetCore("SendNotification", {
                Title = "Sucesso",
                Text = "Bans removidos de " .. successCount .. " casas!",
                Duration = 5
            })
        end
        if failCount > 0 then
            game.StarterGui:SetCore("SendNotification", {
                Title = "Aviso",
                Text = "Falha ao remover bans de " .. failCount .. " casas. Veja o console para detalhes.",
                Duration = 5
            })
        end
        if successCount == 0 and failCount == 0 then
            game.StarterGui:SetCore("SendNotification", {
                Title = "Aviso",
                Text = "Nenhum ban encontrado para remover.",
                Duration = 5
            })
        end
    end,
})



------------------------------------------------------------------------------------------------------------------------------------------------

Tab2:Paragraph({ Title = "pegar permisao de casas!", Desc = "" })

Tab2:Dropdown({
    Title = "pegar permiss√£o das casas",
    Desc = "",
    Value = "Option 1",
    Multi = false,
    AllowNone = true,
    Values = {"Option 1", "Option 2", "Option 3", "Option 4", "Option 5", "Option 6", "Option 7", "Option 8", "Option 9", "Option 10", "Option 11", "Option 12", "Option 13", "Option 14", "Option 15", "Option 16", "Option 17", "Option 18", "Option 19", "Option 20", "Option 21", "Option 22", "Option 23", "Option 24", "Option 25", "Option 26", "Option 27", "Option 28", "Option 29", "Option 30", "Option 31", "Option 32", "Option 33", "Option 34", "Option 35", "Option 36", "Option 37"},
    Callback = function(tab)
        local permission = tonumber(tab:match("%d+")) or 1
        fireServer("1Playe1rTrigge1rEven1t", {"GivePermissionLoopToServer", LocalPlayer, permission})
    end,
})

----------------------------------------------------------------------------------------------------------------------------------------------

Tab2:Paragraph({ Title = "fun√ßoes para outros players", Desc = "" })

Tab2:Paragraph({ Title = "esta fun√ßao e para dar permisao de qualquer casa para qualquer player", Desc = "" })

-- Fun√ß√£o para pegar os nomes dos jogadores
local function getPlayerNames()
    local playerNames = {}
    for _, player in ipairs(Players:GetPlayers()) do
        table.insert(playerNames, player.Name)
    end
    return playerNames
end

-- Dropdown para selecionar o jogador
local selectedPlayerName = ""
local DropdownPlayers = Tab2:Dropdown({
    Title = "Selecionar Jogador",
    Desc = "Escolha um jogador para dar permiss√£o",
    Value = "",
    Multi = false,
    AllowNone = true,
    Values = getPlayerNames(),
    Callback = function(playerName)
        selectedPlayerName = playerName
        print("Jogador selecionado: " .. selectedPlayerName)
    end,
})

-- Atualiza o dropdown quando jogadores entram ou saem
Players.PlayerAdded:Connect(function() DropdownPlayers:Refresh(getPlayerNames()) end)
Players.PlayerRemoving:Connect(function() DropdownPlayers:Refresh(getPlayerNames()) end)

-- Dropdown para selecionar o n√∫mero da casa
local selectedHouseNumber = 1
local houseOptions = {}
for i = 1, 37 do
    table.insert(houseOptions, tostring(i))
end

local DropdownHouses = Tab2:Dropdown({
    Title = "Selecionar Casa",
    Desc = "Escolha o n√∫mero da casa (1 a 37)",
    Value = "1",
    Multi = false,
    AllowNone = false,
    Values = houseOptions,
    Callback = function(houseNumber)
        selectedHouseNumber = tonumber(houseNumber)
        print("Casa selecionada: " .. selectedHouseNumber)
    end,
})

-- Bot√£o para dar permiss√£o
Tab2:Button({
    Title = "Dar Permiss√£o",
    Desc = "D√° permiss√£o ao jogador selecionado para a casa escolhida",
    Callback = function()
        if selectedPlayerName == "" then
            warn("Nenhum jogador selecionado!")
            return
        end
        local targetPlayer = Players:FindFirstChild(selectedPlayerName)
        if not targetPlayer then
            warn("Jogador n√£o encontrado: " .. selectedPlayerName)
            return
        end
        local args = {
            [1] = "GivePermissionLoopToServer",
            [2] = targetPlayer,
            [3] = selectedHouseNumber
        }
        local success, errorMessage = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("RE"):WaitForChild("1Playe1rTrigge1rEven1t"):FireServer(unpack(args))
        end)
        if success then
            print("Permiss√£o dada para " .. selectedPlayerName .. " na casa " .. selectedHouseNumber)
        else
            warn("Erro ao dar permiss√£o: " .. tostring(errorMessage))
        end
    end,
})

----------------------------------------------------------------------------------------------------------------------------------------------

Tab2:Paragraph({ Title = "esta fun√ßao e para remover a permisao de qualquer casa e de qualque player", Desc = "" })

-- Fun√ß√£o para pegar os nomes dos jogadores
local function getPlayerNames()
    local playerNames = {}
    for _, player in ipairs(Players:GetPlayers()) do
        table.insert(playerNames, player.Name)
    end
    return playerNames
end

-- Dropdown para selecionar o jogador
local selectedPlayerNameRemove = ""
local DropdownPlayersRemove = Tab2:Dropdown({
    Title = "Selecionar Jogador (Remover)",
    Desc = "Escolha um jogador para remover permiss√£o",
    Value = "",
    Multi = false,
    AllowNone = true,
    Values = getPlayerNames(),
    Callback = function(playerName)
        selectedPlayerNameRemove = playerName
        print("Jogador selecionado para remover permiss√£o: " .. selectedPlayerNameRemove)
    end,
})

-- Atualiza o dropdown quando jogadores entram ou saem
Players.PlayerAdded:Connect(function() DropdownPlayersRemove:Refresh(getPlayerNames()) end)
Players.PlayerRemoving:Connect(function() DropdownPlayersRemove:Refresh(getPlayerNames()) end)

-- Dropdown para selecionar o n√∫mero da casa
local selectedHouseNumberRemove = 1
local houseOptionsRemove = {}
for i = 1, 37 do
    table.insert(houseOptionsRemove, tostring(i))
end

local DropdownHousesRemove = Tab2:Dropdown({
    Title = "Selecionar Casa (Remover)",
    Desc = "Escolha o n√∫mero da casa (1 a 37)",
    Value = "1",
    Multi = false,
    AllowNone = false,
    Values = houseOptionsRemove,
    Callback = function(houseNumber)
        selectedHouseNumberRemove = tonumber(houseNumber)
        print("Casa selecionada para remover permiss√£o: " .. selectedHouseNumberRemove)
    end,
})

-- Bot√£o para remover permiss√£o
Tab2:Button({
    Title = "Remover Permiss√£o",
    Desc = "Remove a permiss√£o do jogador selecionado para a casa escolhida",
    Callback = function()
        if selectedPlayerNameRemove == "" then
            warn("Nenhum jogador selecionado para remover permiss√£o!")
            return
        end
        local targetPlayer = Players:FindFirstChild(selectedPlayerNameRemove)
        if not targetPlayer then
            warn("Jogador n√£o encontrado: " .. selectedPlayerNameRemove)
            return
        end
        local args = {
            [1] = "RemovePermissionLoopToServer",
            [2] = targetPlayer,
            [3] = selectedHouseNumberRemove
        }
        local success, errorMessage = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("RE"):WaitForChild("1Playe1rTrigge1rEven1t"):FireServer(unpack(args))
        end)
        if success then
            print("Permiss√£o removida de " .. selectedPlayerNameRemove .. " na casa " .. selectedHouseNumberRemove)
        else
            warn("Erro ao remover permiss√£o: " .. tostring(errorMessage))
        end
    end,
})


-- (C√≥digo anterior, como a Tab1 e Tab2)
---------------------------------------------------------------------------------------------------------------------------------
                                          -- === Tab 3: Carro === --
---------------------------------------------------------------------------------------------------------------------------------

Tab3:Paragraph({ 
    Title = "Instru√ß√µes para o teleporta todods os carros do server no void ", 
    Desc = "para que funcione perfeitamente use o void protection do systemBroken na tab sripts la vai tar ele e vai em game e voidprotection"
})

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

Tab3:Toggle({
    Title = "matar todos os carros do server",
    Desc = "teleporta os carrospara o void",
    Value = false,
    Callback = function(state)
        local LocalPlayer = Players.LocalPlayer
        local originalPosition -- Para armazenar a posi√ß√£o original do jogador
        local teleportActive = state -- Estado do toggle
        local fallDamageDisabled = false -- Para controlar se a morte por queda est√° desativada

        -- Fun√ß√£o para desativar/reativar a morte por queda
        local function toggleFallDamage(disable)
            if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("Humanoid") then return end
            local humanoid = LocalPlayer.Character.Humanoid
            if disable then
                -- Desativa a morte por queda
                humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
                humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
                humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp, true)
                humanoid.PlatformStand = false
                fallDamageDisabled = true
                print("Morte por queda desativada!")
            else
                -- Reativa a morte por queda
                humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
                humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, true)
                fallDamageDisabled = false
                print("Morte por queda reativada!")
            end
        end

        -- Fun√ß√£o para teleportar o jogador para um assento
        local function teleportToSeat(seat, car)
            if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("Humanoid") then
                warn("Personagem ou Humanoid n√£o encontrado!")
                return false
            end
            local humanoid = LocalPlayer.Character.Humanoid
            local rootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if not rootPart then
                warn("HumanoidRootPart n√£o encontrado!")
                return false
            end

            -- For√ßa o jogador a n√£o estar sentado antes de tentar
            humanoid.Sit = false
            task.wait(0.1)

            -- Teleporta o jogador para perto do assento antes de sentar
            rootPart.CFrame = seat.CFrame + Vector3.new(0, 5, 0) -- Coloca o jogador acima do assento
            task.wait(0.1)

            -- Tenta sentar no assento
            seat:Sit(humanoid)
            task.wait(0.5) -- Espera para confirmar que sentou
            local success = humanoid.SeatPart == seat
            if success then
                print("Sentou no assento do carro: " .. car.Name)
            else
                warn("Falha ao sentar no assento do carro: " .. car.Name)
            end
            return success
        end

        -- Fun√ß√£o para teleportar o carro e o jogador para o void
        local function teleportToVoid(car)
            if not car then
                warn("Carro n√£o encontrado para teleportar ao void!")
                return
            end
            -- Define o PrimaryPart se n√£o estiver definido
            if not car.PrimaryPart then
                local body = car:FindFirstChild("Body", true) or car:FindFirstChild("Chassis", true)
                if body and body:IsA("BasePart") then
                    car.PrimaryPart = body
                else
                    warn("Carro " .. car.Name .. " n√£o tem PrimaryPart ou Body/Chassis para teleportar!")
                    return
                end
            end
            local voidPosition = Vector3.new(0, -1000, 0) -- Posi√ß√£o no "void"
            car:SetPrimaryPartCFrame(CFrame.new(voidPosition))
            print("Carro " .. car.Name .. " teleportado para o void!")
            task.wait(0.5) -- Espera para garantir que o teleporte ocorreu
        end

        -- Fun√ß√£o para for√ßar o jogador a sair do carro e voltar √† posi√ß√£o original
        local function exitCarAndReturn()
            if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("Humanoid") then
                warn("Personagem ou Humanoid n√£o encontrado para sair do carro!")
                return
            end
            local humanoid = LocalPlayer.Character.Humanoid
            if humanoid.SeatPart then
                humanoid.Sit = false -- For√ßa o jogador a sair do assento
                print("Jogador saiu do assento!")
            end
            task.wait(0.1) -- Pequeno atraso para garantir que saiu
            if originalPosition then
                LocalPlayer.Character:PivotTo(CFrame.new(originalPosition))
                print("Jogador retornou √† posi√ß√£o original: " .. tostring(originalPosition))
            else
                warn("Posi√ß√£o original n√£o definida para retorno!")
            end
        end

        if state then
            -- Salva a posi√ß√£o original do jogador antes de come√ßar
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                originalPosition = LocalPlayer.Character.HumanoidRootPart.Position
                print("Posi√ß√£o original salva: " .. tostring(originalPosition))
            else
                warn("N√£o foi poss√≠vel encontrar o personagem do jogador para salvar a posi√ß√£o!")
                return
            end

            -- Desativa a morte por queda
            toggleFallDamage(true)

            -- Inicia o loop para processar os carros
            spawn(function()
                -- Obt√©m todos os carros em Workspace.Vehicles
                local vehiclesFolder = Workspace:FindFirstChild("Vehicles")
                if not vehiclesFolder then
                    warn("Pasta 'Vehicles' n√£o encontrada no Workspace!")
                    return
                end

                -- Cria uma lista de carros (filtra apenas os que terminam com "Car")
                local cars = {}
                for _, car in ipairs(vehiclesFolder:GetChildren()) do
                    if car.Name:match("Car$") then -- Verifica se o nome termina com "Car"
                        table.insert(cars, car)
                    end
                end
                print("Carros encontrados: " .. #cars)

                -- Processa cada carro
                for _, car in ipairs(cars) do
                    if not teleportActive then
                        print("Toggle desativado, parando o loop!")
                        break
                    end

                    print("Processando carro: " .. car.Name)

                    -- Procura o VehicleSeat recursivamente dentro do carro
                    local vehicleSeat = car:FindFirstChildWhichIsA("VehicleSeat", true)
                    if vehicleSeat then
                        print("VehicleSeat encontrado no carro: " .. car.Name .. " em " .. vehicleSeat:GetFullName())
                        -- Verifica se o assento est√° vazio
                        if vehicleSeat.Occupant == nil then
                            print("Assento est√° vazio, tentando sentar...")
                            -- Tenta teleportar para o assento
                            local success = teleportToSeat(vehicleSeat, car)
                            if success then
                                -- Teleporta o carro e o jogador para o void
                                teleportToVoid(car)
                                -- For√ßa o jogador a sair do carro e voltar √† posi√ß√£o original
                                exitCarAndReturn()
                                task.wait(1) -- Intervalo antes de passar para o pr√≥ximo carro
                            else
                                warn("N√£o conseguiu sentar no assento do carro: " .. car.Name)
                            end
                        else
                            print("Assento ocupado no carro: " .. car.Name .. ", passando para o pr√≥ximo...")
                        end
                    else
                        warn("VehicleSeat n√£o encontrado no carro: " .. car.Name)
                    end
                end

                -- Desativa o toggle automaticamente quando terminar
                if teleportActive then
                    teleportActive = false
                    print("Todos os carros foram processados!")
                    -- Reativa a morte por queda ao terminar
                    toggleFallDamage(false)
                end
            end)
        else
            teleportActive = false -- Para o loop quando o toggle √© desativado
            print("Toggle desativado manualmente!")
            -- Reativa a morte por queda ao desativar o toggle
            toggleFallDamage(false)
        end
    end,
})

-- Garante que a morte por queda seja reativada/desativada ao recarregar o personagem
local fallDamageDisabled = false
Players.LocalPlayer.CharacterAdded:Connect(function(character)
    if fallDamageDisabled then
        local humanoid = character:WaitForChild("Humanoid")
        humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
        humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp, true)
        humanoid.PlatformStand = false
        print("Morte por queda desativada ap√≥s respawn!")
    else
        local humanoid = character:WaitForChild("Humanoid")
        humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, true)
        print("Morte por queda reativada ap√≥s respawn!")
    end
end)
-----------------------------------------------------------------------------------------------------
                                          -- === Tab 4: RGB Color === --
---------------------------------------------------------------------------------------------------------------------------------

-- Lista de cores vibrantes (usada por todos os toggles)
local vibrantColors = {
    Color3.new(1, 0, 0),       -- Vermelho
    Color3.new(0, 1, 0),       -- Verde
    Color3.new(0, 0, 1),       -- Azul
    Color3.new(1, 1, 0),       -- Amarelo
    Color3.new(1, 0, 1),       -- Magenta
    Color3.new(0, 1, 1),       -- Ciano
    Color3.new(1, 0.5, 0),     -- Laranja
    Color3.new(0.5, 0, 1)      -- Roxo
}

-- Fun√ß√£o auxiliar para disparar eventos (reutilizada por todos os toggles)
local function fireServer(eventName, args)
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local event = ReplicatedStorage:FindFirstChild("RE") and ReplicatedStorage.RE:FindFirstChild(eventName)
    if event then
        pcall(function()
            event:FireServer(unpack(args))
        end)
    end
end

-- Novo Toggle: Nome e Bio RGB Sincronizado (em primeiro lugar)
local nameAndBioRGBActive = false
Tab4:Toggle({
    Title = "Nome e Bio RGB Sincronizado",
    Desc = "Ativa cores RGB sincronizadas para Nome e Bio",
    Value = false,
    Callback = function(state)
        nameAndBioRGBActive = state
        if state then
            task.spawn(function()
                while nameAndBioRGBActive and LocalPlayer.Character do
                    local color = vibrantColors[math.random(1, #vibrantColors)]
                    local nameArgs = { [1] = "PickingRPNameColor", [2] = color }
                    local bioArgs = { [1] = "PickingRPBioColor", [2] = color }
                    fireServer("1RPNam1eColo1r", nameArgs)
                    fireServer("1RPNam1eColo1r", bioArgs)
                    wait(1)
                    task.wait() -- Pequena pausa para aliviar a carga
                end
            end)
        end
    end
})

-- Toggle Nome RGB
local nameRGBActive = false
Tab4:Toggle({
    Title = "Nome RGB",
    Desc = "Ativa cores RGB para o Nome",
    Value = false,
    Callback = function(state)
        nameRGBActive = state
        if state then
            task.spawn(function()
                while nameRGBActive and LocalPlayer.Character do
                    local color = vibrantColors[math.random(1, #vibrantColors)]
                    local args = { [1] = "PickingRPNameColor", [2] = color }
                    fireServer("1RPNam1eColo1r", args)
                    wait(1)
                    task.wait() -- Pequena pausa para aliviar a carga
                end
            end)
        end
    end
})

-- Toggle Bio RGB
local bioRGBActive = false
Tab4:Toggle({
    Title = "Bio RGB",
    Desc = "Ativa cores RGB aleat√≥rias na sua bio",
    Value = false,
    Callback = function(state)
        bioRGBActive = state
        if state then
            task.spawn(function()
                while bioRGBActive and LocalPlayer.Character do
                    local color = vibrantColors[math.random(1, #vibrantColors)]
                    local args = { [1] = "PickingRPBioColor", [2] = color }
                    fireServer("1RPNam1eColo1r", args)
                    wait(1)
                    task.wait() -- Pequena pausa para aliviar a carga
                end
            end)
        end
    end
})

-- Toggle RGB Premium (Carro)
local carRGBActive = false
Tab4:Toggle({
    Title = "Car RGB",
    Desc = "Precisa do premium (aten√ß√£o, pode dar kick!!!! N√£o recomendo usar!!!)",
    Value = false,
    Callback = function(state)
        carRGBActive = state
        if state then
            local character = LocalPlayer.Character
            if not character then
                carRGBActive = false
                return
            end
            task.spawn(function()
                while carRGBActive and LocalPlayer.Character do
                    local color = vibrantColors[math.random(1, #vibrantColors)]
                    local args = { [1] = "PickingCarColor", [2] = color }
                    local ReplicatedStorage = game:GetService("ReplicatedStorage")
                    local event = ReplicatedStorage:FindFirstChild("RE") and ReplicatedStorage.RE:FindFirstChild("1Player1sCa1r")
                    if event then
                        pcall(function()
                            event:FireServer(unpack(args))
                        end)
                    end
                    wait(1)
                    task.wait() -- Pequena pausa para aliviar a carga
                end
            end)
        end
    end
})
---------------------------------------------------------------------------------------------------------------------------------
                                          -- === Tab 5: Troll Musica === --
---------------------------------------------------------------------------------------------------------------------------------

local function tocarMusica(id)
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    
    local argsCasa = {
        [1] = "PickHouseMusicText",
        [2] = id
    }
    ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Player1sHous1e"):FireServer(unpack(argsCasa))

    local argsCarro = {
        [1] = "PickingCarMusicText",
        [2] = id
    }
    ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Player1sCa1r"):FireServer(unpack(argsCarro))

    local argsScooter = {
        [1] = "PickingScooterMusicText",
        [2] = id
    }
    ReplicatedStorage:WaitForChild("RE"):WaitForChild("1NoMoto1rVehicle1s"):FireServer(unpack(argsScooter))
end

-- Fun√ß√£o auxiliar para validar valores do Dropdown
local function isValidMusicId(value)
    return value and value ~= "" and value ~= "Option 1" and not value:match("novas musica adds") and not value:match("musica brasil") and not value:match("musica do meu interece") and not value:match("musica dls por elas") and not value:match("meme abaixo") and not value:match("estourada")
end

Tab5:Input({
    Title = "ID da m√∫sica",
    Placeholder = "Digite o ID e pressione Enter",
    Callback = function(value)
        if value and value ~= "" then
            tocarMusica(tostring(value))
        end
    end,
})


-- Tabela de op√ß√µes de m√∫sica para o Dropdown "Funk, Phonk, MTG"
local musicOptions = {
    ["forro"] = {
        {name = "forro", id = "4354908569"}, -- Placeholder ID para t√≠tulo
        {name = "forro ja can√ßou", id = "74812784884330"},
        {name = "lenbro ate hoje", id = "71531533552899"},
        {name = "escolha certa", id = "107088620814881"},
        {name = "nome na ajenda", id = "140095882383991"},
        {name = "forro da rezenha", id = "120973520531216"},
        {name = "forro dudu", id = "74404168179733"},
        {name = "forro sao joao", id = "106364874935196"},
        {name = "forro engra√ßado paia", id = "76524290482399"}
       
        
    }
}

-- Criar listas de nomes e mapeamento de categorias
local musicNames = {}
local categoryMap = {}
for category, sounds in pairs(musicOptions) do
    for _, music in ipairs(sounds) do
        table.insert(musicNames, music.name)
        categoryMap[music.name] = {id = music.id, category = category}
    end
end

-- Fun√ß√£o auxiliar para tocar m√∫sica
local function playMusic(soundId)
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local argsScooter = {
        [1] = "PickingScooterMusicText",
        [2] = tostring(soundId)
    }
    ReplicatedStorage:WaitForChild("RE"):WaitForChild("1NoMoto1rVehicle1s"):FireServer(unpack(argsScooter))
    
    local argsCarro = {
        [1] = "PickingCarMusicText",
        [2] = tostring(soundId)
    }
    ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Player1sCa1r"):FireServer(unpack(argsCarro))
end

-- Dropdown para "Funk, Phonk, MTG"
Tab5:Dropdown({
    Title = "forro",
    Desc = "all",
    Value = "Option 1",
    Multi = false,
    AllowNone = true,
    Values = musicNames,
    Callback = function(selectedSound)
        if selectedSound and categoryMap[selectedSound] then
            local soundId = categoryMap[selectedSound].id
            if soundId and soundId ~= "" and soundId ~= "4354908569" then
                playMusic(soundId)
                print("M√∫sica selecionada: " .. selectedSound .. " (ID: " .. soundId .. ")")
            else
                print("ID inv√°lido ou t√≠tulo selecionado: " .. tostring(selectedSound))
            end
        else
            print("Nenhuma m√∫sica selecionada ou ID n√£o encontrado!")
        end
    end,
})

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------




-- Tabela de op√ß√µes de m√∫sica para o Dropdown "Funk, Phonk, MTG"
local musicOptions = {
    ["forro"] = {
        {name = "musica", id = "4354908569"}, -- Placeholder ID para t√≠tulo
        {name = "ANXIETY (Amapiano Re-fix)", id = "101483901475189"},
        {name = "Meu corpo, minhas regras", id = "127587901595282"},
        {name = "FALAR (YPKE)", id = "81289143488329"},
        {name = "$$$$gg$$$$gg", id = "137471775091253"}
        
       
        
    }
}

-- Criar listas de nomes e mapeamento de categorias
local musicNames = {}
local categoryMap = {}
for category, sounds in pairs(musicOptions) do
    for _, music in ipairs(sounds) do
        table.insert(musicNames, music.name)
        categoryMap[music.name] = {id = music.id, category = category}
    end
end

-- Fun√ß√£o auxiliar para tocar m√∫sica
local function playMusic(soundId)
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local argsScooter = {
        [1] = "PickingScooterMusicText",
        [2] = tostring(soundId)
    }
    ReplicatedStorage:WaitForChild("RE"):WaitForChild("1NoMoto1rVehicle1s"):FireServer(unpack(argsScooter))
    
    local argsCarro = {
        [1] = "PickingCarMusicText",
        [2] = tostring(soundId)
    }
    ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Player1sCa1r"):FireServer(unpack(argsCarro))
end

-- Dropdown para "Funk, Phonk, MTG"
Tab5:Dropdown({
    Title = "musicas internacionais",
    Desc = "all",
    Value = "Option 1",
    Multi = false,
    AllowNone = true,
    Values = musicNames,
    Callback = function(selectedSound)
        if selectedSound and categoryMap[selectedSound] then
            local soundId = categoryMap[selectedSound].id
            if soundId and soundId ~= "" and soundId ~= "4354908569" then
                playMusic(soundId)
                print("M√∫sica selecionada: " .. selectedSound .. " (ID: " .. soundId .. ")")
            else
                print("ID inv√°lido ou t√≠tulo selecionado: " .. tostring(selectedSound))
            end
        else
            print("Nenhuma m√∫sica selecionada ou ID n√£o encontrado!")
        end
    end,
})







-------------------------------------------------------------------------------











-- Tabela de op√ß√µes de m√∫sica para o Dropdown "Funk, Phonk, MTG"
local musicOptions = {
    ["Funk"] = {
        {name = "funks", id = "4354908569"},
        {name = "sua mulher funk", id = "90844637105538"},
        {name = "carro ", id = "100788814736643"},
        {name = "efuga na viatura", id = "131891110268352"},
        {name = "da queles momentos", id = "123134215207264"},
        {name = "ela vem para provacar", id = "79916408808299"},
        {name = "funkphonk fumando verde", id = "112143944982807"},
        {name = "trippi troop funk", id = "73049389767013"},
        {name = "bombini funkphonk", id = "88814770244609"},
        {name = "rachador", id = "109411226739991"},
        {name = "cauma xmara", id = "95664293972405"},
        {name = "tipo tasmania phonkfunk", id = "104300546340195"},
        {name = "que que sharke", id = "129546408528391"},
        {name = "cappuccino assassino funk", id = "122197083209373"},
        {name = "kawai funk", id = "130053797131700"},
        {name = "acordei passando mal", id = "83875675100660"},
        {name = "mechamou de amor", id = "81791559745283"},
        {name = "oeee ja ven sentando", id = "130944058486069"},
        {name = "orror (omega007)", id = "73638649204496"},
        {name = "que pro", id = "97239186078279"},
        {name = "3 em um dot funk", id = "92191873659720"},
        {name = "naved novinha", id = "102930993846348"},
        {name = "preparaaa raaaaa", id = "98063604604756"},
        {name = "vagalumes", id = "72026860897382"},
        {name = "nova gera√ßao", id = "140065053895542"},
        {name = "lovezin", id = "130664328738685"},
        {name = "to voando alto", id = "110475831724424"},
        {name = "CVVV", id = "94245278418076"},
        {name = "MW funk", id = "73473695797214"},
        {name = "menor TV", id = "93993692602344"},
        {name = "de duplinha", id = "80112997683181"},
        {name = "tropa da jamaika", id = "104498738218748"},
        {name = "pre treino", id = "136869502216760"},
        {name = "Of the king (Omega)", id = "75080131478471"},
        {name = "CVRL", id = "124244582950595"},
        {name = "batida Brega Violino (Beat Brega Funk) ", id = "99399643204701"},
        {name = "Espressora Signora FUNK", id = "123394392737234"},
        {name = "Dan√ßa do Canguru (Pke Gaz1nh)", id = "86876136192157"},
        {name = "Il Cacto Hipopotamo FUNK", id = "104491656009142"},
        {name = "Dingo o Bell (Omega)", id = "93847687239132"},
        {name = "espere 30segundos!! Ondas sonoras", id = "127757321382838"},
        {name = "MONTAGEM ARABIANA (Pke Gaz1nh)", id = "78076624091098"},
        {name = "MONTAGEM 15 AN0", id = "82838053504552"},
        {name = "Clube das Winx", id = "101870752447864"},
        {name = "MONTAGEM PALHA√áO DAS TREVAS", id = "98342120038327"},
        {name = "AQUI NO CH.. (GAZ1NH)", id = "132455229546431"},
        {name = "AUTOMOTIVO DUPLA DINAMICA", id = "73361598376791"},
        {name = "SENTA, SENTA, SENTA", id = "140417852590557"},
        {name = "Boladona", id = "96625339070598"},
        {name = "ARROCHA ", id = "103249564479431"},
        {name = "MEGA DOS AUTOMOTIVO", id = "82353927625851"},
        {name = "escravos do po", id = "108995231462803"}
        
        
        
    }
}

-- Criar listas de nomes e mapeamento de categorias
local musicNames = {}
local categoryMap = {}
for category, sounds in pairs(musicOptions) do
    for _, music in ipairs(sounds) do
        table.insert(musicNames, music.name)
        categoryMap[music.name] = {id = music.id, category = category}
    end
end

-- Fun√ß√£o auxiliar para tocar m√∫sica
local function playMusic(soundId)
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local argsScooter = {
        [1] = "PickingScooterMusicText",
        [2] = tostring(soundId)
    }
    ReplicatedStorage:WaitForChild("RE"):WaitForChild("1NoMoto1rVehicle1s"):FireServer(unpack(argsScooter))
    
    local argsCarro = {
        [1] = "PickingCarMusicText",
        [2] = tostring(soundId)
    }
    ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Player1sCa1r"):FireServer(unpack(argsCarro))
end

-- Dropdown para "Funk, Phonk, MTG"
Tab5:Dropdown({
    Title = "Funk",
    Desc = "all",
    Value = "Option 1",
    Multi = false,
    AllowNone = true,
    Values = musicNames,
    Callback = function(selectedSound)
        if selectedSound and categoryMap[selectedSound] then
            local soundId = categoryMap[selectedSound].id
            if soundId and soundId ~= "" and soundId ~= "4354908569" then
                playMusic(soundId)
                print("M√∫sica selecionada: " .. selectedSound .. " (ID: " .. soundId .. ")")
            else
                print("ID inv√°lido ou t√≠tulo selecionado: " .. tostring(selectedSound))
            end
        else
            print("Nenhuma m√∫sica selecionada ou ID n√£o encontrado!")
        end
    end,
})







-------------------------------------------------------------------------------











-- Tabela de op√ß√µes de m√∫sica para o Dropdown "Funk, Phonk, MTG"
local musicOptions = {
    ["phonk"] = {
        {name = "phonk", id = "4354908569"},
        {name = "wyles", id = "85385155970460"},
        {name = "phonk kawai", id = "91502410121438"},
        {name = "querendo da a bucet@", id = "72720721570850"},
        {name = "vem no pocpoc", id = "102333419023382"},
        {name = "tatiu wim", id = "122871512353520"},
        {name = "novinha sapeca", id = "111668097052966"},
        {name = "novinha representa", id = "93786060174790"},
        {name = "phonk1", id = "77501611905348"},
        {name = "phonk2", id = "126887144190812"},
        {name = "phonk osadia", id = "88033569921555"},
        {name = "phonk sarra", id = "132436320685732"},
        {name = "relaionamento sem crush", id = "105832154444494"},
        {name = "phonk3", id = "90323407842935"},
        {name = "novinha dan√ßapanpa", id = "132245626038510"},
        {name = "phonk sexoagre√ßivo", id = "111995323199676"},
        {name = "phonk4", id = "115016589376700"},
        {name = "phonk5", id = "118740708757685"},
        {name = "phonk6", id = "139435437308948"},
        {name = "phonk chapaquente", id = "109189438638906"},
        {name = "phonk rajada", id = "105126065014034"},
        {name = "rede globo", id = "138487820505005"},
        {name = "phonk indiano", id = "87968531262747"},
        {name = "vapo do vapo", id = "106317184644394"},
        {name = "tutatatutata", id = "112068892721408"},
        {name = "phonk slower", id = "122852029094656"},
        {name = "phonk9", id = "91760524161503"},
        {name = "phonk10", id = "73140398421340"},
        {name = "phonk11", id = "137962454483542"},
        {name = "phonk12", id = "84733736048142"},
        {name = "phonk12", id = "106322173003761"},
        {name = "phonk13", id = "94604796823780"},
        {name = "phonk14", id = "118063577904953"},
        {name = "phonk15", id = "115567432786512"},
        {name = "phonk toq", id = "71304501822029"},
        {name = "phonk hey", id = "132218979961283"},
        {name = "phonk16", id = "102708912256857"},
        {name = "phonk17", id = "140642559093189"},
        {name = "phonk neve", id = "13530439660"},
        {name = "phonk18", id = "87863924786534"},
        {name = "phonk19", id = "133135085604736"},
        {name = "phonk lento", id = "97258811783169"},
        {name = "phonk20", id = "92308400487695"},
        {name = "phonk21", id = "104635713368149"},
        {name = "tipo wym", id = "88064647826500"},
        {name = "estouradassa1", id = "92175624643620"},
        {name = "estouradassa2", id = "108099943758978"},
        {name = "Naaaaa", id = "109784877184952"},
        {name = "trem", id = "114608169341947"},
        {name = "eoropa", id = "111346133543699"},
        {name = "atimosphekika", id = "77857496821844"},
        {name = "phonk ALL THE TIME", id = "123809083385992"},
        {name = "Lifelong Memory", id = "81929101024622"},
        {name = "Automotivo Blondie (Pke Gaz1nh)", id = "74564219749776"},
        {name = "‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏Ñ‡∏ô‡πÑ‡∏ó‡∏¢ v2", id = "118225359190317"},
        {name = "MTG TU VAI SENTAR (Pke Gaz1nh)", id = "115317874112657"},
        {name = "TOMADA PHONK", id = "96610114209889"},
        {name = "riightt rs ", id = "98153718682753"},
        {name = "SARRA FUNK", id = "96249826607044"}
       
        
        
    }
}

-- Criar listas de nomes e mapeamento de categorias
local musicNames = {}
local categoryMap = {}
for category, sounds in pairs(musicOptions) do
    for _, music in ipairs(sounds) do
        table.insert(musicNames, music.name)
        categoryMap[music.name] = {id = music.id, category = category}
    end
end

-- Fun√ß√£o auxiliar para tocar m√∫sica
local function playMusic(soundId)
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local argsScooter = {
        [1] = "PickingScooterMusicText",
        [2] = tostring(soundId)
    }
    ReplicatedStorage:WaitForChild("RE"):WaitForChild("1NoMoto1rVehicle1s"):FireServer(unpack(argsScooter))
    
    local argsCarro = {
        [1] = "PickingCarMusicText",
        [2] = tostring(soundId)
    }
    ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Player1sCa1r"):FireServer(unpack(argsCarro))
end

-- Dropdown para "Funk, Phonk, MTG"
Tab5:Dropdown({
    Title = "Phonk",
    Desc = "all",
    Value = "Option 1",
    Multi = false,
    AllowNone = true,
    Values = musicNames,
    Callback = function(selectedSound)
        if selectedSound and categoryMap[selectedSound] then
            local soundId = categoryMap[selectedSound].id
            if soundId and soundId ~= "" and soundId ~= "4354908569" then
                playMusic(soundId)
                print("M√∫sica selecionada: " .. selectedSound .. " (ID: " .. soundId .. ")")
            else
                print("ID inv√°lido ou t√≠tulo selecionado: " .. tostring(selectedSound))
            end
        else
            print("Nenhuma m√∫sica selecionada ou ID n√£o encontrado!")
        end
    end,
})

-- Bot√£o Stop (Carro)
Tab5:Button({
    Title = "Stop",
    Desc = "Car music",
    Callback = function()
        tocarMusica("")
        print("M√∫sica do carro parada")
    end,
})

---------------------------------------------------------------------------------------------------------------------------------
                                                -- === Tab 6: Music All === --
---------------------------------------------------------------------------------------------------------------------------------

local loopAtivo = false
local InputID = ""

Tab6:Input({
    Title = "Insira o ID Audio All",
    Desc = "Digite o ID do som que deseja tocar",
    Value = "",
    PlaceholderText = "Exemplo: 6832470734",
    ClearTextOnFocus = true,
    Callback = function(text)
        InputID = tonumber(text)
        if not InputID then warn("Por favor, insira um ID v√°lido!") end
    end,
})

Tab6:Button({
    Title = "Tocar Som",
    Desc = "Clique para tocar a m√∫sica inserida",
    Callback = function()
        if InputID then
            fireServer("1Gu1nSound1s", {Workspace, InputID, 1})
            local globalSound = Instance.new("Sound", Workspace)
            globalSound.SoundId = "rbxassetid://" .. InputID
            globalSound.Looped = false
            globalSound:Play()
            task.wait(3)
            globalSound:Destroy()
        else
            warn("Nenhum ID v√°lido foi inserido!")
        end
    end,
})

Tab6:Toggle({
    Title = "Loop",
    Desc = "Ative para colocar o som em loop",
    Icon = "check",
    Value = false,
    Callback = function(state)
        loopAtivo = state
        if loopAtivo then
            print("Loop ativado!")
            spawn(function()
                while loopAtivo do
                    if InputID then
                        fireServer("1Gu1nSound1s", {Workspace, InputID, 1})
                        local globalSound = Instance.new("Sound", Workspace)
                        globalSound.SoundId = "rbxassetid://" .. InputID
                        globalSound.Looped = false
                        globalSound:Play()
                        -- N√£o espera o √°udio terminar, apenas cria e toca
                        task.spawn(function() -- Usa task.spawn para destruir ap√≥s 3 segundos sem interferir no loop
                            task.wait(3)
                            globalSound:Destroy()
                        end)
                    else
                        warn("Nenhum ID v√°lido foi inserido!")
                    end
                    task.wait(1) -- Intervalo de 1 segundo entre cada in√≠cio de som
                end
            end)
        else
            print("Loop desativado!")
        end
    end,
})

---------------------------------------------------------------------------------------------------------------------------------------------

local musicOptions = {
    ["Memes"] = {
        {name = "pankapakan", id = 122547522269143},
        {name = "gemido", id = 106835463235574},
        {name = "gemidao v2", id = 112179417472137},
        {name = "Gemido ultra r√°pido", id = 128863565301778},
        {name = "sus sex", id = 128137573022197},
        {name = "gemido estranho", id = 131219411501419},
        {name = "gemido kawai", id = 100409245129170},
        {name = "Hentai gemido", id = 125037339642322},
        {name = "Hentai wiaaaaan", id = 88332347208779},
        {name = "iamete cunasai", id = 108494476595033},
        {name = "___", id = 4354908569},
        {name = "gemidos acima", id = 4354908569},
        {name = "___", id = 4354908569},
        --parte dos gemidos acima 
        --memes abaixo 
        {name = "memes abaixo", id = 4354908569},
        {name = "___", id = 4354908569},
        {name = "kid bengala", id = 4354908569},
        {name = "Toma jack", id = 132603645477541},
        {name = "Toma jackV2", id = 100446887985203},
        {name = "Toma jack no sol quente", id = 97476487963273},
        {name = "ifood", id = 133843750864059},
        {name = "pelo geito ela ta querendo ram", id = 94395705857835},
        {name = "lula vai todo mundo ", id = 136804576009416},
        {name = "coringa", id = 84663543883498},
        {name = "shoope", id = 8747441609},
        {name = "quenojo", id = 103440368630269},
        {name = "sai dai lava prato", id = 101232400175829},
        {name = "se e loko numconpe√ßa", id = 78442476709262},
        {name = "mita sequer que eu too uma", id = 94889439372168},
        {name = "Hoje vou ser tua mulher e tu", id = 90844637105538},
        {name = "Deita aqui eu mandei vc deitar sirens", id = 100291188941582},
        {name = "miau", id = 131804436682424},
        {name = "skibidi", id = 128771670035179},
        
        {name = "cavalo!!", id = 78871573440184},
       

        {name = "deixa os garoto brinca", id = 80291355054807},
        {name = "flamengo", id = 137774355552052},
        {name = "sai do mei satnas", id = 127944706557246},
        {name = "namoral agora e a hora", id = 120677947987369},
        {name = "n pode me chutar pq seu celebro e burro", id = 82284055473737},
        {name = "vc ta fudido vou te pegar", id = 120214772725166},
        {name = "deley", id = 102906880476838},
        {name = "Tu e um beta", id = 130233956349541},
        {name = "Porfavor n tira eu nao", id = 85321374020324},
        {name = "Ol√° beleza vc pode me d√° muitos", id = 74235334504693},
        {name = "Discord sus", id = 122662798976905},
        {name = "rojao apito", id = 6549021381},
        {name = "off", id = 1778829098},
        {name = "Kazuma kazuma", id = 127954653962405},
        {name = "sometourado", id = 123592956882621},
        {name = "Estouradoespad", id = 136179020015211},
        {name = "Alaku bommm", id = 110796593805268},
        {name = "busss", id = 139841197791567},
        {name = "Estourado wItb", id = 137478052262430},
        {name = "sla", id = 116672405522828},

    }
}

local musicNames = {}
local categoryMap = {}
for category, sounds in pairs(musicOptions) do
    for _, music in ipairs(sounds) do
        table.insert(musicNames, music.name)
        categoryMap[music.name] = {id = music.id, category = category}
    end
end

local selectedSoundID = nil
local currentVolume = 1
local currentPitch = 1

local function playSound(soundId, volume, pitch)
    fireServer("1Gu1nSound1s", {Workspace, soundId, volume})
    local globalSound = Instance.new("Sound")
    globalSound.Parent = Workspace
    globalSound.SoundId = "rbxassetid://" .. soundId
    globalSound.Volume = volume
    globalSound.Pitch = pitch
    globalSound.Looped = false
    globalSound:Play()
    -- Usa task.spawn para destruir ap√≥s 3 segundos sem bloquear o loop
    task.spawn(function()
        task.wait(3)
        globalSound:Destroy()
    end)
end

local MusicDropdown = Tab6:Dropdown({
    Title = "Selecione um meme",
    Desc = "Escolha um meme para tocar no servidor",
    Value = "pankapakan",
    Multi = false,
    AllowNone = true,
    Values = musicNames,
    Callback = function(selectedSound)
        if selectedSound and categoryMap[selectedSound] then
            selectedSoundID = categoryMap[selectedSound].id
            print("Som selecionado: " .. selectedSound .. " (ID: " .. selectedSoundID .. ")")
        else
            warn("Nenhum som selecionado ou ID n√£o encontrado!")
            selectedSoundID = nil
        end
    end,
})

Tab6:Button({
    Title = "Tocar Som Selecionado",
    Desc = "Clique para tocar o som do dropdown",
    Callback = function()
        if selectedSoundID then
            playSound(selectedSoundID, currentVolume, currentPitch)
        else
            warn("Nenhum som selecionado no dropdown!")
        end
    end,
})

local dropdownLoopActive = false
Tab6:Toggle({
    Title = "Loop",
    Desc = "Ativa o loop do som selecionado",
    Value = false,
    Callback = function(state)
        dropdownLoopActive = state
        if state then
            print("Loop ativado!")
            task.spawn(function()
                while dropdownLoopActive do
                    if selectedSoundID then
                        playSound(selectedSoundID, currentVolume, currentPitch)
                    else
                        warn("Nenhum som selecionado!")
                    end
                    task.wait(1) -- Intervalo de 1 segundo entre cada in√≠cio de som
                end
            end)
        else
            print("Loop desativado!")
        end
    end,
})

local musicOptions = {
    ["efeito/terror"] = {
        {name = "jumpscar", id = 91784486966761},
        {name = "gritoestourado", id = 7520729342},
        {name = "Woooo", id = 117521059248354},
        {name = "gritodoido", id = 7807987190},
        {name = "gritomedo", id = 113029085566978},
        {name = "___", id = 4354908569},
        {name = "gritos acima", id = 4354908569},
        {name = "___", id = 4354908569}, 
        {name = "sirens abaixo", id = 4354908569},
        {name = "___", id = 4354908569},
        {name = "Nukesiren", id = 9067330158},
        {name = "nuclear sirenv2", id = 675587093},
        {name = "Alertescola", id = 6607047008},
        {name = "Memealertsiren", id = 8379374771},
        {name = "Sirenhead", id = 5681392074},
        {name = "Chernobyl5", id = 101927395686044},
        {name = "Alerta3S", id = 402404861},
        {name = "Radioxiado", id = 8028069841},
        {name = "Error", id = 101446887200514},
        {name = "___", id = 4354908569},
        {name = "sirens acima", id = 4354908569},
        {name = "Risada", id = 79191730206814},
        {name = "Hahahah", id = 90096947219465},
        {name = "___", id = 4354908569},
        {name = "efeitos abaixo", id = 4354908569},
        {name = "___", id = 4354908569},
        {name = "metal", id = 71251935617451},
        {name = "tiro", id = 104223019424522},
        {name = "Golden efect", id = 77773293292155},
        {name = "Haki sound", id = 91390250645812},

    }
}

local musicNames = {}
local categoryMap = {}
for category, sounds in pairs(musicOptions) do
    for _, music in ipairs(sounds) do
        table.insert(musicNames, music.name)
        categoryMap[music.name] = {id = music.id, category = category}
    end
end

local selectedSoundID = nil
local currentVolume = 1
local currentPitch = 1

local function playSound(soundId, volume, pitch)
    fireServer("1Gu1nSound1s", {Workspace, soundId, volume})
    local globalSound = Instance.new("Sound")
    globalSound.Parent = Workspace
    globalSound.SoundId = "rbxassetid://" .. soundId
    globalSound.Volume = volume
    globalSound.Pitch = pitch
    globalSound.Looped = false
    globalSound:Play()
    -- Usa task.spawn para destruir ap√≥s 3 segundos sem bloquear o loop
    task.spawn(function()
        task.wait(3)
        globalSound:Destroy()
    end)
end

local MusicDropdown = Tab6:Dropdown({
    Title = "Selecione um terror ou efeito",
    Desc = "Escolha umterror ou efeito para tocar no servidor",
    Value = "jumpscar",
    Multi = false,
    AllowNone = true,
    Values = musicNames,
    Callback = function(selectedSound)
        if selectedSound and categoryMap[selectedSound] then
            selectedSoundID = categoryMap[selectedSound].id
            print("Som selecionado: " .. selectedSound .. " (ID: " .. selectedSoundID .. ")")
        else
            warn("Nenhum som selecionado ou ID n√£o encontrado!")
            selectedSoundID = nil
        end
    end,
})

Tab6:Button({
    Title = "Tocar Som Selecionado",
    Desc = "Clique para tocar o som do dropdown",
    Callback = function()
        if selectedSoundID then
            playSound(selectedSoundID, currentVolume, currentPitch)
        else
            warn("Nenhum som selecionado no dropdown!")
        end
    end,
})

local dropdownLoopActive = false
Tab6:Toggle({
    Title = "Loop",
    Desc = "Ativa o loop do som selecionado",
    Value = false,
    Callback = function(state)
        dropdownLoopActive = state
        if state then
            print("Loop ativado!")
            task.spawn(function()
                while dropdownLoopActive do
                    if selectedSoundID then
                        playSound(selectedSoundID, currentVolume, currentPitch)
                    else
                        warn("Nenhum som selecionado!")
                    end
                    task.wait(1) -- Intervalo de 1 segundo entre cada in√≠cio de som
                end
            end)
        else
            print("Loop desativado!")
        end
    end,
})

----------------------------------------------------------------------------------------------------------------------------------------------
                                               -- === Tab 7: Scripts === --
----------------------------------------------------------------------------------------------------------------------------------------------

Tab7:Button({
    Title = "Invisible",
    Desc = "universal",
    Callback = function()
        loadstring(game:HttpGet("https://scriptblox.com/raw/Universal-Script-fe-invisible-4366"))()
    end,
})

Tab7:Button({
    Title = "FE Jerk Off Hub Matrix",
    Desc = "Universal",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/ExploitFin/AquaMatrix/refs/heads/AquaMatrix/AquaMatrix"))()
    end,
})

Tab7:Button({
    Title = "FE HUGG",
    Desc = "Universal",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/JSFKGBASDJKHIOAFHDGHIUODSGBJKLFGDKSB/fe/refs/heads/main/FEHUGG"))()
    end,
})

Tab7:Button({
    Title = "Auto Piano Panda Hub",
    Desc = "Universal",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/MADNESSTEST/Pqoeirnfjw/main/AP3-5.lua", true))()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/Sgesa/RandomCatsAutoplay/main/Protected_1274635038188005.lua.txt", true))()
    end,
})

Tab7:Button({
    Title = "Buraco Negro",
    Desc = "Universal",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/Bac0nHck/Scripts/main/BringFlingPlayers"))("More Scripts: t.me/arceusxscripts")
    end,
})

Tab7:Button({
    Title = "System Broochk",
    Desc = "Universal",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/H20CalibreYT/SystemBroken/main/script"))()
    end,
})

Tab7:Button({
    Title = "Roships",
    Desc = "Universal",
    Callback = function()
        loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-rochips-universal-18294"))()
    end,
})

Tab7:Button({
    Title = "Sander X",
    Desc = "Somente para Brookhaven",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/kigredns/SanderXV4.2.2/refs/heads/main/New.lua"))()
    end,
})

Tab7:Button({
    Title = "Reverso",
    Desc = "Universal",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/0Ben1/fe./main/L"))()
    end,
})

Tab7:Button({
    Title = "RD4",
    Desc = "Somente para Brookhaven",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/M1ZZ001/BrookhavenR4D/main/Brookhaven%20R4D%20Script"))()
    end,
})

-----------------------------------------------------------------------------------------------------------------------------------------
                                          -- === Tab 8: Jogadores === --
-----------------------------------------------------------------------------------------------------------------------------------------

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local isSpectating = false
local spectatedPlayer = nil
local characterConnection = nil

-- Fun√ß√£o para obter os nomes dos jogadores, excluindo o jogador local
local function getPlayerNames()
    local playerNames = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playerNames, player.Name)
        end
    end
    return playerNames
end

-- Fun√ß√£o para atualizar o dropdown com os nomes dos jogadores
local function updateDropdown(dropdown)
    local success, errorMessage = pcall(function()
        local currentValue = dropdown.Value
        local playerNames = getPlayerNames()
        dropdown:Refresh(playerNames)
        if currentValue and not table.find(playerNames, currentValue) then
            dropdown:SetValue("")
            print("Jogador anterior saiu do jogo. Sele√ß√£o resetada.")
            if isSpectating then
                stopSpectating()
                SpectateToggle:SetValue(false)
            end
        end
    end)
    if not success then
        warn("Erro ao atualizar dropdown: " .. tostring(errorMessage))
    end
end

-- Fun√ß√£o para teletransportar para o jogador selecionado (com ancoragem segura)
local function teleportToPlayer(playerName)
    local targetPlayer = Players:FindFirstChild(playerName)
    if targetPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local myHRP = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        local myHumanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
        if not myHRP or not myHumanoid then
            print("Seu personagem n√£o est√° totalmente carregado para teletransporte.")
            return
        end

        -- Zerar a f√≠sica do personagem antes do teleporte
        for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Velocity = Vector3.zero
                part.RotVelocity = Vector3.zero
                part.Anchored = true -- Ancorar temporariamente para evitar movimento
            end
        end

        -- Teleportar para a posi√ß√£o do jogador-alvo
        local success, errorMessage = pcall(function()
            myHRP.CFrame = CFrame.new(targetPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, 2, 0)) -- Leve eleva√ß√£o para evitar colis√£o com o ch√£o
        end)
        if not success then
            warn("Erro ao teletransportar: " .. tostring(errorMessage))
            return
        end

        -- Garantir que o Humanoid saia do estado sentado ou voando
        myHumanoid.Sit = false
        myHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp)

        -- Aguardar 0,5 segundos com o personagem ancorado
        task.wait(0.5)

        -- Desancorar todas as partes do personagem e restaurar f√≠sica
        for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Anchored = false
                part.Velocity = Vector3.zero
                part.RotVelocity = Vector3.zero
            end
        end

        print("Teletransportado para o jogador: " .. playerName .. " com ancoragem segura.")
    else
        print("Jogador ou personagem n√£o encontrado para teletransporte.")
    end
end

-- Fun√ß√£o para visualizar um jogador (modo espectador)
local function spectatePlayer(playerName)
    if characterConnection then
        characterConnection:Disconnect()
        characterConnection = nil
    end

    local targetPlayer = Players:FindFirstChild(playerName)
    if targetPlayer and targetPlayer ~= LocalPlayer then
        spectatedPlayer = targetPlayer
        isSpectating = true
        print("Visualizando jogador: " .. targetPlayer.Name)

        local function updateCamera()
            if not isSpectating or not spectatedPlayer then
                return
            end
            if spectatedPlayer.Character and spectatedPlayer.Character:FindFirstChild("Humanoid") then
                Workspace.CurrentCamera.CameraSubject = spectatedPlayer.Character.Humanoid
            else
                Workspace.CurrentCamera.CameraSubject = nil
            end
        end

        updateCamera()

        characterConnection = RunService.Heartbeat:Connect(function()
            if not isSpectating then
                characterConnection:Disconnect()
                characterConnection = nil
                return
            end
            local success, errorMessage = pcall(updateCamera)
            if not success then
                warn("Erro ao atualizar c√¢mera no modo visualiza√ß√£o: " .. tostring(errorMessage))
                stopSpectating()
            end
        end)

        spectatedPlayer.CharacterAdded:Connect(function()
            if isSpectating then
                updateCamera()
            end
        end)
    else
        print("Jogador inv√°lido ou n√£o encontrado para modo visualiza√ß√£o.")
        isSpectating = false
        spectatedPlayer = nil
    end
end

-- Fun√ß√£o para parar de visualizar
local function stopSpectating()
    if characterConnection then
        characterConnection:Disconnect()
        characterConnection = nil
    end

    isSpectating = false
    spectatedPlayer = nil

    -- Garante que a c√¢mera volte para o Humanoid do jogador local
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        Workspace.CurrentCamera.CameraSubject = LocalPlayer.Character.Humanoid
        Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom -- For√ßa o modo de c√¢mera padr√£o
        print("Parando de visualizar. Voltando √† vis√£o do jogador local.")
    else
        Workspace.CurrentCamera.CameraSubject = nil
        Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
        print("Nenhum personagem local encontrado. C√¢mera redefinida.")
    end
end

-- Detecta quando o jogador local morre e reseta a c√¢mera
LocalPlayer.CharacterAdded:Connect(function(character)
    if isSpectating then
        stopSpectating()
        print("Voc√™ morreu. C√¢mera voltou para o seu personagem.")
    end
end)

-- Dropdown para selecionar jogador
local DropdownPlayer = Tab8:Dropdown({
    Title = "Selecionar Jogador",
    Desc = "Selecione o jogador para teletransportar ou visualizar",
    Value = "",
    Multi = false,
    AllowNone = true,
    Values = getPlayerNames(),
    Callback = function(selectedPlayerName)
        if selectedPlayerName == "" or selectedPlayerName == nil then
            print("Nenhum jogador selecionado.")
            if isSpectating then
                stopSpectating()
                SpectateToggle:SetValue(false)
            end
        else
            print("Jogador selecionado: " .. selectedPlayerName)
            if isSpectating then
                stopSpectating()
                spectatePlayer(selectedPlayerName)
            end
        end
    end,
})

-- Bot√£o para atualizar a lista de jogadores (adicionado logo abaixo do dropdown)
Tab8:Button({
    Title = "Atualizar Lista de Jogadores",
    Desc = "Atualiza a lista de jogadores no dropdown",
    Callback = function()
        updateDropdown(DropdownPlayer)
        print("Lista de jogadores atualizada.")
    end,
})

-- Bot√£o de Teleporte
Tab8:Button({
    Title = "Teleportar para Jogador",
    Desc = "Clique para teletransportar para o jogador selecionado",
    Callback = function()
        local selectedPlayerName = DropdownPlayer.Value
        if selectedPlayerName and selectedPlayerName ~= "" then
            local success, errorMessage = pcall(teleportToPlayer, selectedPlayerName)
            if not success then
                warn("Erro ao teletransportar: " .. tostring(errorMessage))
            end
        else
            print("Selecione um jogador antes de teletransportar.")
        end
    end,
})

-- Toggle para visualizar jogador
local SpectateToggle = Tab8:Toggle({
    Title = "Visualizar Jogador",
    Desc = "Ativa ou desativa o modo de visualiza√ß√£o",
    Default = false,
    Callback = function(state)
        if state then
            local selectedPlayerName = DropdownPlayer.Value
            if selectedPlayerName and selectedPlayerName ~= "" then
                local success, errorMessage = pcall(spectatePlayer, selectedPlayerName)
                if not success then
                    warn("Erro ao ativar modo de visualiza√ß√£o: " .. tostring(errorMessage))
                    SpectateToggle:SetValue(false)
                end
            else
                print("Selecione um jogador antes de ativar o modo de visualiza√ß√£o.")
                SpectateToggle:SetValue(false)
            end
        else
            local success, errorMessage = pcall(stopSpectating)
            if not success then
                warn("Erro ao desativar modo de visualiza√ß√£o: " .. tostring(errorMessage))
            end
        end
    end,
})

-- Atualiza o dropdown quando jogadores entram ou saem
updateDropdown(DropdownPlayer)
Players.PlayerAdded:Connect(function()
    updateDropdown(DropdownPlayer)
end)
Players.PlayerRemoving:Connect(function(player)
    updateDropdown(DropdownPlayer)
    if spectatedPlayer and spectatedPlayer == player then
        stopSpectating()
        SpectateToggle:SetValue(false)
        DropdownPlayer:SetValue("")
    end
end)
-----------------------------------------------------------------------------------------------------------------------------------------
                                          -- === Tab 9: Teleportes === --
-----------------------------------------------------------------------------------------------------------------------------------------

local player = game.Players.LocalPlayer
local selectedLocation = "Morro"

-- Dropdown com as localiza√ß√µes de Brookhaven
local Dropdown = Tab9:Dropdown({
    Title = "Locais de Brookhaven",
    Desc = "Selecione um local para teleportar",
    Value = "Morro",
    Multi = false,
    AllowNone = false,
    Values = {
        "Morro",
        "Pra√ßa",
        "Banco",
        "Hospital",
        "Prefeitura",
        "Fazenda",
        "Mercado",
        "Shopping",
        "Aeroporto",
        "Hotel",
        "Beira-mar 1",
        "Beira-mar 2"
    },
    Callback = function(value)
        selectedLocation = value
        print("Local selecionado: " .. selectedLocation)
    end
})

-- Bot√£o para teleportar
local TeleportButton = Tab9:Button({
    Title = "Teleportar",
    Desc = "Teleporta para o local selecionado",
    Callback = function()
        print("Teleportando para: " .. selectedLocation)
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local humanoidRootPart = player.Character.HumanoidRootPart
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            local locations = {
                ["Morro"] = Vector3.new(-348.64, 65.94, -458.08),
                ["Pra√ßa"] = Vector3.new(-26.17, 3.48, -0.93),
                ["Banco"] = Vector3.new(1.99, 3.32, 236.65),
                ["Hospital"] = Vector3.new(-303.2, 3.40, 13.74),
                ["Prefeitura"] = Vector3.new(-354.65, 7.32, -102.16),
                ["Fazenda"] = Vector3.new(-766.41, 2.92, -61.10),
                ["Mercado"] = Vector3.new(16.31, 3.32, -107.07),
                ["Shopping"] = Vector3.new(151.05, 3.52, -190.64),
                ["Aeroporto"] = Vector3.new(290.23, 4.32, 42.57),
                ["Hotel"] = Vector3.new(159.10, 3.32, 164.97),
                ["Beira-mar 1"] = Vector3.new(55.69, 2.94, -1403.60),
                ["Beira-mar 2"] = Vector3.new(42.39, 2.94, 1336.14)
            }

            if locations[selectedLocation] then
                local success, errorMessage = pcall(function()
                    -- Desativar f√≠sica (impedir movimento durante o teleporte)
                    if humanoid then
                        humanoid:ChangeState(Enum.HumanoidStateType.Physics) -- For√ßar estado neutro
                        humanoid.WalkSpeed = 0 -- Impedir movimento
                    end
                    humanoidRootPart.Anchored = true -- Ancorar para evitar f√≠sica externa

                    -- Realizar o teleporte
                    humanoidRootPart.CFrame = CFrame.new(locations[selectedLocation])

                    -- Manter ancorado por 0,4 segundos
                    task.wait(0.4)

                    -- Restaurar estado
                    humanoidRootPart.Anchored = false
                    if humanoid then
                        humanoid.WalkSpeed = 16 -- Restaurar velocidade padr√£o (ajuste conforme necess√°rio)
                        humanoid:ChangeState(Enum.HumanoidStateType.Running) -- Voltar ao estado normal
                    end
                end)

                if not success then
                    warn("Erro ao teleportar: " .. tostring(errorMessage))
                    -- Garantir que o personagem n√£o fique preso
                    humanoidRootPart.Anchored = false
                    if humanoid then
                        humanoid.WalkSpeed = 16
                        humanoid:ChangeState(Enum.HumanoidStateType.Running)
                    end
                end
            else
                print("Local n√£o encontrado!")
            end
        else
            print("Personagem n√£o encontrado!")
        end
    end
})




-----------------------------------------------------------------------------------------------------------------------------------------
                                          -- === Tab 10: Troll === --
-----------------------------------------------------------------------------------------------------------------------------------------

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

-- Vari√°veis compartilhadas
local selectedPlayer = nil
local isFollowingKill = false
local isFollowingPull = false
local running = false
local connection = nil
local flingConnection = nil
local originalPosition = nil
local savedPosition = nil
local originalProperties = {}
local selectedKillPullMethod = nil
local selectedFlingMethod = nil
local soccerBall = nil
local couch = nil
local isSpectating = false
local spectatedPlayer = nil
local characterConnection = nil
local flingToggle = nil -- Para armazenar a refer√™ncia do toggle

-- Cria um RemoteEvent para comunica√ß√£o com o servidor
local SetNetworkOwnerEvent = Instance.new("RemoteEvent")
SetNetworkOwnerEvent.Name = "SetNetworkOwnerEvent_" .. tostring(math.random(1000, 9999))
SetNetworkOwnerEvent.Parent = ReplicatedStorage

-- Cria um script no servidor para lidar com o RemoteEvent
local serverScriptCode = [[
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local event = ReplicatedStorage:WaitForChild("]] .. SetNetworkOwnerEvent.Name .. [[")
    
    event.OnServerEvent:Connect(function(player, part, networkOwner)
        if part and part:IsA("BasePart") then
            pcall(function()
                part:SetNetworkOwner(networkOwner)
                part.Anchored = false
                part.CanCollide = true
                part.CanTouch = true
            end)
        end
    end)
]]

local success, errorMessage = pcall(function()
    loadstring(serverScriptCode)()
end)
if not success then
    warn("Erro ao criar script no servidor: " .. tostring(errorMessage))
end

-- Fun√ß√£o para desativar temporariamente o CarClient
local function disableCarClient()
    local backpack = LocalPlayer:WaitForChild("Backpack")
    local carClient = backpack:FindFirstChild("CarClient")
    if carClient and carClient:IsA("LocalScript") then
        carClient.Disabled = true
        print("CarClient desativado com sucesso!")
    end
end

-- Fun√ß√£o para reativar o CarClient
local function enableCarClient()
    local backpack = LocalPlayer:WaitForChild("Backpack")
    local carClient = backpack:FindFirstChild("CarClient")
    if carClient and carClient:IsA("LocalScript") then
        carClient.Disabled = false
        print("CarClient reativado com sucesso!")
    end
end

-- Fun√ß√£o para obter os nomes dos jogadores, excluindo o jogador local
local function getPlayerNames()
    local playerNames = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playerNames, player.Name)
        end
    end
    return playerNames
end

-- Fun√ß√£o para atualizar o dropdown
local function updateDropdown(dropdown)
    local success, errorMessage = pcall(function()
        local playerNames = getPlayerNames()
        dropdown:Refresh(playerNames)
        if selectedPlayer and not table.find(playerNames, selectedPlayer.Name) then
            dropdown:SetValue("")
            selectedPlayer = nil
            if isSpectating then
                stopSpectating()
            end
        end
    end)
    if not success then
        warn("Erro ao atualizar dropdown: " .. tostring(errorMessage))
    end
end

-- Fun√ß√£o para visualizar um jogador
local function spectatePlayer(playerName)
    if characterConnection then
        characterConnection:Disconnect()
        characterConnection = nil
    end

    local targetPlayer = Players:FindFirstChild(playerName)
    if targetPlayer and targetPlayer ~= LocalPlayer then
        spectatedPlayer = targetPlayer
        isSpectating = true

        local function updateCamera()
            if not isSpectating or not spectatedPlayer then
                return
            end
            if spectatedPlayer.Character and spectatedPlayer.Character:FindFirstChild("Humanoid") then
                Workspace.CurrentCamera.CameraSubject = spectatedPlayer.Character.Humanoid
            else
                Workspace.CurrentCamera.CameraSubject = nil
            end
        end

        updateCamera()

        characterConnection = RunService.Heartbeat:Connect(function()
            if not isSpectating then
                characterConnection:Disconnect()
                characterConnection = nil
                return
            end
            local success, errorMessage = pcall(updateCamera)
            if not success then
                warn("Erro ao atualizar c√¢mera no modo visualiza√ß√£o: " .. tostring(errorMessage))
                stopSpectating()
            end
        end)

        spectatedPlayer.CharacterAdded:Connect(function()
            if isSpectating then
                updateCamera()
            end
        end)
    else
        isSpectating = false
        spectatedPlayer = nil
    end
end

-- Fun√ß√£o para parar de visualizar
local function stopSpectating()
    if characterConnection then
        characterConnection:Disconnect()
        characterConnection = nil
    end

    isSpectating = false
    spectatedPlayer = nil

    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        Workspace.CurrentCamera.CameraSubject = LocalPlayer.Character.Humanoid
        Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
    else
        Workspace.CurrentCamera.CameraSubject = nil
        Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
    end
end

-- Detecta quando o jogador local morre e reseta a c√¢mera
LocalPlayer.CharacterAdded:Connect(function(character)
    if isSpectating then
        stopSpectating()
    end
end)

-- Dropdown para selecionar jogador
print("Criando o dropdown para selecionar jogador...")
local DropdownPlayer = Tab10:Dropdown({
    Title = "Selecionar Jogador",
    Desc = "Escolha um jogador para matar, puxar, visualizar ou aplicar fling",
    Value = "",
    Multi = false,
    AllowNone = true,
    Values = getPlayerNames(),
    Callback = function(selectedPlayerName)
        if selectedPlayerName == "" or selectedPlayerName == nil then
            selectedPlayer = nil
            if running or isFollowingKill or isFollowingPull then
                running = false
                isFollowingKill = false
                isFollowingPull = false
                if connection then connection:Disconnect() end
                if flingConnection then flingConnection:Disconnect() end
                if flingToggle then flingToggle:SetValue(false) end
            end
            if isSpectating then
                stopSpectating()
            end
        else
            selectedPlayer = Players:FindFirstChild(selectedPlayerName)
            if isSpectating then
                stopSpectating()
                spectatePlayer(selectedPlayerName)
            end
        end
    end
})
print("Dropdown para selecionar jogador criado com sucesso!")

-- Bot√£o para atualizar a lista de jogadores
print("Criando o bot√£o para atualizar a lista de jogadores...")
Tab10:Button({
    Title = "Atualizar Lista de Jogadores",
    Desc = "Atualiza a lista de jogadores no dropdown",
    Callback = function()
        updateDropdown(DropdownPlayer)
    end
})
print("Bot√£o para atualizar a lista de jogadores criado com sucesso!")

-- Toggle para visualizar jogador
print("Criando o toggle para visualizar jogador...")
local SpectateToggle = Tab10:Toggle({
    Title = "Visualizar Jogador",
    Desc = "Ativa/desativa a visualiza√ß√£o do jogador selecionado",
    Default = false,
    Callback = function(state)
        if state then
            if selectedPlayer then
                local success, errorMessage = pcall(spectatePlayer, selectedPlayer.Name)
                if not success then
                    warn("Erro ao ativar modo visualiza√ß√£o: " .. tostring(errorMessage))
                    SpectateToggle:SetValue(false)
                end
            else
                warn("Selecione um jogador antes de ativar a visualiza√ß√£o.")
                SpectateToggle:SetValue(false)
            end
        else
            local success, errorMessage = pcall(stopSpectating)
            if not success then
                warn("Erro ao desativar modo visualiza√ß√£o: " .. tostring(errorMessage))
            end
        end
    end
})
print("Toggle para visualizar jogador criado com sucesso!")

-- Remove jogadores que saem do servidor
Players.PlayerRemoving:Connect(function(player)
    if selectedPlayer == player then
        selectedPlayer = nil
        if isSpectating then
            stopSpectating()
        end
        if running then
            running = false
            if connection then connection:Disconnect() connection = nil end
            if flingConnection then flingConnection:Disconnect() flingConnection = nil end
            if flingToggle then flingToggle:SetValue(false) end
        end
    end
    updateDropdown(DropdownPlayer)
end)

-- Inicializa o dropdown
updateDropdown(DropdownPlayer)

-- Dropdown para selecionar m√©todo de matar/puxar
print("Criando o dropdown para selecionar m√©todo de matar/puxar...")
local DropdownKillPullMethod = Tab10:Dropdown({
    Title = "Selecionar M√©todo (Matar/Puxar)",
    Desc = "Escolha o m√©todo para matar ou puxar",
    Values = {"Sof√°", "√înibus"},
    Callback = function(value)
        selectedKillPullMethod = value
    end
})
print("Dropdown para selecionar m√©todo de matar/puxar criado com sucesso!")

-- Fun√ß√£o para equipar o sof√°
local function equipSofa()
    local backpack = LocalPlayer:WaitForChild("Backpack")
    local sofa = backpack:FindFirstChild("Couch") or LocalPlayer.Character:FindFirstChild("Couch")
    if not sofa then
        local args = { [1] = "PickingTools", [2] = "Couch" }
        local success, err = pcall(function()
            ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Too1l"):InvokeServer(unpack(args))
        end)
        if not success then
            warn("Erro ao pegar o sof√°: " .. tostring(err))
            return false
        end
        repeat
            sofa = backpack:FindFirstChild("Couch")
            task.wait()
        until sofa or task.wait(5)
        if not sofa then
            warn("Falha ao pegar o sof√°!")
            return false
        end
    end
    if sofa.Parent ~= LocalPlayer.Character then
        sofa.Parent = LocalPlayer.Character
    end
    return true
end

-- Fun√ß√£o para matar com sof√°
local function killWithSofa(targetPlayer)
    if not targetPlayer or not targetPlayer.Character or not LocalPlayer.Character then
        warn("Selecione um jogador v√°lido antes de iniciar!")
        return
    end
    if not equipSofa() then return end
    isFollowingKill = true
    originalPosition = LocalPlayer.Character:FindFirstChild("HumanoidRootPart").Position
end

-- Fun√ß√£o para puxar com sof√°
local function pullWithSofa(targetPlayer)
    if not targetPlayer or not targetPlayer.Character or not LocalPlayer.Character then
        warn("Selecione um jogador v√°lido antes de iniciar!")
        return
    end
    if not equipSofa() then return end
    isFollowingPull = true
    originalPosition = LocalPlayer.Character:FindFirstChild("HumanoidRootPart").Position
end

-- Fun√ß√£o para matar com √¥nibus
local function killWithBus(targetPlayer)
    if not targetPlayer or not targetPlayer.Character or not LocalPlayer.Character then return end
    local character = LocalPlayer.Character
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local myHRP = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not myHRP then return end
    savedPosition = myHRP.Position
    pcall(function()
        myHRP.Anchored = true
        myHRP.CFrame = CFrame.new(Vector3.new(1181.83, 76.08, -1158.83))
        task.wait(0.2)
        myHRP.Velocity = Vector3.zero
        myHRP.RotVelocity = Vector3.zero
        myHRP.Anchored = false
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
        end
    end)
    task.wait(0.5)
    
    -- Desativar CarClient antes de deletar ve√≠culos
    disableCarClient()
    
    local args = { [1] = "DeleteAllVehicles" }
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
    end)
    args = { [1] = "PickingCar", [2] = "SchoolBus" }
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
    end)
    task.wait(1)
    local vehiclesFolder = Workspace:FindFirstChild("Vehicles")
    if not vehiclesFolder then
        warn("Pasta Vehicles n√£o encontrada no Workspace!")
        return
    end
    local busName = LocalPlayer.Name .. "Car"
    local bus = vehiclesFolder:FindFirstChild(busName)
    if not bus then
        warn("√înibus n√£o encontrado em Workspace.Vehicles com o nome: " .. busName)
        return
    end
    pcall(function()
        myHRP.Anchored = true
        myHRP.CFrame = CFrame.new(Vector3.new(1171.15, 79.45, -1166.2))
        task.wait(0.2)
        myHRP.Velocity = Vector3.zero
        myHRP.RotVelocity = Vector3.zero
        myHRP.Anchored = false
        humanoid:ChangeState(Enum.HumanoidStateType.Seated)
    end)
    local sitStart = tick()
    repeat
        task.wait()
        if tick() - sitStart > 10 then
            warn("Timeout: Jogador local n√£o foi detectado como sentado!")
            return
        end
    until humanoid.Sit
    for _, part in ipairs(bus:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
            pcall(function() part:SetNetworkOwner(nil) end)
        end
    end
    running = true
    connection = RunService.Stepped:Connect(function()
        if not running then return end
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end)
    local lastUpdate = tick()
    local updateInterval = 0.05
    local startTime = tick()
    flingConnection = RunService.Heartbeat:Connect(function()
        if not running then return end
        local targetCharacter = targetPlayer.Character or targetPlayer.CharacterAdded:Wait()
        local newTargetHRP = targetCharacter:FindFirstChild("HumanoidRootPart")
        local newTargetHumanoid = targetCharacter:FindFirstChild("Humanoid")
        if not newTargetHRP or not newTargetHumanoid then return end
        if not myHRP or not humanoid then
            running = false
            return
        end
        if tick() - lastUpdate < updateInterval then return end
        lastUpdate = tick()
        local offset = Vector3.new(math.random(-10, 10), 0, math.random(-10, 10))
        pcall(function()
            local targetPosition = newTargetHRP.Position + offset
            bus:PivotTo(
                CFrame.new(targetPosition) * CFrame.Angles(
                    math.rad(Workspace.DistributedGameTime * 12000),
                    math.rad(Workspace.DistributedGameTime * 15000),
                    math.rad(Workspace.DistributedGameTime * 18000)
                )
            )
        end)
        local playerSeated = false
        for _, seat in ipairs(bus:GetDescendants()) do
            if (seat:IsA("Seat") or seat:IsA("VehicleSeat")) and seat.Name ~= "VehicleSeat" then
                if seat.Occupant == newTargetHumanoid then
                    playerSeated = true
                    break
                end
            end
        end
        if playerSeated or tick() - startTime > 10 then
            running = false
            if connection then connection:Disconnect() connection = nil end
            if flingConnection then flingConnection:Disconnect() flingConnection = nil end
            pcall(function()
                bus:PivotTo(CFrame.new(Vector3.new(-76.6, -401.97, -84.26)))
            end)
            task.wait(0.5)
            
            -- Desativar CarClient antes de deletar ve√≠culos
            disableCarClient()
            
            local args = { [1] = "DeleteAllVehicles" }
            pcall(function()
                ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
            end)
            if character then
                local myHRP = character:FindFirstChild("HumanoidRootPart")
                if myHRP then
                    if savedPosition then
                        pcall(function()
                            myHRP.Anchored = true
                            myHRP.CFrame = CFrame.new(savedPosition + Vector3.new(0, 5, 0))
                            task.wait(0.2)
                            myHRP.Velocity = Vector3.zero
                            myHRP.RotVelocity = Vector3.zero
                            myHRP.Anchored = false
                            if humanoid then
                                humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                            end
                        end)
                    else
                        warn("savedPosition n√£o est√° definida para teleporte de volta!")
                    end
                end
            end
            if character then
                for _, part in ipairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                        part.Velocity = Vector3.zero
                        part.RotVelocity = Vector3.zero
                    end
                end
            end
            local myHumanoid = character and character:FindFirstChild("Humanoid")
            if myHumanoid then
                myHumanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
            end
            for _, seat in ipairs(Workspace:GetDescendants()) do
                if seat:IsA("Seat") or seat:IsA("VehicleSeat") then
                    seat.Disabled = false
                end
            end
            pcall(function()
                ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Clothe1s"):FireServer("CharacterSizeUp", 1)
            end)
        end
    end)
end

-- L√≥gica de matar e puxar
local followConnection
if followConnection then followConnection:Disconnect() end
followConnection = RunService.Heartbeat:Connect(function()
    if (isFollowingKill or isFollowingPull) and selectedPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and selectedPlayer.Character and selectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local success, errorMessage = pcall(function()
            local targetPosition = selectedPlayer.Character.HumanoidRootPart.Position
            LocalPlayer.Character:SetPrimaryPartCFrame(
                CFrame.new(targetPosition) * CFrame.Angles(
                    math.rad(Workspace.DistributedGameTime * 12000),
                    math.rad(Workspace.DistributedGameTime * 15000),
                    math.rad(Workspace.DistributedGameTime * 18000)
                )
            )
        end)
        if not success then
            warn("Erro no loop de matar/puxar: " .. tostring(errorMessage))
            isFollowingKill = false
            isFollowingPull = false
        end
    end
end)

local sitCheckConnection
if sitCheckConnection then sitCheckConnection:Disconnect() end
sitCheckConnection = RunService.Heartbeat:Connect(function()
    if (isFollowingKill or isFollowingPull) and selectedPlayer and selectedPlayer.Character and selectedPlayer.Character:FindFirstChild("Humanoid") then
        local success, errorMessage = pcall(function()
            if selectedPlayer.Character.Humanoid.Sit then
                if isFollowingKill then
                    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        LocalPlayer.Character:SetPrimaryPartCFrame(CFrame.new(0, -500, 0))
                        task.wait(0.5)
                        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Too1l"):InvokeServer("PickingTools", "Couch")
                        task.wait(1)
                    end
                end
                isFollowingKill = false
                isFollowingPull = false
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and originalPosition then
                    local myHRP = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    local myHumanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
                    if myHRP then
                        myHRP.Anchored = true
                        myHRP.CFrame = CFrame.new(originalPosition + Vector3.new(0, 5, 0))
                        task.wait(0.2)
                        myHRP.Velocity = Vector3.zero
                        myHRP.RotVelocity = Vector3.zero
                        myHRP.Anchored = false
                        if myHumanoid then
                            myHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                        end
                    end
                    originalPosition = nil
                end
            end
        end)
        if not success then
            warn("Erro na verifica√ß√£o de assento: " .. tostring(errorMessage))
            isFollowingKill = false
            isFollowingPull = false
        end
    end
end)

-- Bot√£o para iniciar matar
print("Criando o bot√£o para iniciar matar...")
Tab10:Button({
    Title = "Matar",
    Desc = "Inicia o matar com o m√©todo selecionado",
    Callback = function()
        if isFollowingKill or isFollowingPull or running then
            warn("Uma a√ß√£o j√° est√° ativa. Use o bot√£o Parar primeiro.")
            return
        end
        if not selectedPlayer then
            warn("Nenhum jogador selecionado!")
            return
        end
        if not selectedKillPullMethod then
            warn("Nenhum m√©todo de matar/puxar selecionado!")
            return
        end
        if selectedKillPullMethod == "Sof√°" then
            killWithSofa(selectedPlayer)
        elseif selectedKillPullMethod == "√înibus" then
            killWithBus(selectedPlayer)
        end
    end
})
print("Bot√£o para iniciar matar criado com sucesso!")

-- Bot√£o para iniciar puxar
print("Criando o bot√£o para iniciar puxar...")
Tab10:Button({
    Title = "Puxar",
    Desc = "Inicia o puxar com o m√©todo selecionado",
    Callback = function()
        if isFollowingKill or isFollowingPull or running then
            warn("Uma a√ß√£o j√° est√° ativa. Use o bot√£o Parar primeiro.")
            return
        end
        if not selectedPlayer then
            warn("Nenhum jogador selecionado!")
            return
        end
        if not selectedKillPullMethod then
            warn("Nenhum m√©todo de matar/puxar selecionado!")
            return
        end
        if selectedKillPullMethod == "Sof√°" then
            pullWithSofa(selectedPlayer)
        else
            warn("Puxar s√≥ funciona com Sof√°!")
        end
    end
})
print("Bot√£o para iniciar puxar criado com sucesso!")

-- Bot√£o para parar matar ou puxar
print("Criando o bot√£o para parar matar ou puxar...")
Tab10:Button({
    Title = "Parar (Matar ou Puxar)",
    Desc = "Para o movimento de matar ou puxar",
    Callback = function()
        isFollowingKill = false
        isFollowingPull = false
        for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
                part.Velocity = Vector3.zero
                part.RotVelocity = Vector3.zero
            end
        end
        local myHumanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
        if myHumanoid then
            myHumanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        end
        for _, seat in ipairs(Workspace:GetDescendants()) do
            if seat:IsA("Seat") or seat:IsA("VehicleSeat") then
                seat.Disabled = false
            end
        end
        if originalPosition then
            local myHRP = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if myHRP then
                myHRP.Anchored = true
                myHRP.CFrame = CFrame.new(originalPosition + Vector3.new(0, 5, 0))
                task.wait(0.2)
                myHRP.Velocity = Vector3.zero
                myHRP.RotVelocity = Vector3.zero
                myHRP.Anchored = false
                if myHumanoid then
                    myHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                end
            end
            originalPosition = nil
        end
        
        -- Desativar CarClient antes de deletar ve√≠culos
        disableCarClient()
        
        local args = { [1] = "DeleteAllVehicles" }
        pcall(function()
            ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
        end)
    end
})
print("Bot√£o para parar matar ou puxar criado com sucesso!")

-- Dropdown para selecionar m√©todo de fling
print("Criando o dropdown para selecionar m√©todo de fling...")
local DropdownFlingMethod = Tab10:Dropdown({
    Title = "Selecionar M√©todo de Fling",
    Desc = "Escolha o m√©todo para aplicar fling",
    Values = {"Sof√°", "√înibus", "Bola", "Barco"},
    Callback = function(value)
        selectedFlingMethod = value
    end
})
print("Dropdown para selecionar m√©todo de fling criado com sucesso!")

-- Fun√ß√£o para equipar a bola
local function equipBola()
    local backpack = LocalPlayer:WaitForChild("Backpack")
    local bola = backpack:FindFirstChild("SoccerBall") or LocalPlayer.Character:FindFirstChild("SoccerBall")
    if not bola then
        local args = { [1] = "PickingTools", [2] = "SoccerBall" }
        local success, err = pcall(function()
            ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Too1l"):InvokeServer(unpack(args))
        end)
        if not success then
            warn("Erro ao pegar a bola: " .. tostring(err))
            return false
        end
        repeat
            bola = backpack:FindFirstChild("SoccerBall")
            task.wait()
        until bola or task.wait(5)
        if not bola then
            warn("Falha ao pegar a bola!")
            return false
        end
    end
    if bola.Parent ~= LocalPlayer.Character then
        bola.Parent = LocalPlayer.Character
    end
    return true
end

-- Fun√ß√£o para fling com bola (com pot√™ncia aumentada absurdamente)
local function flingWithBall(targetPlayer)
    if not targetPlayer or not targetPlayer.Character then
        warn("Selecione um jogador v√°lido antes de iniciar o fling!")
        return
    end
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local myHRP = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not myHRP then
        warn("Seu personagem ainda n√£o est√° totalmente carregado.")
        return
    end
    if not equipBola() then return end
    task.wait(0.5)
    local args = { [1] = "PlayerWantsToDeleteTool", [2] = "SoccerBall" }
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Clea1rTool1s"):FireServer(unpack(args))
    end)
    local workspaceCom = Workspace:FindFirstChild("WorkspaceCom")
    if not workspaceCom then
        warn("WorkspaceCom n√£o encontrado!")
        return
    end
    local soccerBalls = workspaceCom:FindFirstChild("001_SoccerBalls")
    if not soccerBalls then
        warn("001_SoccerBalls n√£o encontrado!")
        return
    end
    soccerBall = soccerBalls:FindFirstChild("Soccer" .. LocalPlayer.Name)
    if not soccerBall then
        warn("Bola de futebol n√£o encontrada em Workspace.WorkspaceCom.001_SoccerBalls.Soccer" .. LocalPlayer.Name)
        return
    end
    originalProperties = {
        Anchored = soccerBall.Anchored,
        CanCollide = soccerBall.CanCollide,
        CanTouch = soccerBall.CanTouch
    }
    soccerBall.Anchored = false
    soccerBall.CanCollide = true
    soccerBall.CanTouch = true
    pcall(function() soccerBall:SetNetworkOwner(nil) end)
    savedPosition = myHRP.Position
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end
    if humanoid then
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
        humanoid.Sit = false
    end
    for _, seat in ipairs(Workspace:GetDescendants()) do
        if seat:IsA("Seat") or seat:IsA("VehicleSeat") then
            seat.Disabled = true
        end
    end
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Clothe1s"):FireServer("CharacterSizeDown", 4)
    end)
    running = true
    local lastFlingTime = 0
    connection = RunService.Heartbeat:Connect(function()
        if not running or not targetPlayer.Character then return end
        local hrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        local hum = targetPlayer.Character:FindFirstChild("Humanoid")
        local myHRP = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp or not hum or not myHRP then return end
        local moveDir = hum.MoveDirection
        local isStill = moveDir.Magnitude < 0.1
        local isSitting = hum.Sit
        if isSitting then
            local y = math.sin(tick() * 50) * 2
            soccerBall.CFrame = CFrame.new(hrp.Position + Vector3.new(0, 0.75 + y, 0))
        elseif isStill then
            local z = math.sin(tick() * 50) * 3
            soccerBall.CFrame = CFrame.new(hrp.Position + Vector3.new(0, 0.75, z))
        else
            local offset = moveDir.Unit * math.clamp(hrp.Velocity.Magnitude * 0.15, 5, 12)
            soccerBall.CFrame = CFrame.new(hrp.Position + offset + Vector3.new(0, 0.75, 0))
        end
        myHRP.CFrame = CFrame.new(soccerBall.Position + Vector3.new(0, 1, 0))
    end)
    flingConnection = RunService.Heartbeat:Connect(function()
        if not running or not targetPlayer.Character then return end
        local hrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        local dist = (soccerBall.Position - hrp.Position).Magnitude
        if dist < 4 and tick() - lastFlingTime > 0.4 then
            lastFlingTime = tick()
            for _, part in ipairs(targetPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
            local fling = Instance.new("BodyVelocity")
            fling.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            -- Aumentando a pot√™ncia do fling para valores absurdamente altos
            fling.Velocity = Vector3.new(math.random(-5, 5), 5, math.random(-5, 5)).Unit * 500000 + Vector3.new(0, 250000, 0) -- Aumentado de 100000 para 500000 (horizontal) e 50000 para 250000 (vertical)
            fling.Parent = hrp
            task.delay(0.3, function()
                fling:Destroy()
                for _, part in ipairs(targetPlayer.Character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                    end
                end
            end)
        end
    end)
end

-- Fun√ß√£o para fling com sof√°
local function flingWithSofa(targetPlayer)
    if not targetPlayer or not targetPlayer.Character or not LocalPlayer.Character then
        warn("Selecione um jogador v√°lido antes de iniciar!")
        return
    end
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local myHRP = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not myHRP then
        warn("Seu personagem ainda n√£o est√° totalmente carregado.")
        return
    end
    savedPosition = myHRP.Position
    if not equipSofa() then return end
    task.wait(0.5)
    couch = character:FindFirstChild("Couch")
    if not couch then
        for _, obj in ipairs(Workspace:GetDescendants()) do
            if (obj.Name == "Couch" or obj.Name == "Couch" .. LocalPlayer.Name) and (obj:IsA("BasePart") or obj:IsA("Tool")) then
                couch = obj
                break
            end
        end
    end
    if not couch then
        warn("Sof√° n√£o encontrado no personagem ou no Workspace!")
        return
    end
    if couch:IsA("BasePart") then
        originalProperties = {
            Anchored = couch.Anchored,
            CanCollide = couch.CanCollide,
            CanTouch = couch.CanTouch
        }
        couch.Anchored = false
        couch.CanCollide = true
        couch.CanTouch = true
        pcall(function() couch:SetNetworkOwner(nil) end)
    end
    running = true
    connection = RunService.Stepped:Connect(function()
        if not running then return end
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end)
    local startTime = tick()
    local walkFlingInstance = nil
    flingConnection = RunService.Heartbeat:Connect(function()
        if not running then return end
        if not targetPlayer or not targetPlayer.Character then
            running = false
            return
        end
        local newTargetHRP = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        local newTargetHumanoid = targetPlayer.Character:FindFirstChild("Humanoid")
        if not newTargetHRP or not newTargetHumanoid then
            running = false
            return
        end
        if not myHRP or not humanoid then
            running = false
            return
        end
        pcall(function()
            local targetPosition = newTargetHRP.Position
            character:SetPrimaryPartCFrame(
                CFrame.new(targetPosition) * CFrame.Angles(
                    math.rad(Workspace.DistributedGameTime * 12000),
                    math.rad(Workspace.DistributedGameTime * 15000),
                    math.rad(Workspace.DistributedGameTime * 18000)
                )
            )
        end)
        if newTargetHumanoid.Sit or tick() - startTime > 10 then
            running = false
            flingConnection:Disconnect()
            flingConnection = nil
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                    pcall(function() part:SetNetworkOwner(nil) end)
                end
            end
            walkFlingInstance = Instance.new("BodyVelocity")
            walkFlingInstance.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            walkFlingInstance.Velocity = Vector3.new(math.random(-5, 5), 5, math.random(-5, 5)).Unit * 1000000 + Vector3.new(0, 1000000, 0)
            walkFlingInstance.Parent = myHRP
            pcall(function()
                myHRP.Anchored = true
                myHRP.CFrame = CFrame.new(Vector3.new(-59599.73, 2040070.50, -293391.16))
                myHRP.Anchored = false
            end)
            local spinStart = tick()
            local spinConnection
            spinConnection = RunService.Heartbeat:Connect(function()
                if tick() - spinStart >= 0.5 then
                    spinConnection:Disconnect()
                    return
                end
                pcall(function()
                    character:SetPrimaryPartCFrame(
                        myHRP.CFrame * CFrame.Angles(
                            math.rad(Workspace.DistributedGameTime * 12000),
                            math.rad(Workspace.DistributedGameTime * 15000),
                            math.rad(Workspace.DistributedGameTime * 18000)
                        )
                    )
                end)
            end)
            task.wait(0.5)
            local args = { [1] = "PlayerWantsToDeleteTool", [2] = "Couch" }
            pcall(function()
                ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Clea1rTool1s"):FireServer(unpack(args))
            end)
            pcall(function()
                myHRP.Anchored = true
                myHRP.CFrame = CFrame.new(savedPosition + Vector3.new(0, 5, 0))
                task.wait(0.2)
                myHRP.Velocity = Vector3.zero
                myHRP.RotVelocity = Vector3.zero
                myHRP.Anchored = false
                if humanoid then
                    humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                end
            end)
            if walkFlingInstance then
                walkFlingInstance:Destroy()
                for _, part in ipairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                    end
                end
            end
            -- Desativar o toggle automaticamente
            if flingToggle then
                flingToggle:SetValue(false)
            end
        end
    end)
end

-- Fun√ß√£o para fling com √¥nibus (sem busca por chassi)
local function flingWithBus(targetPlayer)
    if not targetPlayer or not targetPlayer.Character or not LocalPlayer.Character then
        warn("Selecione um jogador v√°lido antes de iniciar!")
        return
    end
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local myHRP = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not myHRP then
        warn("Seu personagem ainda n√£o est√° totalmente carregado.")
        return
    end
    savedPosition = myHRP.Position
    pcall(function()
        myHRP.Anchored = true
        myHRP.CFrame = CFrame.new(Vector3.new(1181.83, 76.08, -1158.83))
        task.wait(0.2)
        myHRP.Velocity = Vector3.zero
        myHRP.RotVelocity = Vector3.zero
        myHRP.Anchored = false
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
        end
    end)
    task.wait(0.5)
    
    -- Desativar CarClient antes de deletar ve√≠culos
    disableCarClient()
    
    local args = { [1] = "DeleteAllVehicles" }
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
    end)
    args = { [1] = "PickingCar", [2] = "SchoolBus" }
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
    end)
    task.wait(1)
    local vehiclesFolder = Workspace:FindFirstChild("Vehicles")
    if not vehiclesFolder then
        warn("Pasta Vehicles n√£o encontrada no Workspace!")
        return
    end
    local busName = LocalPlayer.Name .. "Car"
    local bus = vehiclesFolder:FindFirstChild(busName)
    if not bus then
        warn("√înibus n√£o encontrado em Workspace.Vehicles com o nome: " .. busName)
        return
    end
    pcall(function()
        myHRP.Anchored = true
        myHRP.CFrame = CFrame.new(Vector3.new(1171.15, 79.45, -1166.2))
        task.wait(0.2)
        myHRP.Velocity = Vector3.zero
        myHRP.RotVelocity = Vector3.zero
        myHRP.Anchored = false
        humanoid:ChangeState(Enum.HumanoidStateType.Seated)
    end)
    local sitStart = tick()
    repeat
        task.wait()
        if tick() - sitStart > 10 then
            warn("Timeout: Jogador local n√£o foi detectado como sentado!")
            return
        end
    until humanoid.Sit
    for _, part in ipairs(bus:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
            pcall(function() part:SetNetworkOwner(nil) end)
        end
    end
    running = true
    connection = RunService.Stepped:Connect(function()
        if not running then return end
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end)
    local startTime = tick()
    local walkFlingInstancePlayer = nil
    flingConnection = RunService.Heartbeat:Connect(function()
        if not running then return end
        if not targetPlayer or not targetPlayer.Character then
            running = false
            return
        end
        local newTargetHRP = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        local newTargetHumanoid = targetPlayer.Character:FindFirstChild("Humanoid")
        if not newTargetHRP or not newTargetHumanoid then
            running = false
            return
        end
        if not myHRP or not humanoid then
            running = false
            return
        end
        local offset = Vector3.new(math.random(-10, 10), 0, math.random(-10, 10))
        pcall(function()
            local targetPosition = newTargetHRP.Position + offset
            bus:PivotTo(
                CFrame.new(targetPosition) * CFrame.Angles(
                    math.rad(Workspace.DistributedGameTime * 12000),
                    math.rad(Workspace.DistributedGameTime * 15000),
                    math.rad(Workspace.DistributedGameTime * 18000)
                )
            )
        end)
        local playerSeated = false
        for _, seat in ipairs(bus:GetDescendants()) do
            if (seat:IsA("Seat") or seat:IsA("VehicleSeat")) and seat.Name ~= "VehicleSeat" then
                if seat.Occupant == newTargetHumanoid then
                    playerSeated = true
                    break
                end
            end
        end
        if playerSeated or tick() - startTime > 10 then
            running = false
            flingConnection:Disconnect()
            flingConnection = nil
            pcall(function()
                bus:PivotTo(CFrame.new(Vector3.new(-59599.73, 2040070.50, -293391.16)))
            end)
            
            -- Aplicar fling apenas no jogador, sem buscar chassi no √¥nibus
            walkFlingInstancePlayer = Instance.new("BodyVelocity")
            walkFlingInstancePlayer.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            walkFlingInstancePlayer.Velocity = Vector3.new(math.random(-5, 5), 5, math.random(-5, 5)).Unit * 1000000 + Vector3.new(0, 1000000, 0)
            walkFlingInstancePlayer.Parent = myHRP
            task.wait(0.5)
            
            -- Desativar CarClient antes de deletar ve√≠culos
            disableCarClient()
            
            local args = { [1] = "DeleteAllVehicles" }
            pcall(function()
                ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
            end)
            if walkFlingInstancePlayer then
                walkFlingInstancePlayer:Destroy()
                for _, part in ipairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                    end
                end
            end
            pcall(function()
                myHRP.Anchored = true
                myHRP.CFrame = CFrame.new(savedPosition + Vector3.new(0, 5, 0))
                task.wait(0.2)
                myHRP.Velocity = Vector3.zero
                myHRP.RotVelocity = Vector3.zero
                myHRP.Anchored = false
                if humanoid then
                    humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                end
            end)
            -- Desativar o toggle automaticamente
            if flingToggle then
                flingToggle:SetValue(false)
            end
        end
    end)
end

-- Fun√ß√£o para fling com barco
local function flingWithBoat(targetPlayer)
    if not targetPlayer or not targetPlayer.Character or not LocalPlayer.Character then return end
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local myHRP = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not myHRP then return end
    savedPosition = myHRP.Position
    pcall(function()
        myHRP.Anchored = true
        myHRP.CFrame = CFrame.new(Vector3.new(-3359.52, -5.05, -501.94))
        task.wait(0.2)
        myHRP.Velocity = Vector3.zero
        myHRP.RotVelocity = Vector3.zero
        myHRP.Anchored = false
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
        end
    end)
    
    -- Desativar CarClient antes de deletar ve√≠culos
    disableCarClient()
    
    local args = { [1] = "DeleteAllVehicles" }
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
    end)
    task.wait(0.4)
    args = { [1] = "PickingBoat", [2] = "MilitaryBoatFree" }
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
    end)
    task.wait(1.5)
    local vehiclesFolder = Workspace:FindFirstChild("Vehicles")
    if not vehiclesFolder then
        warn("Pasta Vehicles n√£o encontrada no Workspace!")
        return
    end
    local boatName = LocalPlayer.Name .. "Car"
    local boat = vehiclesFolder:FindFirstChild(boatName)
    if not boat then
        warn("Barco n√£o encontrado em Workspace.Vehicles com o nome: " .. boatName)
        return
    end
    pcall(function()
        myHRP.Anchored = true
        myHRP.CFrame = CFrame.new(Vector3.new(-3358.85, 5.25, -521.95))
        task.wait(0.2)
        myHRP.Velocity = Vector3.zero
        myHRP.RotVelocity = Vector3.zero
        myHRP.Anchored = false
        humanoid:ChangeState(Enum.HumanoidStateType.Seated)
    end)
    local sitStart = tick()
    repeat
        task.wait()
        if tick() - sitStart > 10 then break end
    until humanoid.Sit
    for _, part in ipairs(boat:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = true
            pcall(function() part:SetNetworkOwner(nil) end)
        end
    end
    running = true
    connection = RunService.Stepped:Connect(function()
        if not running then return end
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end)
    local touchedConnections = {}
    local mainPart = boat:FindFirstChild("Body")
    if mainPart and mainPart:IsA("BasePart") then
        local conn = mainPart.Touched:Connect(function(hit)
            if not running then return end
            local hitPlayer = Players:GetPlayerFromCharacter(hit.Parent)
            if hitPlayer and hitPlayer == targetPlayer then
                local targetHRP = hit.Parent:FindFirstChild("HumanoidRootPart")
                if targetHRP then
                    local flingForce = Instance.new("BodyVelocity")
                    flingForce.MaxForce = Vector3.new(1e12, 1e12, 1e12)
                    flingForce.Velocity = Vector3.new(math.random(-5, 5), 5, math.random(-5, 5)).Unit * 2000000 + Vector3.new(0, 2000000, 0)
                    flingForce.Parent = targetHRP
                    task.defer(function()
                        task.wait(1)
                        flingForce:Destroy()
                    end)
                end
            end
        end)
        table.insert(touchedConnections, conn)
    else
        warn("Parte 'Body' n√£o encontrada no barco! Usando todas as partes...")
        for _, part in ipairs(boat:GetDescendants()) do
            if part:IsA("BasePart") then
                local conn = part.Touched:Connect(function(hit)
                    if not running then return end
                    local hitPlayer = Players:GetPlayerFromCharacter(hit.Parent)
                    if hitPlayer and hitPlayer == targetPlayer then
                        local targetHRP = hit.Parent:FindFirstChild("HumanoidRootPart")
                        if targetHRP then
                            local flingForce = Instance.new("BodyVelocity")
                            flingForce.MaxForce = Vector3.new(1e12, 1e12, 1e12)
                            flingForce.Velocity = Vector3.new(math.random(-5, 5), 5, math.random(-5, 5)).Unit * 2000000 + Vector3.new(0, 2000000, 0)
                            flingForce.Parent = targetHRP
                            task.defer(function()
                                task.wait(1)
                                flingForce:Destroy()
                            end)
                        end
                    end
                end)
                table.insert(touchedConnections, conn)
            end
        end
    end
    local lastUpdate = tick()
    local updateInterval = 0.05
    flingConnection = RunService.Heartbeat:Connect(function()
        if not running then
            for _, conn in ipairs(touchedConnections) do
                conn:Disconnect()
            end
            touchedConnections = {}
            return
        end
        local targetCharacter = targetPlayer.Character or targetPlayer.CharacterAdded:Wait()
        local newTargetHRP = targetCharacter:FindFirstChild("HumanoidRootPart")
        local newTargetHumanoid = targetCharacter:FindFirstChild("Humanoid")
        if not newTargetHRP or not newTargetHumanoid then return end
        if not myHRP or not humanoid then
            running = false
            for _, conn in ipairs(touchedConnections) do
                conn:Disconnect()
            end
            touchedConnections = {}
            return
        end
        if tick() - lastUpdate < updateInterval then return end
        lastUpdate = tick()
        pcall(function()
            local targetPosition = newTargetHRP.Position
            local time = Workspace.DistributedGameTime
            local rotationX = math.rad(time * 20000)
            local rotationY = math.rad(time * 25000)
            local rotationZ = math.rad(time * 30000)
            boat:PivotTo(
                CFrame.new(targetPosition) * CFrame.Angles(rotationX, rotationY, rotationZ)
            )
        end)
    end)
end

-- Fun√ß√£o para parar o fling (usada pelo toggle)
local function stopFling()
    running = false
    if connection then
        connection:Disconnect()
        connection = nil
    end
    if flingConnection then
        flingConnection:Disconnect()
        flingConnection = nil
    end
    if soccerBall then
        soccerBall.Anchored = originalProperties.Anchored
        soccerBall.CanCollide = originalProperties.CanCollide
        soccerBall.CanTouch = originalProperties.CanTouch
    end
    if couch and couch:IsA("BasePart") then
        couch.Anchored = originalProperties.Anchored
        couch.CanCollide = originalProperties.CanCollide
        couch.CanTouch = originalProperties.CanTouch
    end
    
    -- Desativar CarClient antes de deletar ve√≠culos
    disableCarClient()
    
    local args = { [1] = "DeleteAllVehicles" }
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
    end)
    task.wait(0.2)
    local character = LocalPlayer.Character
    if character then
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
                part.Velocity = Vector3.zero
                part.RotVelocity = Vector3.zero
            end
        end
    end
    local myHumanoid = character and character:FindFirstChild("Humanoid")
    if myHumanoid then
        myHumanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
    end
    for _, seat in ipairs(Workspace:GetDescendants()) do
        if seat:IsA("Seat") or seat:IsA("VehicleSeat") then
            seat.Disabled = false
        end
    end
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Clothe1s"):FireServer("CharacterSizeUp", 1)
    end)
    if savedPosition then
        local myHRP = character and character:FindFirstChild("HumanoidRootPart")
        if myHRP then
            pcall(function()
                myHRP.Anchored = true
                myHRP.CFrame = CFrame.new(savedPosition + Vector3.new(0, 5, 0))
                task.wait(0.2)
                myHRP.Velocity = Vector3.zero
                myHRP.RotVelocity = Vector3.zero
                myHRP.Anchored = false
                if myHumanoid then
                    myHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                end
            end)
        end
    end
end

-- Toggle para ativar/desativar o fling
print("Criando o toggle para ativar/desativar o fling...")
flingToggle = Tab10:Toggle({
    Title = "Ativar Fling",
    Desc = "Ativa ou desativa o fling com o m√©todo selecionado",
    Default = false,
    Callback = function(state)
        if state then
            if isFollowingKill or isFollowingPull or running then
                warn("Uma a√ß√£o j√° est√° ativa. Use o bot√£o Parar (Matar ou Puxar) primeiro.")
                flingToggle:SetValue(false)
                return
            end
            if not selectedPlayer then
                warn("Nenhum jogador selecionado!")
                flingToggle:SetValue(false)
                return
            end
            if not selectedFlingMethod then
                warn("Nenhum m√©todo de fling selecionado!")
                flingToggle:SetValue(false)
                return
            end
            if selectedFlingMethod == "Bola" then
                flingWithBall(selectedPlayer)
            elseif selectedFlingMethod == "Sof√°" then
                flingWithSofa(selectedPlayer)
            elseif selectedFlingMethod == "√înibus" then
                flingWithBus(selectedPlayer)
            elseif selectedFlingMethod == "Barco" then
                flingWithBoat(selectedPlayer)
            end
        else
            stopFling()
        end
    end
})
print("Toggle para ativar/desativar o fling criado com sucesso!")

print("Script inicializado com sucesso! A UI deve estar vis√≠vel agora.")

Tab10:Paragraph({ 
    Title = "fling barco op mais n recomendo ele pod causar travamento!!! e use o noclip ", 
    Desc = ""
})


