local WindUI = loadstring(game:HttpGet("https://tree-hub.vercel.app/api/UI/WindUI"))()
local Version = "1.4.0"

local Window = WindUI:CreateWindow({
    Title = "Lolyta troll 6667575",
    Icon = "door-open",
    Author = "Lolycon666",
    Folder = "Lolyta 666",
    Size = UDim2.fromOffset(580, 460),
    KeySystem = {
        Key = "666",
        Note = "pode nao man",
        URL = "",
        SaveKey = true,
    },
    Transparent = true,
    Theme = "Dark",
    SideBarWidth = 200,
    HasOutline = false,
})

Window:EditOpenButton({
    Title = "Lolyta troll",
    Icon = "align-justify",
    CornerRadius = UDim.new(0, 10),
    StrokeThickness = 3,
    Color = ColorSequence.new(Color3.fromHex("FF0F7B"), Color3.fromHex("F89B29"))
})

-- === Abas da Interface === --
local Tab1 = Window:Tab({ Title = "troll", Icon = "Ball" })

-----------------------------------------------------------------------------------------------------------------------------------------
                                          -- === Tab 1: Troll === --
-----------------------------------------------------------------------------------------------------------------------------------------

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

-- Variáveis compartilhadas
local selectedPlayer = nil
local isFollowingKill = false
local isFollowingPull = false
local originalPosition = nil
local isSpectating = false
local spectatedPlayer = nil
local characterConnection = nil
local soccerBall = nil
local running = false
local connection, flingConnection
local originalProperties = {}
local savedPosition = nil

-- Cria um RemoteEvent para comunicação com o servidor
local SetNetworkOwnerEvent = Instance.new("RemoteEvent")
SetNetworkOwnerEvent.Name = "SetNetworkOwnerEvent_" .. tostring(math.random(1000, 9999))
SetNetworkOwnerEvent.Parent = ReplicatedStorage

-- Cria um script no servidor para lidar com o RemoteEvent
local serverScriptCode = [[
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local event = ReplicatedStorage:WaitForChild("]] .. SetNetworkOwnerEvent.Name .. [[")
    
    event.OnServerEvent:Connect(function(player, part, networkOwner)
        if part and part:IsA("BasePart") then
            pcall(function()
                part:SetNetworkOwner(networkOwner)
                part.Anchored = false
                part.CanCollide = true
                part.CanTouch = true
            end)
        end
    end)
]]

local success, errorMessage = pcall(function()
    loadstring(serverScriptCode)()
end)
if not success then
    warn("Erro ao criar script no servidor: " .. tostring(errorMessage))
end

-- Função para obter os nomes dos jogadores, excluindo o jogador local
local function getPlayerNames()
    local playerNames = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playerNames, player.Name)
        end
    end
    return playerNames
end

-- Função para atualizar o dropdown
local function updateDropdown(dropdown)
    local success, errorMessage = pcall(function()
        local playerNames = getPlayerNames()
        dropdown:Refresh(playerNames)
        if selectedPlayer and not table.find(playerNames, selectedPlayer.Name) then
            dropdown:SetValue("")
            selectedPlayer = nil
            print("Jogador anterior saiu do jogo. Seleção resetada.")
        end
    end)
    if not success then
        warn("Erro ao atualizar dropdown: " .. tostring(errorMessage))
    end
end

-- Função para visualizar um jogador
local function spectatePlayer(playerName)
    if characterConnection then
        characterConnection:Disconnect()
        characterConnection = nil
    end

    local targetPlayer = Players:FindFirstChild(playerName)
    if targetPlayer and targetPlayer ~= LocalPlayer then
        spectatedPlayer = targetPlayer
        isSpectating = true
        print("Visualizando jogador: " .. targetPlayer.Name)

        local function updateCamera()
            if not isSpectating or not spectatedPlayer then
                return
            end
            if spectatedPlayer.Character and spectatedPlayer.Character:FindFirstChild("Humanoid") then
                Workspace.CurrentCamera.CameraSubject = spectatedPlayer.Character.Humanoid
            else
                Workspace.CurrentCamera.CameraSubject = nil
            end
        end

        updateCamera()

        characterConnection = RunService.Heartbeat:Connect(function()
            if not isSpectating then
                characterConnection:Disconnect()
                characterConnection = nil
                return
            end
            local success, errorMessage = pcall(updateCamera)
            if not success then
                warn("Erro ao atualizar câmera no modo visualização: " .. tostring(errorMessage))
                stopSpectating()
            end
        end)

        spectatedPlayer.CharacterAdded:Connect(function()
            if isSpectating then
                updateCamera()
            end
        end)
    else
        print("Jogador inválido ou não encontrado para modo visualização.")
        isSpectating = false
        spectatedPlayer = nil
    end
end

-- Função para parar de visualizar
local function stopSpectating()
    if characterConnection then
        characterConnection:Disconnect()
        characterConnection = nil
    end

    isSpectating = false
    spectatedPlayer = nil

    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        Workspace.CurrentCamera.CameraSubject = LocalPlayer.Character.Humanoid
        Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
        print("Parando de visualizar. Voltando à visão do jogador local.")
    else
        Workspace.CurrentCamera.CameraSubject = nil
        Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
        print("Nenhum personagem local encontrado. Câmera redefinida.")
    end
end

-- Detecta quando o jogador local morre e reseta a câmera
LocalPlayer.CharacterAdded:Connect(function(character)
    if isSpectating then
        stopSpectating()
        print("Você morreu. Câmera voltou para o seu personagem.")
    end
end)

-- Botão System Broken
Tab1:Button({
    Title = "System Broken",
    Desc = "Universal",
    Callback = function()
        local success, errorMessage = pcall(function()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/H20CalibreYT/SystemBroken/main/script"))()
        end)
        if not success then
            warn("Erro ao carregar System Broken: " .. tostring(errorMessage))
        end
    end,
})

Tab1:Paragraph({ 
    Title = "Execute o System Broken e ative o VoidProtection", 
    Desc = "Faça isso antes de usar as funções abaixo!!!"
})

-- Dropdown para selecionar jogador
local DropdownPlayer = Tab1:Dropdown({
    Title = "Selecionar Jogador",
    Desc = "Escolha um jogador para matar, puxar ou aplicar fling",
    Value = "",
    Multi = false,
    AllowNone = true,
    Values = getPlayerNames(),
    Callback = function(selectedPlayerName)
        if selectedPlayerName == "" or selectedPlayerName == nil then
            selectedPlayer = nil
            print("Nenhum jogador selecionado.")
            if running then
                running = false
                if connection then connection:Disconnect() end
                if flingConnection then flingConnection:Disconnect() end
                stopSpectating()
            end
            isFollowingKill = false
            isFollowingPull = false
        else
            selectedPlayer = Players:FindFirstChild(selectedPlayerName)
            print("Jogador selecionado: " .. selectedPlayerName)
            if isSpectating then
                stopSpectating()
                spectatePlayer(selectedPlayerName)
            end
            if running then
                print("Jogador do fling atualizado para: " .. selectedPlayerName)
            end
        end
    end,
})

-- Botão para atualizar a lista de jogadores
Tab1:Button({
    Title = "Atualizar Lista de Jogadores",
    Desc = "Atualiza a lista de jogadores no dropdown",
    Callback = function()
        updateDropdown(DropdownPlayer)
        print("Lista de jogadores atualizada!")
    end,
})

-- Toggle para visualizar jogador
local SpectateToggle = Tab1:Toggle({
    Title = "Visualizar Jogador",
    Desc = "Ativa/desativa a visualização do jogador selecionado",
    Default = false,
    Callback = function(state)
        if state then
            if selectedPlayer then
                local success, errorMessage = pcall(spectatePlayer, selectedPlayer.Name)
                if not success then
                    warn("Erro ao ativar modo visualização: " .. tostring(errorMessage))
                    SpectateToggle:SetValue(false)
                end
            else
                print("Selecione um jogador antes de ativar a visualização.")
                SpectateToggle:SetValue(false)
            end
        else
            local success, errorMessage = pcall(stopSpectating)
            if not success then
                warn("Erro ao desativar modo visualização: " .. tostring(errorMessage))
            end
        end
    end,
})

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-- BOTÃO INICIAR FLING COM SOFÁ
Tab1:Button({
    Title = "Iniciar Fling com Sofá",
    Desc = "Inicia o fling no jogador selecionado usando o sofá",
    Callback = function()
        if running then
            print("O fling já está ativo. Use o botão 'Parar Fling' primeiro.")
            return
        end
        if not selectedPlayer or not selectedPlayer.Character or not LocalPlayer.Character then
            warn("Selecione um jogador válido antes de iniciar!")
            return
        end

        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local myHRP = character:FindFirstChild("HumanoidRootPart")
        if not humanoid or not myHRP then
            warn("Seu personagem ainda não está totalmente carregado.")
            return
        end

        -- Salva a posição inicial
        savedPosition = myHRP.Position

        -- Função para equipar o sofá
        local function equipSofa()
            local backpack = LocalPlayer:WaitForChild("Backpack")
            local sofa = backpack:FindFirstChild("Couch") or character:FindFirstChild("Couch")

            if not sofa then
                -- Pega o sofá se não estiver no inventário ou equipado
                local args = {
                    [1] = "PickingTools",
                    [2] = "Couch"
                }
                local success, err = pcall(function()
                    ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Too1l"):InvokeServer(unpack(args))
                end)
                if not success then
                    warn("Erro ao pegar o sofá: " .. tostring(err))
                    return false
                end

                -- Espera o sofá aparecer na mochila
                repeat
                    sofa = backpack:FindFirstChild("Couch")
                    task.wait()
                until sofa or task.wait(5) -- Timeout de 5 segundos
                if not sofa then
                    warn("Falha ao pegar o sofá!")
                    return false
                end
            end

            -- Se o sofá não estiver equipado, equipa
            if sofa.Parent ~= character then
                sofa.Parent = character
                print("Sofá equipado!")
            else
                print("Sofá já está equipado!")
            end
            return true
        end

        -- Equipa o sofá
        if not equipSofa() then
            return
        end

        -- Espera 0.5 segundos
        task.wait(0.5)

        -- Procura o sofá no personagem (Tool) ou no Workspace (BasePart)
        local couch
        couch = character:FindFirstChild("Couch") -- Prioriza o sofá equipado (Tool)
        if not couch then
            for _, obj in ipairs(Workspace:GetDescendants()) do
                if (obj.Name == "Couch" or obj.Name == "Couch" .. LocalPlayer.Name) and (obj:IsA("BasePart") or obj:IsA("Tool")) then
                    couch = obj
                    break
                end
            end
        end
        if not couch then
            warn("Sofá não encontrado no personagem ou como BasePart/Tool no Workspace!")
            print("Procurando sofá... Objetos no Workspace com 'Couch' no nome:")
            for _, obj in ipairs(Workspace:GetDescendants()) do
                if obj.Name:find("Couch") then
                    print(" - " .. obj.Name .. " (Type: " .. obj.ClassName .. ", Path: " .. obj:GetFullName() .. ")")
                end
            end
            return
        end
        print("Sofá encontrado: " .. couch.Name .. " (Type: " .. couch.ClassName .. ", Path: " .. couch:GetFullName() .. ")")

        -- Configura o sofá apenas se for BasePart
        originalProperties = {}
        if couch:IsA("BasePart") then
            originalProperties = {
                Anchored = couch.Anchored,
                CanCollide = couch.CanCollide,
                CanTouch = couch.CanTouch
            }
            couch.Anchored = false
            couch.CanCollide = true
            couch.CanTouch = true
            pcall(function() couch:SetNetworkOwner(nil) end)
            print("Propriedades do sofá configuradas: Anchored = false, CanCollide = true, CanTouch = true")
        else
            print("Sofá é um " .. couch.ClassName .. ", pulando configuração de propriedades.")
        end

        -- Ativa o NoClip
        running = true
        connection = RunService.Stepped:Connect(function()
            if not running then return end
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)

        -- Segue o jogador selecionado com backflips caóticos (como no "Matar com o Sofá")
        print("Iniciando acompanhamento de " .. selectedPlayer.Name .. " com backflips!")
        local startTime = tick()
        local walkFlingInstance = nil -- Para armazenar o BodyVelocity do walkfling
        flingConnection = RunService.Heartbeat:Connect(function()
            if not running then
                print("Loop de acompanhamento interrompido: running = false")
                return
            end
            if not selectedPlayer or not selectedPlayer.Character then
                warn("Jogador selecionado não está mais disponível!")
                running = false
                return
            end
            local newTargetHRP = selectedPlayer.Character:FindFirstChild("HumanoidRootPart")
            local newTargetHumanoid = selectedPlayer.Character:FindFirstChild("Humanoid")
            if not newTargetHRP or not newTargetHumanoid then
                warn("HumanoidRootPart ou Humanoid do jogador selecionado não encontrado!")
                running = false
                return
            end
            if not myHRP or not humanoid then
                warn("HumanoidRootPart ou Humanoid do jogador local não encontrado!")
                running = false
                return
            end

            -- Teleporta ao centro do jogador selecionado com backflips caóticos
            pcall(function()
                local targetPosition = newTargetHRP.Position -- Centro do jogador selecionado
                character:SetPrimaryPartCFrame(
                    CFrame.new(targetPosition) * CFrame.Angles(
                        math.rad(Workspace.DistributedGameTime * 12000),
                        math.rad(Workspace.DistributedGameTime * 15000),
                        math.rad(Workspace.DistributedGameTime * 18000)
                    )
                )
            end)
            print("Teleportado e aplicando backflips caóticos para " .. selectedPlayer.Name .. " (Posição: " .. tostring(newTargetHRP.Position) .. ")")

            -- Verifica se o jogador selecionado está sentado ou se o tempo limite foi atingido
            print("Jogador " .. selectedPlayer.Name .. " sentado: " .. tostring(newTargetHumanoid.Sit) .. " | Tempo decorrido: " .. tostring(tick() - startTime))
            if newTargetHumanoid.Sit or tick() - startTime > 10 then
                running = false
                flingConnection:Disconnect()
                flingConnection = nil

                -- Aplica o walkfling no jogador local (seu personagem)
                for _, part in ipairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                        pcall(function() part:SetNetworkOwner(nil) end)
                    end
                end
                walkFlingInstance = Instance.new("BodyVelocity")
                walkFlingInstance.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                walkFlingInstance.Velocity = Vector3.new(math.random(-5, 5), 5, math.random(-5, 5)).Unit * 1000000 + Vector3.new(0, 1000000, 0)
                walkFlingInstance.Parent = myHRP
                print("Walkfling ativado no jogador local!")

                -- Teleporta o jogador local para as coordenadas extremas
                pcall(function()
                    myHRP.Anchored = true
                    myHRP.CFrame = CFrame.new(Vector3.new(-59599.73, 2040070.50, -293391.16))
                    myHRP.Anchored = false
                end)
                print("Jogador local teleportado para as coordenadas extremas: X = -59599.73, Y = 2040070.50, Z = -293391.16")

                -- Faz o jogador local girar muito rápido por 0.5 segundos
                local spinStart = tick()
                local spinConnection
                spinConnection = RunService.Heartbeat:Connect(function()
                    if tick() - spinStart >= 0.5 then
                        spinConnection:Disconnect()
                        return
                    end
                    pcall(function()
                        character:SetPrimaryPartCFrame(
                            myHRP.CFrame * CFrame.Angles(
                                math.rad(Workspace.DistributedGameTime * 12000),
                                math.rad(Workspace.DistributedGameTime * 15000),
                                math.rad(Workspace.DistributedGameTime * 18000)
                            )
                        )
                    end)
                end)
                task.wait(0.5)
                print("Jogador local girou muito rápido por 0.5 segundos!")

                -- Deleta o sofá do inventário
                local args = {
                    [1] = "PlayerWantsToDeleteTool",
                    [2] = "Couch"
                }
                pcall(function()
                    ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Clea1rTool1s"):FireServer(unpack(args))
                end)
                print("Sofá removido do inventário!")

                -- Teleporta o jogador local de volta à posição inicial
                pcall(function()
                    myHRP.Anchored = true
                    myHRP.CFrame = CFrame.new(savedPosition + Vector3.new(0, 5, 0))
                    task.wait(0.2)
                    myHRP.Velocity = Vector3.zero
                    myHRP.RotVelocity = Vector3.zero
                    myHRP.Anchored = false
                    if humanoid then
                        humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                    end
                end)
                print("Jogador local retornado à posição inicial!")

                -- Desativa o walkfling do jogador local
                if walkFlingInstance then
                    walkFlingInstance:Destroy()
                    walkFlingInstance = nil
                    for _, part in ipairs(character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = true
                        end
                    end
                    print("Walkfling desativado no jogador local!")
                end
            end
        end)
    end,
})

-- BOTÃO PARAR FLING
Tab1:Button({
    Title = "Parar Fling",
    Desc = "Para o fling no jogador selecionado",
    Callback = function()
        running = false
        if connection then
            connection:Disconnect()
            connection = nil
        end
        if flingConnection then
            flingConnection:Disconnect()
            flingConnection = nil
        end

        -- Restaura as propriedades do sofá (se for BasePart)
        if couch and couch:IsA("BasePart") then
            couch.Anchored = originalProperties.Anchored
            couch.CanCollide = originalProperties.CanCollide
            couch.CanTouch = originalProperties.CanTouch
        end

        -- Desativa o NoClip
        local character = LocalPlayer.Character
        if character then
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = true
                    part.Velocity = Vector3.zero
                    part.RotVelocity = Vector3.zero
                end
            end
        end

        -- Restaura a capacidade de sentar
        local myHumanoid = character and character:FindFirstChild("Humanoid")
        if myHumanoid then
            myHumanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        end

        -- Reativa assentos
        for _, seat in ipairs(Workspace:GetDescendants()) do
            if seat:IsA("Seat") or seat:IsA("VehicleSeat") then
                seat.Disabled = false
            end
        end

        -- Restaura o tamanho do personagem
        pcall(function()
            ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Clothe1s"):FireServer("CharacterSizeUp", 1)
        end)

        -- Teleporta com segurança
        if savedPosition then
            local myHRP = character and character:FindFirstChild("HumanoidRootPart")
            if myHRP then
                myHRP.Anchored = true
                myHRP.CFrame = CFrame.new(savedPosition + Vector3.new(0, 5, 0))
                task.wait(0.2)
                myHRP.Velocity = Vector3.zero
                myHRP.RotVelocity = Vector3.zero
                myHRP.Anchored = false
                if myHumanoid then
                    myHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                end
            end
        end
        print("Fling parado. Personagem voltou à posição original.")
    end,
})

-------------------------------------------------------------------------------------------------------------------------------------------


-- BOTÃO INICIAR FLING COM ÔNIBUS
Tab1:Button({
    Title = "Iniciar Fling com Ônibus",
    Desc = "Inicia o fling no jogador selecionado usando o ônibus",
    Callback = function()
        if running then
            print("O fling já está ativo. Use o botão 'Parar Fling' primeiro.")
            return
        end
        if not selectedPlayer or not selectedPlayer.Character or not LocalPlayer.Character then
            warn("Selecione um jogador válido antes de iniciar!")
            return
        end

        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local myHRP = character:FindFirstChild("HumanoidRootPart")
        if not humanoid or not myHRP then
            warn("Seu personagem ainda não está totalmente carregado.")
            return
        end

        -- Salva a posição inicial
        savedPosition = myHRP.Position

        -- Teleporte seguro para a posição inicial (X = 1181.83, Y = 76.08, Z = -1158.83)
        pcall(function()
            myHRP.Anchored = true
            myHRP.CFrame = CFrame.new(Vector3.new(1181.83, 76.08, -1158.83))
            task.wait(0.2)
            myHRP.Velocity = Vector3.zero
            myHRP.RotVelocity = Vector3.zero
            myHRP.Anchored = false
            if humanoid then
                humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
            end
        end)
        print("Jogador local teleportado para a posição inicial: X = 1181.83, Y = 76.08, Z = -1158.83")

        -- Espera 0.5 segundos
        task.wait(0.5)

        -- Deleta todos os veículos
        local args = { [1] = "DeleteAllVehicles" }
        pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
        end)
        print("Todos os veículos deletados!")

        -- Spawnar o ônibus (SchoolBus)
        local args = { [1] = "PickingCar", [2] = "SchoolBus" }
        pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
        end)
        print("Ônibus (SchoolBus) spawnado!")

        -- Espera 1 segundo para garantir que o ônibus apareça no Workspace
        task.wait(1)

        -- Localiza o ônibus em Workspace.Vehicles com o nome do jogador local (ex.: rtrt967Car)
        local bus = nil
        local vehiclesFolder = Workspace:FindFirstChild("Vehicles")
        if not vehiclesFolder then
            warn("Pasta Vehicles não encontrada no Workspace!")
            return
        end
        local busName = LocalPlayer.Name .. "Car" -- ex.: rtrt967Car
        bus = vehiclesFolder:FindFirstChild(busName)
        if not bus then
            warn("Ônibus não encontrado em Workspace.Vehicles com o nome: " .. busName)
            print("Procurando ônibus... Objetos em Workspace.Vehicles:")
            for _, obj in ipairs(vehiclesFolder:GetChildren()) do
                print(" - " .. obj.Name .. " (Type: " .. obj.ClassName .. ", Path: " .. obj:GetFullName() .. ")")
            end
            return
        end
        print("Ônibus encontrado: " .. bus.Name .. " (Path: " .. bus:GetFullName() .. ")")

        -- Teleporta o jogador para a posição do assento do motorista (X = 1171.15, Y = 79.45, Z = -1166.2)
        pcall(function()
            myHRP.Anchored = true
            myHRP.CFrame = CFrame.new(Vector3.new(1171.15, 79.45, -1166.2))
            task.wait(0.2)
            myHRP.Velocity = Vector3.zero
            myHRP.RotVelocity = Vector3.zero
            myHRP.Anchored = false
            humanoid:ChangeState(Enum.HumanoidStateType.Seated)
        end)
        print("Jogador local teleportado para a posição do assento do motorista: X = 1171.15, Y = 79.45, Z = -1166.2")

        -- Espera até que o jogador local esteja sentado (timeout de 10 segundos)
        local sitStart = tick()
        repeat
            task.wait()
            if tick() - sitStart > 10 then
                warn("Timeout: Jogador local não foi detectado como sentado!")
                return
            end
        until humanoid.Sit
        print("Jogador local detectado como sentado!")

        -- Remove colisões do ônibus
        for _, part in ipairs(bus:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
                pcall(function() part:SetNetworkOwner(nil) end)
            end
        end
        print("Colisões do ônibus desativadas!")

        -- Ativa o NoClip para o jogador local
        running = true
        connection = RunService.Stepped:Connect(function()
            if not running then return end
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)

        -- Segue o jogador selecionado com backflips agressivos em todas as direções
        print("Iniciando acompanhamento de " .. selectedPlayer.Name .. " com backflips agressivos!")
        local startTime = tick()
        local walkFlingInstanceBus = nil -- Para o walkfling do ônibus
        local walkFlingInstancePlayer = nil -- Para o walkfling do jogador local
        flingConnection = RunService.Heartbeat:Connect(function()
            if not running then
                print("Loop de acompanhamento interrompido: running = false")
                return
            end
            if not selectedPlayer or not selectedPlayer.Character then
                warn("Jogador selecionado não está mais disponível!")
                running = false
                return
            end
            local newTargetHRP = selectedPlayer.Character:FindFirstChild("HumanoidRootPart")
            local newTargetHumanoid = selectedPlayer.Character:FindFirstChild("Humanoid")
            if not newTargetHRP or not newTargetHumanoid then
                warn("HumanoidRootPart ou Humanoid do jogador selecionado não encontrado!")
                running = false
                return
            end
            if not myHRP or not humanoid then
                warn("HumanoidRootPart ou Humanoid do jogador local não encontrado!")
                running = false
                return
            end

            -- Teleporta o ônibus para diferentes posições ao redor do jogador selecionado com backflips agressivos
            local offset = Vector3.new(math.random(-10, 10), 0, math.random(-10, 10)) -- Frente, trás, lados
            pcall(function()
                local targetPosition = newTargetHRP.Position + offset
                bus:PivotTo(
                    CFrame.new(targetPosition) * CFrame.Angles(
                        math.rad(Workspace.DistributedGameTime * 12000),
                        math.rad(Workspace.DistributedGameTime * 15000),
                        math.rad(Workspace.DistributedGameTime * 18000)
                    )
                )
            end)
            print("Ônibus teleportado e aplicando backflips agressivos para " .. selectedPlayer.Name .. " (Posição: " .. tostring(newTargetHRP.Position + offset) .. ")")

            -- Verifica se o jogador selecionado sentou em algum assento do ônibus
            local playerSeated = false
            for _, seat in ipairs(bus:GetDescendants()) do
                if (seat:IsA("Seat") or seat:IsA("VehicleSeat")) and seat.Name ~= "VehicleSeat" then -- Exclui o assento do motorista
                    if seat.Occupant == newTargetHumanoid then
                        playerSeated = true
                        break
                    end
                end
            end
            print("Jogador " .. selectedPlayer.Name .. " sentado no ônibus: " .. tostring(playerSeated) .. " | Tempo decorrido: " .. tostring(tick() - startTime))
            if playerSeated or tick() - startTime > 10 then
                running = false
                flingConnection:Disconnect()
                flingConnection = nil

                -- Teleporta o ônibus para a posição do fling anterior (X = -59599.73, Y = 2040070.50, Z = -293391.16)
                pcall(function()
                    bus:PivotTo(CFrame.new(Vector3.new(-59599.73, 2040070.50, -293391.16)))
                end)
                print("Ônibus teleportado para as coordenadas extremas: X = -59599.73, Y = 2040070.50, Z = -293391.16")

                -- Aplica o walkfling no ônibus
                local busHRP = bus:FindFirstChild("Body") and bus.Body:FindFirstChild("BusBody")
                if busHRP then
                    walkFlingInstanceBus = Instance.new("BodyVelocity")
                    walkFlingInstanceBus.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                    walkFlingInstanceBus.Velocity = Vector3.new(math.random(-5, 5), 5, math.random(-5, 5)).Unit * 1000000 + Vector3.new(0, 1000000, 0)
                    walkFlingInstanceBus.Parent = busHRP
                    print("Walkfling ativado no ônibus!")
                else
                    warn("BusBody não encontrado para aplicar o walkfling!")
                end

                -- Aplica o walkfling no jogador local
                walkFlingInstancePlayer = Instance.new("BodyVelocity")
                walkFlingInstancePlayer.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                walkFlingInstancePlayer.Velocity = Vector3.new(math.random(-5, 5), 5, math.random(-5, 5)).Unit * 1000000 + Vector3.new(0, 1000000, 0)
                walkFlingInstancePlayer.Parent = myHRP
                print("Walkfling ativado no jogador local!")

                -- Espera 0.5 segundos
                task.wait(0.5)

                -- Deleta o ônibus (e todos os veículos)
                local args = { [1] = "DeleteAllVehicles" }
                pcall(function()
                    game:GetService("ReplicatedStorage"):WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
                end)
                print("Ônibus deletado! Jogador selecionado deve estar voando para longe!")

                -- Desativa os walkflings
                if walkFlingInstanceBus then
                    walkFlingInstanceBus:Destroy()
                    walkFlingInstanceBus = nil
                end
                if walkFlingInstancePlayer then
                    walkFlingInstancePlayer:Destroy()
                    walkFlingInstancePlayer = nil
                    for _, part in ipairs(character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = true
                        end
                    end
                    print("Walkflings desativados!")
                end

                -- Teleporta o jogador local de volta à posição inicial com teleporte seguro
                pcall(function()
                    myHRP.Anchored = true
                    myHRP.CFrame = CFrame.new(savedPosition + Vector3.new(0, 5, 0))
                    task.wait(0.2)
                    myHRP.Velocity = Vector3.zero
                    myHRP.RotVelocity = Vector3.zero
                    myHRP.Anchored = false
                    if humanoid then
                        humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                    end
                end)
                print("Jogador local retornado à posição inicial!")
            end
        end)
    end,
})

-- BOTÃO PARAR FLING
Tab1:Button({
    Title = "Parar Fling",
    Desc = "Para o fling no jogador selecionado",
    Callback = function()
        running = false
        if connection then
            connection:Disconnect()
            connection = nil
        end
        if flingConnection then
            flingConnection:Disconnect()
            flingConnection = nil
        end

        -- Desativa o NoClip
        local character = LocalPlayer.Character
        if character then
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = true
                    part.Velocity = Vector3.zero
                    part.RotVelocity = Vector3.zero
                end
            end
        end

        -- Restaura a capacidade de sentar
        local myHumanoid = character and character:FindFirstChild("Humanoid")
        if myHumanoid then
            myHumanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        end

        -- Reativa assentos
        for _, seat in ipairs(Workspace:GetDescendants()) do
            if seat:IsA("Seat") or seat:IsA("VehicleSeat") then
                seat.Disabled = false
            end
        end

        -- Restaura o tamanho do personagem
        pcall(function()
            ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Clothe1s"):FireServer("CharacterSizeUp", 1)
        end)

        -- Teleporta com segurança
        if savedPosition then
            local myHRP = character and character:FindFirstChild("HumanoidRootPart")
            if myHRP then
                myHRP.Anchored = true
                myHRP.CFrame = CFrame.new(savedPosition + Vector3.new(0, 5, 0))
                task.wait(0.2)
                myHRP.Velocity = Vector3.zero
                myHRP.RotVelocity = Vector3.zero
                myHRP.Anchored = false
                if myHumanoid then
                    myHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                end
            end
        end
        print("Fling parado. Personagem voltou à posição original.")
    end,
})

--------------------------------------------------------------------------------------------------------------------------------------------------------


-- BOTÃO INICIAR FLING COM BARCO
Tab1:Button({
    Title = "Iniciar Fling com Barco",
    Desc = "Inicia o fling no jogador selecionado usando o barco",
    Callback = function()
        if running then
            print("O fling já está ativo. Use o botão 'Parar Fling' primeiro.")
            return
        end
        if not selectedPlayer or not selectedPlayer.Character or not LocalPlayer.Character then
            warn("Selecione um jogador válido antes de iniciar!")
            return
        end

        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local myHRP = character:FindFirstChild("HumanoidRootPart")
        if not humanoid or not myHRP then
            warn("Seu personagem ainda não está totalmente carregado.")
            return
        end

        -- Salva a posição inicial
        savedPosition = myHRP.Position

        -- Teleporte seguro para a posição inicial (X = -3359.52, Y = -5.05, Z = -501.94)
        pcall(function()
            myHRP.Anchored = true
            myHRP.CFrame = CFrame.new(Vector3.new(-3359.52, -5.05, -501.94))
            task.wait(0.2)
            myHRP.Velocity = Vector3.zero
            myHRP.RotVelocity = Vector3.zero
            myHRP.Anchored = false
            if humanoid then
                humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
            end
        end)
        print("Jogador local teleportado para a posição inicial: X = -3359.52, Y = -5.05, Z = -501.94")

        -- Deleta todos os veículos
        local args = { [1] = "DeleteAllVehicles" }
        pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
        end)
        print("Todos os veículos deletados!")

        -- Espera 0.4 segundos
        task.wait(0.4)

        -- Spawnar o barco (MilitaryBoatFree)
        local args = { [1] = "PickingBoat", [2] = "MilitaryBoatFree" }
        pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
        end)
        print("Barco (MilitaryBoatFree) spawnado!")

        -- Espera 1.5 segundos para garantir que o barco apareça no Workspace
        task.wait(1.5)

        -- Localiza o barco em Workspace.Vehicles com o nome do jogador local (ex.: rtrt967Car)
        local boat = nil
        local vehiclesFolder = Workspace:FindFirstChild("Vehicles")
        if not vehiclesFolder then
            warn("Pasta Vehicles não encontrada no Workspace!")
            return
        end
        local boatName = LocalPlayer.Name .. "Car" -- ex.: rtrt967Car
        boat = vehiclesFolder:FindFirstChild(boatName)
        if not boat then
            warn("Barco não encontrado em Workspace.Vehicles com o nome: " .. boatName)
            print("Procurando barco... Objetos em Workspace.Vehicles:")
            for _, obj in ipairs(vehiclesFolder:GetChildren()) do
                print(" - " .. obj.Name .. " (Type: " .. obj.ClassName .. ", Path: " .. obj:GetFullName() .. ")")
            end
            return
        end
        print("Barco encontrado: " .. boat.Name .. " (Path: " .. boat:GetFullName() .. ")")

        -- Teleporta o jogador para a posição do assento do motorista (X = -3358.85, Y = 5.25, Z = -521.95)
        pcall(function()
            myHRP.Anchored = true
            myHRP.CFrame = CFrame.new(Vector3.new(-3358.85, 5.25, -521.95))
            task.wait(0.2)
            myHRP.Velocity = Vector3.zero
            myHRP.RotVelocity = Vector3.zero
            myHRP.Anchored = false
            humanoid:ChangeState(Enum.HumanoidStateType.Seated)
        end)
        print("Jogador local teleportado para a posição do assento do motorista: X = -3358.85, Y = 5.25, Z = -521.95")

        -- Espera até que o jogador local esteja sentado (timeout de 10 segundos)
        local sitStart = tick()
        repeat
            task.wait()
            if tick() - sitStart > 10 then
                warn("Timeout: Jogador local não foi detectado como sentado! Prosseguindo mesmo assim...")
                break
            end
        until humanoid.Sit
        print("Jogador local detectado como sentado!")

        -- Remove colisões do barco para facilitar o movimento, mas mantém para colisão com o jogador
        for _, part in ipairs(boat:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true -- Mantém colisão para lançar o jogador
                pcall(function() part:SetNetworkOwner(nil) end)
            end
        end
        print("Colisões do barco configuradas!")

        -- Ativa o NoClip para o jogador local
        running = true
        connection = RunService.Stepped:Connect(function()
            if not running then return end
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)

        -- Detecta colisão do jogador selecionado com o barco
        local touchedConnection
        touchedConnection = boat.Touched:Connect(function(hit)
            if not running then return end
            local hitPlayer = game.Players:GetPlayerFromCharacter(hit.Parent)
            if hitPlayer and hitPlayer == selectedPlayer then
                local targetHRP = hit.Parent:FindFirstChild("HumanoidRootPart")
                if targetHRP then
                    local flingForce = Instance.new("BodyVelocity")
                    flingForce.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                    flingForce.Velocity = Vector3.new(math.random(-5, 5), 5, math.random(-5, 5)).Unit * 1000000 + Vector3.new(0, 1000000, 0)
                    flingForce.Parent = targetHRP
                    task.defer(function()
                        task.wait(1)
                        flingForce:Destroy()
                    end)
                    print("Jogador " .. selectedPlayer.Name .. " encostou no barco e foi lançado!")
                end
            end
        end)

        -- Segue o jogador selecionado com backflips agressivos até o botão "Parar Fling" ser pressionado
        print("Iniciando acompanhamento de " .. selectedPlayer.Name .. " com backflips agressivos!")
        local startTime = tick()
        local walkFlingInstanceBoat = nil -- Para o walkfling do barco
        local walkFlingInstancePlayer = nil -- Para o walkfling do jogador local
        flingConnection = RunService.Heartbeat:Connect(function()
            if not running then
                print("Loop de acompanhamento interrompido: running = false")
                if touchedConnection then
                    touchedConnection:Disconnect()
                    touchedConnection = nil
                end
                return
            end
            if not selectedPlayer or not selectedPlayer.Character then
                warn("Jogador selecionado não está mais disponível!")
                running = false
                if touchedConnection then
                    touchedConnection:Disconnect()
                    touchedConnection = nil
                end
                return
            end
            local newTargetHRP = selectedPlayer.Character:FindFirstChild("HumanoidRootPart")
            local newTargetHumanoid = selectedPlayer.Character:FindFirstChild("Humanoid")
            if not newTargetHRP or not newTargetHumanoid then
                warn("HumanoidRootPart ou Humanoid do jogador selecionado não encontrado!")
                running = false
                if touchedConnection then
                    touchedConnection:Disconnect()
                    touchedConnection = nil
                end
                return
            end
            if not myHRP or not humanoid then
                warn("HumanoidRootPart ou Humanoid do jogador local não encontrado!")
                running = false
                if touchedConnection then
                    touchedConnection:Disconnect()
                    touchedConnection = nil
                end
                return
            end

            -- Teleporta o barco para o centro do jogador selecionado com backflips agressivos
            pcall(function()
                local targetPosition = newTargetHRP.Position
                boat:PivotTo(
                    CFrame.new(targetPosition) * CFrame.Angles(
                        math.rad(Workspace.DistributedGameTime * 12000),
                        math.rad(Workspace.DistributedGameTime * 15000),
                        math.rad(Workspace.DistributedGameTime * 18000)
                    )
                )
            end)
            print("Barco teleportado e aplicando backflips agressivos para " .. selectedPlayer.Name .. " (Posição: " .. tostring(newTargetHRP.Position) .. ")")

            -- Verifica se o jogador selecionado sentou em algum assento do barco
            local playerSeated = false
            for _, seat in ipairs(boat:GetDescendants()) do
                if (seat:IsA("Seat") or seat:IsA("VehicleSeat")) and seat.Name ~= "VehicleSeat" then -- Exclui o assento do motorista
                    if seat.Occupant == newTargetHumanoid then
                        playerSeated = true
                        break
                    end
                end
            end
            print("Jogador " .. selectedPlayer.Name .. " sentado no barco: " .. tostring(playerSeated) .. " | Tempo decorrido: " .. tostring(tick() - startTime))
            if playerSeated then
                running = false
                flingConnection:Disconnect()
                flingConnection = nil
                if touchedConnection then
                    touchedConnection:Disconnect()
                    touchedConnection = nil
                end

                -- Teleporta o barco para a posição do fling anterior (X = -59599.73, Y = 2040070.50, Z = -293391.16)
                pcall(function()
                    boat:PivotTo(CFrame.new(Vector3.new(-59599.73, 2040070.50, -293391.16)))
                end)
                print("Barco teleportado para as coordenadas extremas: X = -59599.73, Y = 2040070.50, Z = -293391.16")

                -- Aplica o walkfling no barco
                local boatHRP = boat:FindFirstChild("Body") and boat.Body:FindFirstChild("BusBody")
                if boatHRP then
                    walkFlingInstanceBoat = Instance.new("BodyVelocity")
                    walkFlingInstanceBoat.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                    walkFlingInstanceBoat.Velocity = Vector3.new(math.random(-5, 5), 5, math.random(-5, 5)).Unit * 1000000 + Vector3.new(0, 1000000, 0)
                    walkFlingInstanceBoat.Parent = boatHRP
                    print("Walkfling ativado no barco!")
                else
                    warn("BusBody não encontrado para aplicar o walkfling! Tentando outro método...")
                    for _, part in ipairs(boat:GetDescendants()) do
                        if part:IsA("BasePart") and part.Name == "Body" then
                            walkFlingInstanceBoat = Instance.new("BodyVelocity")
                            walkFlingInstanceBoat.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                            walkFlingInstanceBoat.Velocity = Vector3.new(math.random(-5, 5), 5, math.random(-5, 5)).Unit * 1000000 + Vector3.new(0, 1000000, 0)
                            walkFlingInstanceBoat.Parent = part
                            print("Walkfling ativado no barco (parte alternativa)!")
                            break
                        end
                    end
                end

                -- Aplica o walkfling no jogador local
                walkFlingInstancePlayer = Instance.new("BodyVelocity")
                walkFlingInstancePlayer.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                walkFlingInstancePlayer.Velocity = Vector3.new(math.random(-5, 5), 5, math.random(-5, 5)).Unit * 1000000 + Vector3.new(0, 1000000, 0)
                walkFlingInstancePlayer.Parent = myHRP
                print("Walkfling ativado no jogador local!")

                -- Espera 0.5 segundos
                task.wait(0.5)

                -- Deleta todos os veículos
                local args = { [1] = "DeleteAllVehicles" }
                pcall(function()
                    game:GetService("ReplicatedStorage"):WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
                end)
                print("Barco deletado! Jogador selecionado deve estar voando para longe!")

                -- Desativa os walkflings
                if walkFlingInstanceBoat then
                    walkFlingInstanceBoat:Destroy()
                    walkFlingInstanceBoat = nil
                end
                if walkFlingInstancePlayer then
                    walkFlingInstancePlayer:Destroy()
                    walkFlingInstancePlayer = nil
                    for _, part in ipairs(character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = true
                        end
                    end
                    print("Walkflings desativados!")
                end

                -- Teleporta o jogador local de volta à posição inicial com teleporte seguro
                pcall(function()
                    myHRP.Anchored = true
                    myHRP.CFrame = CFrame.new(savedPosition + Vector3.new(0, 5, 0))
                    task.wait(0.2)
                    myHRP.Velocity = Vector3.zero
                    myHRP.RotVelocity = Vector3.zero
                    myHRP.Anchored = false
                    if humanoid then
                        humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                    end
                end)
                print("Jogador local retornado à posição inicial!")
            end
        end)
    end,
})

-- BOTÃO PARAR FLING
Tab1:Button({
    Title = "Parar Fling",
    Desc = "Para o fling no jogador selecionado",
    Callback = function()
        running = false
        if connection then
            connection:Disconnect()
            connection = nil
        end
        if flingConnection then
            flingConnection:Disconnect()
            flingConnection = nil
        end

        -- Desativa o NoClip
        local character = LocalPlayer.Character
        if character then
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = true
                    part.Velocity = Vector3.zero
                    part.RotVelocity = Vector3.zero
                end
            end
        end

        -- Restaura a capacidade de sentar
        local myHumanoid = character and character:FindFirstChild("Humanoid")
        if myHumanoid then
            myHumanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        end

        -- Reativa assentos
        for _, seat in ipairs(Workspace:GetDescendants()) do
            if seat:IsA("Seat") or seat:IsA("VehicleSeat") then
                seat.Disabled = false
            end
        end

        -- Restaura o tamanho do personagem
        pcall(function()
            ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Clothe1s"):FireServer("CharacterSizeUp", 1)
        end)

        -- Teleporta com segurança
        if savedPosition then
            local myHRP = character and character:FindFirstChild("HumanoidRootPart")
            if myHRP then
                myHRP.Anchored = true
                myHRP.CFrame = CFrame.new(savedPosition + Vector3.new(0, 5, 0))
                task.wait(0.2)
                myHRP.Velocity = Vector3.zero
                myHRP.RotVelocity = Vector3.zero
                myHRP.Anchored = false
                if myHumanoid then
                    myHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                end
            end
        end
        print("Fling parado. Personagem voltou à posição original.")
    end,
})
