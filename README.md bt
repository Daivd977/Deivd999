local WindUI = loadstring(game:HttpGet("https://tree-hub.vercel.app/api/UI/WindUI"))()
local Version = "1.4.0"

local Window = WindUI:CreateWindow({
    Title = "Lolyta troll 666",
    Icon = "door-open",
    Author = "Lolycon666",
    Folder = "Lolyta 666",
    Size = UDim2.fromOffset(580, 460),
    KeySystem = {
        Key = "666",
        Note = "pode nao man",
        URL = "",
        SaveKey = true,
    },
    Transparent = true,
    Theme = "Dark",
    SideBarWidth = 200,
    HasOutline = false,
})

-- fjgjgjfgmdfkj gjf g f gnf  gnjdf gnjdf gfdg dfg df g fgfdgjfgjnf gdjn ffffffffffff  fffffffffffff ffffffffffffffffff ffffffffffffffff ffffffffffffffff fffffffffffffffff 

-- fjgjgjfgmdfkj gjf g f gnf  gnjdf gnjdf gfdg dfg df g fgfdgjfgjnf gdjn ffffffffffff  fffffffffffff ffffffffffffffffff ffffffffffffffff ffffffffffffffff fffffffffffffffff

-- fjgjgjfgmdfkj gjf g f gnf  gnjdf gnjdf gfdg dfg df g fgfdgjfgjnf gdjn ffffffffffff  fffffffffffff ffffffffffffffffff ffffffffffffffff ffffffffffffffff fffffffffffffffff

-- fjgjgjfgmdfkj gjf g f gnf  gnjdf gnjdf gfdg dfg df g fgfdgjfgjnf gdjn ffffffffffff  fffffffffffff ffffffffffffffffff ffffffffffffffff ffffffffffffffff fffffffffffffffff

-- fjgjgjfgmdfkj gjf g f gnf  gnjdf gnjdf gfdg dfg df g fgfdgjfgjnf gdjn ffffffffffff  fffffffffffff ffffffffffffffffff ffffffffffffffff ffffffffffffffff fffffffffffffffff

-- fjgjgjfgmdfkj gjf g f gnf  gnjdf gnjdf gfdg dfg df g fgfdgjfgjnf gdjn ffffffffffff  fffffffffffff ffffffffffffffffff ffffffffffffffff ffffffffffffffff fffffffffffffffff

-- fjgjgjfgmdfkj gjf g f gnf  gnjdf gnjdf gfdg dfg df g fgfdgjfgjnf gdjn ffffffffffff  fffffffffffff ffffffffffffffffff ffffffffffffffff ffffffffffffffff fffffffffffffffff

-- fjgjgjfgmdfkj gjf g f gnf  gnjdf gnjdf gfdg dfg df g fgfdgjfgjnf gdjn ffffffffffff  fffffffffffff ffffffffffffffffff ffffffffffffffff ffffffffffffffff fffffffffffffffff
-- fjgjgjfgmdfkj gjf g f gnf  gnjdf gnjdf gfdg dfg df g fgfdgjfgjnf gdjn ffffffffffff  fffffffffffff ffffffffffffffffff ffffffffffffffff ffffffffffffffff fffffffffffffffff
-- fjgjgjfgmdfkj gjf g f gnf  gnjdf gnjdf gfdg dfg df g fgfdgjfgjnf gdjn ffffffffffff  fffffffffffff ffffffffffffffffff ffffffffffffffff ffffffffffffffff fffffffffffffffff-- fjgjgjfgmdfkj gjf g f gnf  gnjdf gnjdf gfdg dfg df g fgfdgjfgjnf gdjn ffffffffffff  fffffffffffff ffffffffffffffffff ffffffffffffffff ffffffffffffffff fffffffffffffffff

-- fjgjgjfgmdfkj gjf g f gnf  gnjdf gnjdf gfdg dfg df g fgfdgjfgjnf gdjn ffffffffffff  fffffffffffff ffffffffffffffffff ffffffffffffffff ffffffffffffffff fffffffffffffffff
-- fjgjgjfgmdfkj gjf g f gnf  gnjdf gnjdf gfdg dfg df g fgfdgjfgjnf gdjn ffffffffffff  fffffffffffff ffffffffffffffffff ffffffffffffffff ffffffffffffffff fffffffffffffffff

Window:EditOpenButton({
    Title = "Lolyta troll",
    Icon = "align-justify",
    CornerRadius = UDim.new(0, 10),
    StrokeThickness = 3,
    Color = ColorSequence.new(Color3.fromHex("FF0F7B"), Color3.fromHex("F89B29"))
})

-- === Abas da Interface === --
local Tab1 = Window:Tab({ Title = "troll", Icon = "Ball" })

-----------------------------------------------------------------------------------------------------------------------------------------
                                          -- === Tab 1: Troll === --
-----------------------------------------------------------------------------------------------------------------------------------------

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

-- Variáveis compartilhadas
local selectedPlayer = nil
local isFollowingKill = false
local isFollowingPull = false
local originalPosition = nil
local isSpectating = false
local spectatedPlayer = nil
local characterConnection = nil
local soccerBall = nil
local running = false
local connection, flingConnection
local originalProperties = {}
local savedPosition = nil

-- Cria um RemoteEvent para comunicação com o servidor
local SetNetworkOwnerEvent = Instance.new("RemoteEvent")
SetNetworkOwnerEvent.Name = "SetNetworkOwnerEvent_" .. tostring(math.random(1000, 9999))
SetNetworkOwnerEvent.Parent = ReplicatedStorage

-- Cria um script no servidor para lidar com o RemoteEvent
local serverScriptCode = [[
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local event = ReplicatedStorage:WaitForChild("]] .. SetNetworkOwnerEvent.Name .. [[")
    
    event.OnServerEvent:Connect(function(player, part, networkOwner)
        if part and part:IsA("BasePart") then
            pcall(function()
                part:SetNetworkOwner(networkOwner)
                part.Anchored = false
                part.CanCollide = true
                part.CanTouch = true
            end)
        end
    end)
]]

local success, errorMessage = pcall(function()
    loadstring(serverScriptCode)()
end)
if not success then
    warn("Erro ao criar script no servidor: " .. tostring(errorMessage))
end

-- Função para obter os nomes dos jogadores, excluindo o jogador local
local function getPlayerNames()
    local playerNames = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playerNames, player.Name)
        end
    end
    return playerNames
end

-- Função para atualizar o dropdown
local function updateDropdown(dropdown)
    local success, errorMessage = pcall(function()
        local playerNames = getPlayerNames()
        dropdown:Refresh(playerNames)
        if selectedPlayer and not table.find(playerNames, selectedPlayer.Name) then
            dropdown:SetValue("")
            selectedPlayer = nil
            print("Jogador anterior saiu do jogo. Seleção resetada.")
        end
    end)
    if not success then
        warn("Erro ao atualizar dropdown: " .. tostring(errorMessage))
    end
end

-- Função para visualizar um jogador
local function spectatePlayer(playerName)
    if characterConnection then
        characterConnection:Disconnect()
        characterConnection = nil
    end

    local targetPlayer = Players:FindFirstChild(playerName)
    if targetPlayer and targetPlayer ~= LocalPlayer then
        spectatedPlayer = targetPlayer
        isSpectating = true
        print("Visualizando jogador: " .. targetPlayer.Name)

        local function updateCamera()
            if not isSpectating or not spectatedPlayer then
                return
            end
            if spectatedPlayer.Character and spectatedPlayer.Character:FindFirstChild("Humanoid") then
                Workspace.CurrentCamera.CameraSubject = spectatedPlayer.Character.Humanoid
            else
                Workspace.CurrentCamera.CameraSubject = nil
            end
        end

        updateCamera()

        characterConnection = RunService.Heartbeat:Connect(function()
            if not isSpectating then
                characterConnection:Disconnect()
                characterConnection = nil
                return
            end
            local success, errorMessage = pcall(updateCamera)
            if not success then
                warn("Erro ao atualizar câmera no modo visualização: " .. tostring(errorMessage))
                stopSpectating()
            end
        end)

        spectatedPlayer.CharacterAdded:Connect(function()
            if isSpectating then
                updateCamera()
            end
        end)
    else
        print("Jogador inválido ou não encontrado para modo visualização.")
        isSpectating = false
        spectatedPlayer = nil
    end
end

-- Função para parar de visualizar
local function stopSpectating()
    if characterConnection then
        characterConnection:Disconnect()
        characterConnection = nil
    end

    isSpectating = false
    spectatedPlayer = nil

    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        Workspace.CurrentCamera.CameraSubject = LocalPlayer.Character.Humanoid
        Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
        print("Parando de visualizar. Voltando à visão do jogador local.")
    else
        Workspace.CurrentCamera.CameraSubject = nil
        Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
        print("Nenhum personagem local encontrado. Câmera redefinida.")
    end
end

-- Detecta quando o jogador local morre e reseta a câmera
LocalPlayer.CharacterAdded:Connect(function(character)
    if isSpectating then
        stopSpectating()
        print("Você morreu. Câmera voltou para o seu personagem.")
    end
end)

-- Botão System Broken
Tab1:Button({
    Title = "System Broken",
    Desc = "Universal",
    Callback = function()
        local success, errorMessage = pcall(function()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/H20CalibreYT/SystemBroken/main/script"))()
        end)
        if not success then
            warn("Erro ao carregar System Broken: " .. tostring(errorMessage))
        end
    end,
})

Tab1:Paragraph({ 
    Title = "Execute o System Broken e ative o VoidProtection", 
    Desc = "Faça isso antes de usar as funções abaixo!!!"
})

-- Dropdown para selecionar jogador
local DropdownPlayer = Tab1:Dropdown({
    Title = "Selecionar Jogador",
    Desc = "Escolha um jogador para matar, puxar ou aplicar fling",
    Value = "",
    Multi = false,
    AllowNone = true,
    Values = getPlayerNames(),
    Callback = function(selectedPlayerName)
        if selectedPlayerName == "" or selectedPlayerName == nil then
            selectedPlayer = nil
            print("Nenhum jogador selecionado.")
            if running then
                running = false
                if connection then connection:Disconnect() end
                if flingConnection then flingConnection:Disconnect() end
                stopSpectating()
            end
            isFollowingKill = false
            isFollowingPull = false
        else
            selectedPlayer = Players:FindFirstChild(selectedPlayerName)
            print("Jogador selecionado: " .. selectedPlayerName)
            if isSpectating then
                stopSpectating()
                spectatePlayer(selectedPlayerName)
            end
            if running then
                print("Jogador do fling atualizado para: " .. selectedPlayerName)
            end
        end
    end,
})

-- Botão para atualizar a lista de jogadores
Tab1:Button({
    Title = "Atualizar Lista de Jogadores",
    Desc = "Atualiza a lista de jogadores no dropdown",
    Callback = function()
        updateDropdown(DropdownPlayer)
        print("Lista de jogadores atualizada!")
    end,
})

-- Toggle para visualizar jogador
local SpectateToggle = Tab1:Toggle({
    Title = "Visualizar Jogador",
    Desc = "Ativa/desativa a visualização do jogador selecionado",
    Default = false,
    Callback = function(state)
        if state then
            if selectedPlayer then
                local success, errorMessage = pcall(spectatePlayer, selectedPlayer.Name)
                if not success then
                    warn("Erro ao ativar modo visualização: " .. tostring(errorMessage))
                    SpectateToggle:SetValue(false)
                end
            else
                print("Selecione um jogador antes de ativar a visualização.")
                SpectateToggle:SetValue(false)
            end
        else
            local success, errorMessage = pcall(stopSpectating)
            if not success then
                warn("Erro ao desativar modo visualização: " .. tostring(errorMessage))
            end
        end
    end,
})

-- Botão para iniciar matar
Tab1:Button({
    Title = "Iniciar Matar com o Sofá",
    Desc = "Clique para começar a matar o jogador selecionado",
    Callback = function()
        if isFollowingKill or isFollowingPull then
            print("Uma ação (matar ou puxar) já está ativa. Use o botão Parar primeiro.")
            return
        end
        if not selectedPlayer or not selectedPlayer.Character or not LocalPlayer.Character then
            warn("Selecione um jogador válido antes de iniciar!")
            return
        end

        -- Verifica se o sofá está no inventário
        local backpack = LocalPlayer:WaitForChild("Backpack")
        local sofa = backpack:FindFirstChild("Couch")

        if not sofa then
            -- Pega o sofá se não estiver na mochila
            local args = { [1] = "PickingTools", [2] = "Couch" }
            ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Too1l"):InvokeServer(unpack(args))

            repeat
                sofa = backpack:FindFirstChild("Couch")
                task.wait()
            until sofa or task.wait(5) -- Timeout de 5 segundos
            if not sofa then
                warn("Falha ao pegar o sofá!")
                return
            end
        end

        -- Equipa o sofá
        sofa.Parent = LocalPlayer.Character
        print("Sofá equipado!")

        isFollowingKill = true
        originalPosition = LocalPlayer.Character:FindFirstChild("HumanoidRootPart").Position
        print("Iniciando matar para: " .. selectedPlayer.Name)
    end,
})

-- Botão para iniciar puxar
Tab1:Button({
    Title = "Iniciar Puxar",
    Desc = "Clique para começar a puxar o jogador selecionado",
    Callback = function()
        if isFollowingKill or isFollowingPull then
            print("Uma ação (matar ou puxar) já está ativa. Use o botão Parar primeiro.")
            return
        end
        if not selectedPlayer or not selectedPlayer.Character or not LocalPlayer.Character then
            warn("Selecione um jogador válido antes de iniciar!")
            return
        end

        -- Verifica se o sofá está no inventário
        local backpack = LocalPlayer:WaitForChild("Backpack")
        local sofa = backpack:FindFirstChild("Couch")

        if not sofa then
            -- Pega o sofá se não estiver na mochila
            local args = { [1] = "PickingTools", [2] = "Couch" }
            ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Too1l"):InvokeServer(unpack(args))

            repeat
                sofa = backpack:FindFirstChild("Couch")
                task.wait()
            until sofa or task.wait(5) -- Timeout de 5 segundos
            if not sofa then
                warn("Falha ao pegar o sofá!")
                return
            end
        end

        -- Equipa o sofá
        sofa.Parent = LocalPlayer.Character
        print("Sofá equipado!")

        isFollowingPull = true
        originalPosition = LocalPlayer.Character:FindFirstChild("HumanoidRootPart").Position
        print("Iniciando puxar para: " .. selectedPlayer.Name)
    end,
})

-- Botão para parar matar ou puxar
Tab1:Button({
    Title = "Parar (Matar ou Puxar)",
    Desc = "Para o movimento de matar ou puxar",
    Callback = function()
        isFollowingKill = false
        isFollowingPull = false

        for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
                part.Velocity = Vector3.zero
                part.RotVelocity = Vector3.zero
            end
        end

        -- Restaura a capacidade de sentar
        local myHumanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
        if myHumanoid then
            myHumanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        end

        for _, seat in ipairs(Workspace:GetDescendants()) do
            if seat:IsA("Seat") or seat:IsA("VehicleSeat") then
                seat.Disabled = false
            end
        end

        -- Teleporta com segurança
        if originalPosition then
            local myHRP = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if myHRP then
                myHRP.Anchored = true
                myHRP.CFrame = CFrame.new(originalPosition + Vector3.new(0, 5, 0))
                task.wait(0.2)
                myHRP.Velocity = Vector3.zero
                myHRP.RotVelocity = Vector3.zero
                myHRP.Anchored = false
                if myHumanoid then
                    myHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                end
            end
            originalPosition = nil
        end
        print("Movimento parado. Personagem voltou à posição original.")
    end,
})

-- Lógica de matar e puxar
local followConnection
if followConnection then followConnection:Disconnect() end
followConnection = RunService.Heartbeat:Connect(function()
    if (isFollowingKill or isFollowingPull) and selectedPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and selectedPlayer.Character and selectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local success, errorMessage = pcall(function()
            local targetPosition = selectedPlayer.Character.HumanoidRootPart.Position
            LocalPlayer.Character:SetPrimaryPartCFrame(
                CFrame.new(targetPosition) * CFrame.Angles(
                    math.rad(Workspace.DistributedGameTime * 12000),
                    math.rad(Workspace.DistributedGameTime * 15000),
                    math.rad(Workspace.DistributedGameTime * 18000)
                )
            )
        end)
        if not success then
            warn("Erro no loop de matar/puxar: " .. tostring(errorMessage))
            isFollowingKill = false
            isFollowingPull = false
        end
    end
end)

local sitCheckConnection
if sitCheckConnection then sitCheckConnection:Disconnect() end
sitCheckConnection = RunService.Heartbeat:Connect(function()
    if (isFollowingKill or isFollowingPull) and selectedPlayer and selectedPlayer.Character and selectedPlayer.Character:FindFirstChild("Humanoid") then
        local success, errorMessage = pcall(function()
            if selectedPlayer.Character.Humanoid.Sit then
                print("Jogador sentado! Interrompendo ação...")
                
                if isFollowingKill then
                    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        LocalPlayer.Character:SetPrimaryPartCFrame(CFrame.new(0, -500, 0))
                        task.wait(0.5)
                        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Too1l"):InvokeServer("PickingTools", "Couch")
                        task.wait(1)
                    end
                end
                
                isFollowingKill = false
                isFollowingPull = false
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and originalPosition then
                    local myHRP = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    local myHumanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
                    if myHRP then
                        myHRP.Anchored = true
                        myHRP.CFrame = CFrame.new(originalPosition + Vector3.new(0, 5, 0))
                        task.wait(0.2)
                        myHRP.Velocity = Vector3.zero
                        myHRP.RotVelocity = Vector3.zero
                        myHRP.Anchored = false
                        if myHumanoid then
                            myHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                        end
                    end
                    print("Personagem voltou à posição original em pé!")
                end
                originalPosition = nil
            end
        end)
        if not success then
            warn("Erro na verificação de assento: " .. tostring(errorMessage))
            isFollowingKill = false
            isFollowingPull = false
        end
    end
end)



-----------------------------------------------------------------------------------------------------


-- BOTÃO INICIAR FLING
Tab1:Button({
    Title = "Iniciar Fling",
    Desc = "Inicia o fling no jogador selecionado",
    Callback = function()
        if running then
            print("O fling já está ativo. Use o botão 'Parar Fling' primeiro.")
            return
        end
        if not selectedPlayer or not selectedPlayer.Character then
            warn("Selecione um jogador válido antes de iniciar o fling!")
            return
        end

        local backpack = LocalPlayer:WaitForChild("Backpack")
        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if not humanoid or not hrp then
            warn("Seu personagem ainda não está totalmente carregado.")
            return
        end

        savedPosition = hrp.Position

        -- Buscar bola
        local ballTool = backpack:FindFirstChild("SoccerBall") or character:FindFirstChild("SoccerBall")

        -- Se não tiver a bola, pegar
        if not ballTool then
            local success, err = pcall(function()
                ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Too1l"):InvokeServer("PickingTools", "SoccerBall")
            end)
            if not success then
                warn("Erro ao pegar a bola: " .. tostring(err))
                return
            end
        end

        -- Espera um pouco e busca a bola novamente
        task.wait(0.2)
        ballTool = backpack:FindFirstChild("SoccerBall") or character:FindFirstChild("SoccerBall")
        if not ballTool then
            warn("Bola não apareceu.")
            return
        end

        -- Reequipar a bola
        pcall(function()
            humanoid:UnequipTools()
            task.wait(0.1)
            humanoid:EquipTool(ballTool)
        end)

        -- Esperar 0.5s antes de iniciar o fling
        task.wait(0.5)

        -- Ativa o noclip
        running = true
        connection = RunService.Stepped:Connect(function()
            if not running then return end
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") and part.CanCollide then
                    part.CanCollide = false
                end
            end
        end)

        -- Fling loop
        task.spawn(function()
            local target = selectedPlayer
            local ball = character:FindFirstChild("SoccerBall")
            local myHRP = character:FindFirstChild("HumanoidRootPart")
            if not ball or not myHRP or not target then return end

            while running and target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") do
                local targetHRP = target.Character:FindFirstChild("HumanoidRootPart")
                if not targetHRP then break end

                ball.Handle.CFrame = targetHRP.CFrame * CFrame.new(0, 0, -1)
                ball.Handle.Velocity = Vector3.new(10000, 10000, 10000)

                task.wait(0.03)
            end
        end)
    end
})

-- BOTÃO PARAR FLING
Tab1:Button({
    Title = "Parar Fling",
    Desc = "Interrompe o fling e reseta seu personagem",
    Callback = function()
        running = false

        if connection then
            connection:Disconnect()
            connection = nil
        end

        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end

        local myHRP = character:FindFirstChild("HumanoidRootPart")
        if myHRP and savedPosition then
            myHRP.Anchored = true
            myHRP.CFrame = CFrame.new(savedPosition + Vector3.new(0, 5, 0))
            task.wait(0.3)
            myHRP.Anchored = false
        end
    end
})
