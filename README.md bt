-- Carregar a biblioteca WindUI com tratamento de erro e depuração
print("Tentando carregar a biblioteca WindUI...")
local success, WindUI = pcall(function()
    return loadstring(game:HttpGet("https://tree-hub.vercel.app/api/UI/WindUI"))()
end)

if not success or not WindUI then
    warn("Erro ao carregar a biblioteca WindUI: " .. tostring(WindUI))
else
    print("Biblioteca WindUI carregada com sucesso!")
end

local Version = "1.4.0"

-- Criação da janela principal
print("Criando a janela principal...")
local Window = WindUI:CreateWindow({
    Title = "Lolyta troll 67777777",
    Icon = "door-open",
    Author = "Lolycon666",
    Folder = "Lolyta 666",
    Size = UDim2.fromOffset(580, 460),
    KeySystem = {
        Key = "666",
        Note = "pode nao man",
        URL = "",
        SaveKey = true,
    },
    Transparent = true,
    Theme = "Dark",
    SideBarWidth = 200,
    HasOutline = false,
})
print("Janela principal criada com sucesso!")

-- Editar o botão de abertura
print("Editando o botão de abertura...")
Window:EditOpenButton({
    Title = "Lolyta troll",
    Icon = "align-justify",
    CornerRadius = UDim.new(0, 10),
    StrokeThickness = 3,
    Color = ColorSequence.new(Color3.fromHex("FF0F7B"), Color3.fromHex("F89B29"))
})
print("Botão de abertura editado com sucesso!")

-- === Abas da Interface === --
print("Criando a aba 'troll'...")
local Tab1 = Window:Tab({ Title = "troll", Icon = "Ball" })
print("Aba 'troll' criada com sucesso!")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

-- Variáveis compartilhadas
local selectedPlayer = nil
local isFollowingKill = false
local isFollowingPull = false
local running = false
local connection = nil
local flingConnection = nil
local originalPosition = nil
local savedPosition = nil
local originalProperties = {}
local selectedKillPullMethod = nil
local selectedFlingMethod = nil
local soccerBall = nil
local couch = nil
local isSpectating = false
local spectatedPlayer = nil
local characterConnection = nil
local flingToggle = nil -- Para armazenar a referência do toggle

-- Cria um RemoteEvent para comunicação com o servidor
local SetNetworkOwnerEvent = Instance.new("RemoteEvent")
SetNetworkOwnerEvent.Name = "SetNetworkOwnerEvent_" .. tostring(math.random(1000, 9999))
SetNetworkOwnerEvent.Parent = ReplicatedStorage

-- Cria um script no servidor para lidar com o RemoteEvent
local serverScriptCode = [[
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local event = ReplicatedStorage:WaitForChild("]] .. SetNetworkOwnerEvent.Name .. [[")
    
    event.OnServerEvent:Connect(function(player, part, networkOwner)
        if part and part:IsA("BasePart") then
            pcall(function()
                part:SetNetworkOwner(networkOwner)
                part.Anchored = false
                part.CanCollide = true
                part.CanTouch = true
            end)
        end
    end)
]]

local success, errorMessage = pcall(function()
    loadstring(serverScriptCode)()
end)
if not success then
    warn("Erro ao criar script no servidor: " .. tostring(errorMessage))
end

-- Função para desativar temporariamente o CarClient
local function disableCarClient()
    local backpack = LocalPlayer:WaitForChild("Backpack")
    local carClient = backpack:FindFirstChild("CarClient")
    if carClient and carClient:IsA("LocalScript") then
        carClient.Disabled = true
        print("CarClient desativado com sucesso!")
    end
end

-- Função para reativar o CarClient
local function enableCarClient()
    local backpack = LocalPlayer:WaitForChild("Backpack")
    local carClient = backpack:FindFirstChild("CarClient")
    if carClient and carClient:IsA("LocalScript") then
        carClient.Disabled = false
        print("CarClient reativado com sucesso!")
    end
end

-- Função para obter os nomes dos jogadores, excluindo o jogador local
local function getPlayerNames()
    local playerNames = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playerNames, player.Name)
        end
    end
    return playerNames
end

-- Função para atualizar o dropdown
local function updateDropdown(dropdown)
    local success, errorMessage = pcall(function()
        local playerNames = getPlayerNames()
        dropdown:Refresh(playerNames)
        if selectedPlayer and not table.find(playerNames, selectedPlayer.Name) then
            dropdown:SetValue("")
            selectedPlayer = nil
            if isSpectating then
                stopSpectating()
            end
        end
    end)
    if not success then
        warn("Erro ao atualizar dropdown: " .. tostring(errorMessage))
    end
end

-- Função para visualizar um jogador
local function spectatePlayer(playerName)
    if characterConnection then
        characterConnection:Disconnect()
        characterConnection = nil
    end

    local targetPlayer = Players:FindFirstChild(playerName)
    if targetPlayer and targetPlayer ~= LocalPlayer then
        spectatedPlayer = targetPlayer
        isSpectating = true

        local function updateCamera()
            if not isSpectating or not spectatedPlayer then
                return
            end
            if spectatedPlayer.Character and spectatedPlayer.Character:FindFirstChild("Humanoid") then
                Workspace.CurrentCamera.CameraSubject = spectatedPlayer.Character.Humanoid
            else
                Workspace.CurrentCamera.CameraSubject = nil
            end
        end

        updateCamera()

        characterConnection = RunService.Heartbeat:Connect(function()
            if not isSpectating then
                characterConnection:Disconnect()
                characterConnection = nil
                return
            end
            local success, errorMessage = pcall(updateCamera)
            if not success then
                warn("Erro ao atualizar câmera no modo visualização: " .. tostring(errorMessage))
                stopSpectating()
            end
        end)

        spectatedPlayer.CharacterAdded:Connect(function()
            if isSpectating then
                updateCamera()
            end
        end)
    else
        isSpectating = false
        spectatedPlayer = nil
    end
end

-- Função para parar de visualizar
local function stopSpectating()
    if characterConnection then
        characterConnection:Disconnect()
        characterConnection = nil
    end

    isSpectating = false
    spectatedPlayer = nil

    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        Workspace.CurrentCamera.CameraSubject = LocalPlayer.Character.Humanoid
        Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
    else
        Workspace.CurrentCamera.CameraSubject = nil
        Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
    end
end

-- Detecta quando o jogador local morre e reseta a câmera
LocalPlayer.CharacterAdded:Connect(function(character)
    if isSpectating then
        stopSpectating()
    end
end)

-- Dropdown para selecionar jogador
print("Criando o dropdown para selecionar jogador...")
local DropdownPlayer = Tab1:Dropdown({
    Title = "Selecionar Jogador",
    Desc = "Escolha um jogador para matar, puxar, visualizar ou aplicar fling",
    Value = "",
    Multi = false,
    AllowNone = true,
    Values = getPlayerNames(),
    Callback = function(selectedPlayerName)
        if selectedPlayerName == "" or selectedPlayerName == nil then
            selectedPlayer = nil
            if running or isFollowingKill or isFollowingPull then
                running = false
                isFollowingKill = false
                isFollowingPull = false
                if connection then connection:Disconnect() end
                if flingConnection then flingConnection:Disconnect() end
                if flingToggle then flingToggle:SetValue(false) end
            end
            if isSpectating then
                stopSpectating()
            end
        else
            selectedPlayer = Players:FindFirstChild(selectedPlayerName)
            if isSpectating then
                stopSpectating()
                spectatePlayer(selectedPlayerName)
            end
        end
    end
})
print("Dropdown para selecionar jogador criado com sucesso!")

-- Botão para atualizar a lista de jogadores
print("Criando o botão para atualizar a lista de jogadores...")
Tab1:Button({
    Title = "Atualizar Lista de Jogadores",
    Desc = "Atualiza a lista de jogadores no dropdown",
    Callback = function()
        updateDropdown(DropdownPlayer)
    end
})
print("Botão para atualizar a lista de jogadores criado com sucesso!")

-- Toggle para visualizar jogador
print("Criando o toggle para visualizar jogador...")
local SpectateToggle = Tab1:Toggle({
    Title = "Visualizar Jogador",
    Desc = "Ativa/desativa a visualização do jogador selecionado",
    Default = false,
    Callback = function(state)
        if state then
            if selectedPlayer then
                local success, errorMessage = pcall(spectatePlayer, selectedPlayer.Name)
                if not success then
                    warn("Erro ao ativar modo visualização: " .. tostring(errorMessage))
                    SpectateToggle:SetValue(false)
                end
            else
                warn("Selecione um jogador antes de ativar a visualização.")
                SpectateToggle:SetValue(false)
            end
        else
            local success, errorMessage = pcall(stopSpectating)
            if not success then
                warn("Erro ao desativar modo visualização: " .. tostring(errorMessage))
            end
        end
    end
})
print("Toggle para visualizar jogador criado com sucesso!")

-- Remove jogadores que saem do servidor
Players.PlayerRemoving:Connect(function(player)
    if selectedPlayer == player then
        selectedPlayer = nil
        if isSpectating then
            stopSpectating()
        end
        if running then
            running = false
            if connection then connection:Disconnect() connection = nil end
            if flingConnection then flingConnection:Disconnect() flingConnection = nil end
            if flingToggle then flingToggle:SetValue(false) end
        end
    end
    updateDropdown(DropdownPlayer)
end)

-- Inicializa o dropdown
updateDropdown(DropdownPlayer)

-- Dropdown para selecionar método de matar/puxar
print("Criando o dropdown para selecionar método de matar/puxar...")
local DropdownKillPullMethod = Tab1:Dropdown({
    Title = "Selecionar Método (Matar/Puxar)",
    Desc = "Escolha o método para matar ou puxar",
    Values = {"Sofá", "Ônibus"},
    Callback = function(value)
        selectedKillPullMethod = value
    end
})
print("Dropdown para selecionar método de matar/puxar criado com sucesso!")

-- Função para equipar o sofá
local function equipSofa()
    local backpack = LocalPlayer:WaitForChild("Backpack")
    local sofa = backpack:FindFirstChild("Couch") or LocalPlayer.Character:FindFirstChild("Couch")
    if not sofa then
        local args = { [1] = "PickingTools", [2] = "Couch" }
        local success, err = pcall(function()
            ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Too1l"):InvokeServer(unpack(args))
        end)
        if not success then
            warn("Erro ao pegar o sofá: " .. tostring(err))
            return false
        end
        repeat
            sofa = backpack:FindFirstChild("Couch")
            task.wait()
        until sofa or task.wait(5)
        if not sofa then
            warn("Falha ao pegar o sofá!")
            return false
        end
    end
    if sofa.Parent ~= LocalPlayer.Character then
        sofa.Parent = LocalPlayer.Character
    end
    return true
end

-- Função para matar com sofá
local function killWithSofa(targetPlayer)
    if not targetPlayer or not targetPlayer.Character or not LocalPlayer.Character then
        warn("Selecione um jogador válido antes de iniciar!")
        return
    end
    if not equipSofa() then return end
    isFollowingKill = true
    originalPosition = LocalPlayer.Character:FindFirstChild("HumanoidRootPart").Position
end

-- Função para puxar com sofá
local function pullWithSofa(targetPlayer)
    if not targetPlayer or not targetPlayer.Character or not LocalPlayer.Character then
        warn("Selecione um jogador válido antes de iniciar!")
        return
    end
    if not equipSofa() then return end
    isFollowingPull = true
    originalPosition = LocalPlayer.Character:FindFirstChild("HumanoidRootPart").Position
end

-- Função para matar com ônibus
local function killWithBus(targetPlayer)
    if not targetPlayer or not targetPlayer.Character or not LocalPlayer.Character then return end
    local character = LocalPlayer.Character
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local myHRP = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not myHRP then return end
    savedPosition = myHRP.Position
    pcall(function()
        myHRP.Anchored = true
        myHRP.CFrame = CFrame.new(Vector3.new(1181.83, 76.08, -1158.83))
        task.wait(0.2)
        myHRP.Velocity = Vector3.zero
        myHRP.RotVelocity = Vector3.zero
        myHRP.Anchored = false
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
        end
    end)
    task.wait(0.5)
    
    -- Desativar CarClient antes de deletar veículos
    disableCarClient()
    
    local args = { [1] = "DeleteAllVehicles" }
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
    end)
    args = { [1] = "PickingCar", [2] = "SchoolBus" }
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
    end)
    task.wait(1)
    local vehiclesFolder = Workspace:FindFirstChild("Vehicles")
    if not vehiclesFolder then
        warn("Pasta Vehicles não encontrada no Workspace!")
        return
    end
    local busName = LocalPlayer.Name .. "Car"
    local bus = vehiclesFolder:FindFirstChild(busName)
    if not bus then
        warn("Ônibus não encontrado em Workspace.Vehicles com o nome: " .. busName)
        return
    end
    pcall(function()
        myHRP.Anchored = true
        myHRP.CFrame = CFrame.new(Vector3.new(1171.15, 79.45, -1166.2))
        task.wait(0.2)
        myHRP.Velocity = Vector3.zero
        myHRP.RotVelocity = Vector3.zero
        myHRP.Anchored = false
        humanoid:ChangeState(Enum.HumanoidStateType.Seated)
    end)
    local sitStart = tick()
    repeat
        task.wait()
        if tick() - sitStart > 10 then
            warn("Timeout: Jogador local não foi detectado como sentado!")
            return
        end
    until humanoid.Sit
    for _, part in ipairs(bus:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
            pcall(function() part:SetNetworkOwner(nil) end)
        end
    end
    running = true
    connection = RunService.Stepped:Connect(function()
        if not running then return end
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end)
    local lastUpdate = tick()
    local updateInterval = 0.05
    local startTime = tick()
    flingConnection = RunService.Heartbeat:Connect(function()
        if not running then return end
        local targetCharacter = targetPlayer.Character or targetPlayer.CharacterAdded:Wait()
        local newTargetHRP = targetCharacter:FindFirstChild("HumanoidRootPart")
        local newTargetHumanoid = targetCharacter:FindFirstChild("Humanoid")
        if not newTargetHRP or not newTargetHumanoid then return end
        if not myHRP or not humanoid then
            running = false
            return
        end
        if tick() - lastUpdate < updateInterval then return end
        lastUpdate = tick()
        local offset = Vector3.new(math.random(-10, 10), 0, math.random(-10, 10))
        pcall(function()
            local targetPosition = newTargetHRP.Position + offset
            bus:PivotTo(
                CFrame.new(targetPosition) * CFrame.Angles(
                    math.rad(Workspace.DistributedGameTime * 12000),
                    math.rad(Workspace.DistributedGameTime * 15000),
                    math.rad(Workspace.DistributedGameTime * 18000)
                )
            )
        end)
        local playerSeated = false
        for _, seat in ipairs(bus:GetDescendants()) do
            if (seat:IsA("Seat") or seat:IsA("VehicleSeat")) and seat.Name ~= "VehicleSeat" then
                if seat.Occupant == newTargetHumanoid then
                    playerSeated = true
                    break
                end
            end
        end
        if playerSeated or tick() - startTime > 10 then
            running = false
            if connection then connection:Disconnect() connection = nil end
            if flingConnection then flingConnection:Disconnect() flingConnection = nil end
            pcall(function()
                bus:PivotTo(CFrame.new(Vector3.new(-76.6, -401.97, -84.26)))
            end)
            task.wait(0.5)
            
            -- Desativar CarClient antes de deletar veículos
            disableCarClient()
            
            local args = { [1] = "DeleteAllVehicles" }
            pcall(function()
                ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
            end)
            if character then
                local myHRP = character:FindFirstChild("HumanoidRootPart")
                if myHRP then
                    if savedPosition then
                        pcall(function()
                            myHRP.Anchored = true
                            myHRP.CFrame = CFrame.new(savedPosition + Vector3.new(0, 5, 0))
                            task.wait(0.2)
                            myHRP.Velocity = Vector3.zero
                            myHRP.RotVelocity = Vector3.zero
                            myHRP.Anchored = false
                            if humanoid then
                                humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                            end
                        end)
                    else
                        warn("savedPosition não está definida para teleporte de volta!")
                    end
                end
            end
            if character then
                for _, part in ipairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                        part.Velocity = Vector3.zero
                        part.RotVelocity = Vector3.zero
                    end
                end
            end
            local myHumanoid = character and character:FindFirstChild("Humanoid")
            if myHumanoid then
                myHumanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
            end
            for _, seat in ipairs(Workspace:GetDescendants()) do
                if seat:IsA("Seat") or seat:IsA("VehicleSeat") then
                    seat.Disabled = false
                end
            end
            pcall(function()
                ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Clothe1s"):FireServer("CharacterSizeUp", 1)
            end)
        end
    end)
end

-- Lógica de matar e puxar
local followConnection
if followConnection then followConnection:Disconnect() end
followConnection = RunService.Heartbeat:Connect(function()
    if (isFollowingKill or isFollowingPull) and selectedPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and selectedPlayer.Character and selectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local success, errorMessage = pcall(function()
            local targetPosition = selectedPlayer.Character.HumanoidRootPart.Position
            LocalPlayer.Character:SetPrimaryPartCFrame(
                CFrame.new(targetPosition) * CFrame.Angles(
                    math.rad(Workspace.DistributedGameTime * 12000),
                    math.rad(Workspace.DistributedGameTime * 15000),
                    math.rad(Workspace.DistributedGameTime * 18000)
                )
            )
        end)
        if not success then
            warn("Erro no loop de matar/puxar: " .. tostring(errorMessage))
            isFollowingKill = false
            isFollowingPull = false
        end
    end
end)

local sitCheckConnection
if sitCheckConnection then sitCheckConnection:Disconnect() end
sitCheckConnection = RunService.Heartbeat:Connect(function()
    if (isFollowingKill or isFollowingPull) and selectedPlayer and selectedPlayer.Character and selectedPlayer.Character:FindFirstChild("Humanoid") then
        local success, errorMessage = pcall(function()
            if selectedPlayer.Character.Humanoid.Sit then
                if isFollowingKill then
                    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        LocalPlayer.Character:SetPrimaryPartCFrame(CFrame.new(0, -500, 0))
                        task.wait(0.5)
                        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Too1l"):InvokeServer("PickingTools", "Couch")
                        task.wait(1)
                    end
                end
                isFollowingKill = false
                isFollowingPull = false
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and originalPosition then
                    local myHRP = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    local myHumanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
                    if myHRP then
                        myHRP.Anchored = true
                        myHRP.CFrame = CFrame.new(originalPosition + Vector3.new(0, 5, 0))
                        task.wait(0.2)
                        myHRP.Velocity = Vector3.zero
                        myHRP.RotVelocity = Vector3.zero
                        myHRP.Anchored = false
                        if myHumanoid then
                            myHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                        end
                    end
                    originalPosition = nil
                end
            end
        end)
        if not success then
            warn("Erro na verificação de assento: " .. tostring(errorMessage))
            isFollowingKill = false
            isFollowingPull = false
        end
    end
end)

-- Botão para iniciar matar
print("Criando o botão para iniciar matar...")
Tab1:Button({
    Title = "Matar",
    Desc = "Inicia o matar com o método selecionado",
    Callback = function()
        if isFollowingKill or isFollowingPull or running then
            warn("Uma ação já está ativa. Use o botão Parar primeiro.")
            return
        end
        if not selectedPlayer then
            warn("Nenhum jogador selecionado!")
            return
        end
        if not selectedKillPullMethod then
            warn("Nenhum método de matar/puxar selecionado!")
            return
        end
        if selectedKillPullMethod == "Sofá" then
            killWithSofa(selectedPlayer)
        elseif selectedKillPullMethod == "Ônibus" then
            killWithBus(selectedPlayer)
        end
    end
})
print("Botão para iniciar matar criado com sucesso!")

-- Botão para iniciar puxar
print("Criando o botão para iniciar puxar...")
Tab1:Button({
    Title = "Puxar",
    Desc = "Inicia o puxar com o método selecionado",
    Callback = function()
        if isFollowingKill or isFollowingPull or running then
            warn("Uma ação já está ativa. Use o botão Parar primeiro.")
            return
        end
        if not selectedPlayer then
            warn("Nenhum jogador selecionado!")
            return
        end
        if not selectedKillPullMethod then
            warn("Nenhum método de matar/puxar selecionado!")
            return
        end
        if selectedKillPullMethod == "Sofá" then
            pullWithSofa(selectedPlayer)
        else
            warn("Puxar só funciona com Sofá!")
        end
    end
})
print("Botão para iniciar puxar criado com sucesso!")

-- Botão para parar matar ou puxar
print("Criando o botão para parar matar ou puxar...")
Tab1:Button({
    Title = "Parar (Matar ou Puxar)",
    Desc = "Para o movimento de matar ou puxar",
    Callback = function()
        isFollowingKill = false
        isFollowingPull = false
        for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
                part.Velocity = Vector3.zero
                part.RotVelocity = Vector3.zero
            end
        end
        local myHumanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
        if myHumanoid then
            myHumanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        end
        for _, seat in ipairs(Workspace:GetDescendants()) do
            if seat:IsA("Seat") or seat:IsA("VehicleSeat") then
                seat.Disabled = false
            end
        end
        if originalPosition then
            local myHRP = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if myHRP then
                myHRP.Anchored = true
                myHRP.CFrame = CFrame.new(originalPosition + Vector3.new(0, 5, 0))
                task.wait(0.2)
                myHRP.Velocity = Vector3.zero
                myHRP.RotVelocity = Vector3.zero
                myHRP.Anchored = false
                if myHumanoid then
                    myHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                end
            end
            originalPosition = nil
        end
        
        -- Desativar CarClient antes de deletar veículos
        disableCarClient()
        
        local args = { [1] = "DeleteAllVehicles" }
        pcall(function()
            ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
        end)
    end
})
print("Botão para parar matar ou puxar criado com sucesso!")

-- Dropdown para selecionar método de fling
print("Criando o dropdown para selecionar método de fling...")
local DropdownFlingMethod = Tab1:Dropdown({
    Title = "Selecionar Método de Fling",
    Desc = "Escolha o método para aplicar fling",
    Values = {"Sofá", "Ônibus", "Bola", "Barco"},
    Callback = function(value)
        selectedFlingMethod = value
    end
})
print("Dropdown para selecionar método de fling criado com sucesso!")

-- Função para equipar a bola
local function equipBola()
    local backpack = LocalPlayer:WaitForChild("Backpack")
    local bola = backpack:FindFirstChild("SoccerBall") or LocalPlayer.Character:FindFirstChild("SoccerBall")
    if not bola then
        local args = { [1] = "PickingTools", [2] = "SoccerBall" }
        local success, err = pcall(function()
            ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Too1l"):InvokeServer(unpack(args))
        end)
        if not success then
            warn("Erro ao pegar a bola: " .. tostring(err))
            return false
        end
        repeat
            bola = backpack:FindFirstChild("SoccerBall")
            task.wait()
        until bola or task.wait(5)
        if not bola then
            warn("Falha ao pegar a bola!")
            return false
        end
    end
    if bola.Parent ~= LocalPlayer.Character then
        bola.Parent = LocalPlayer.Character
    end
    return true
end

-- Função para fling com bola (com potência aumentada absurdamente)
local function flingWithBall(targetPlayer)
    if not targetPlayer or not targetPlayer.Character then
        warn("Selecione um jogador válido antes de iniciar o fling!")
        return
    end
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local myHRP = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not myHRP then
        warn("Seu personagem ainda não está totalmente carregado.")
        return
    end
    if not equipBola() then return end
    task.wait(0.5)
    local args = { [1] = "PlayerWantsToDeleteTool", [2] = "SoccerBall" }
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Clea1rTool1s"):FireServer(unpack(args))
    end)
    local workspaceCom = Workspace:FindFirstChild("WorkspaceCom")
    if not workspaceCom then
        warn("WorkspaceCom não encontrado!")
        return
    end
    local soccerBalls = workspaceCom:FindFirstChild("001_SoccerBalls")
    if not soccerBalls then
        warn("001_SoccerBalls não encontrado!")
        return
    end
    soccerBall = soccerBalls:FindFirstChild("Soccer" .. LocalPlayer.Name)
    if not soccerBall then
        warn("Bola de futebol não encontrada em Workspace.WorkspaceCom.001_SoccerBalls.Soccer" .. LocalPlayer.Name)
        return
    end
    originalProperties = {
        Anchored = soccerBall.Anchored,
        CanCollide = soccerBall.CanCollide,
        CanTouch = soccerBall.CanTouch
    }
    soccerBall.Anchored = false
    soccerBall.CanCollide = true
    soccerBall.CanTouch = true
    pcall(function() soccerBall:SetNetworkOwner(nil) end)
    savedPosition = myHRP.Position
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end
    if humanoid then
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
        humanoid.Sit = false
    end
    for _, seat in ipairs(Workspace:GetDescendants()) do
        if seat:IsA("Seat") or seat:IsA("VehicleSeat") then
            seat.Disabled = true
        end
    end
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Clothe1s"):FireServer("CharacterSizeDown", 4)
    end)
    running = true
    local lastFlingTime = 0
    connection = RunService.Heartbeat:Connect(function()
        if not running or not targetPlayer.Character then return end
        local hrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        local hum = targetPlayer.Character:FindFirstChild("Humanoid")
        local myHRP = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp or not hum or not myHRP then return end
        local moveDir = hum.MoveDirection
        local isStill = moveDir.Magnitude < 0.1
        local isSitting = hum.Sit
        if isSitting then
            local y = math.sin(tick() * 50) * 2
            soccerBall.CFrame = CFrame.new(hrp.Position + Vector3.new(0, 0.75 + y, 0))
        elseif isStill then
            local z = math.sin(tick() * 50) * 3
            soccerBall.CFrame = CFrame.new(hrp.Position + Vector3.new(0, 0.75, z))
        else
            local offset = moveDir.Unit * math.clamp(hrp.Velocity.Magnitude * 0.15, 5, 12)
            soccerBall.CFrame = CFrame.new(hrp.Position + offset + Vector3.new(0, 0.75, 0))
        end
        myHRP.CFrame = CFrame.new(soccerBall.Position + Vector3.new(0, 1, 0))
    end)
    flingConnection = RunService.Heartbeat:Connect(function()
        if not running or not targetPlayer.Character then return end
        local hrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        local dist = (soccerBall.Position - hrp.Position).Magnitude
        if dist < 4 and tick() - lastFlingTime > 0.4 then
            lastFlingTime = tick()
            for _, part in ipairs(targetPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
            local fling = Instance.new("BodyVelocity")
            fling.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            fling.Velocity = Vector3.new(math.random(-5, 5), 5, math.random(-5, 5)).Unit * 500000 + Vector3.new(0, 250000, 0)
            fling.Parent = hrp
            task.delay(0.3, function()
                fling:Destroy()
                for _, part in ipairs(targetPlayer.Character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                    end
                end
            end)
        end
    end)
end

-- Função para fling com sofá
local function flingWithSofa(targetPlayer)
    if not targetPlayer or not targetPlayer.Character or not LocalPlayer.Character then
        warn("Selecione um jogador válido antes de iniciar!")
        return
    end
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local myHRP = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not myHRP then
        warn("Seu personagem ainda não está totalmente carregado.")
        return
    end
    savedPosition = myHRP.Position
    if not equipSofa() then return end
    task.wait(0.5)
    couch = character:FindFirstChild("Couch")
    if not couch then
        for _, obj in ipairs(Workspace:GetDescendants()) do
            if (obj.Name == "Couch" or obj.Name == "Couch" .. LocalPlayer.Name) and (obj:IsA("BasePart") or obj:IsA("Tool")) then
                couch = obj
                break
            end
        end
    end
    if not couch then
        warn("Sofá não encontrado no personagem ou no Workspace!")
        return
    end
    if couch:IsA("BasePart") then
        originalProperties = {
            Anchored = couch.Anchored,
            CanCollide = couch.CanCollide,
            CanTouch = couch.CanTouch
        }
        couch.Anchored = false
        couch.CanCollide = true
        couch.CanTouch = true
        pcall(function() couch:SetNetworkOwner(nil) end)
    end
    running = true
    connection = RunService.Stepped:Connect(function()
        if not running then return end
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end)
    local startTime = tick()
    local walkFlingInstance = nil
    flingConnection = RunService.Heartbeat:Connect(function()
        if not running then return end
        if not targetPlayer or not targetPlayer.Character then
            running = false
            return
        end
        local newTargetHRP = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        local newTargetHumanoid = targetPlayer.Character:FindFirstChild("Humanoid")
        if not newTargetHRP or not newTargetHumanoid then
            running = false
            return
        end
        if not myHRP or not humanoid then
            running = false
            return
        end
        pcall(function()
            local targetPosition = newTargetHRP.Position
            character:SetPrimaryPartCFrame(
                CFrame.new(targetPosition) * CFrame.Angles(
                    math.rad(Workspace.DistributedGameTime * 12000),
                    math.rad(Workspace.DistributedGameTime * 15000),
                    math.rad(Workspace.DistributedGameTime * 18000)
                )
            )
        end)
        if newTargetHumanoid.Sit or tick() - startTime > 10 then
            running = false
            flingConnection:Disconnect()
            flingConnection = nil
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                    pcall(function() part:SetNetworkOwner(nil) end)
                end
            end
            walkFlingInstance = Instance.new("BodyVelocity")
            walkFlingInstance.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            walkFlingInstance.Velocity = Vector3.new(math.random(-5, 5), 5, math.random(-5, 5)).Unit * 1000000 + Vector3.new(0, 1000000, 0)
            walkFlingInstance.Parent = myHRP
            pcall(function()
                myHRP.Anchored = true
                myHRP.CFrame = CFrame.new(Vector3.new(-59599.73, 2040070.50, -293391.16))
                myHRP.Anchored = false
            end)
            local spinStart = tick()
            local spinConnection
            spinConnection = RunService.Heartbeat:Connect(function()
                if tick() - spinStart >= 0.5 then
                    spinConnection:Disconnect()
                    return
                end
                pcall(function()
                    character:SetPrimaryPartCFrame(
                        myHRP.CFrame * CFrame.Angles(
                            math.rad(Workspace.DistributedGameTime * 12000),
                            math.rad(Workspace.DistributedGameTime * 15000),
                            math.rad(Workspace.DistributedGameTime * 18000)
                        )
                    )
                end)
            end)
            task.wait(0.5)
            local args = { [1] = "PlayerWantsToDeleteTool", [2] = "Couch" }
            pcall(function()
                ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Clea1rTool1s"):FireServer(unpack(args))
            end)
            pcall(function()
                myHRP.Anchored = true
                myHRP.CFrame = CFrame.new(savedPosition + Vector3.new(0, 5, 0))
                task.wait(0.2)
                myHRP.Velocity = Vector3.zero
                myHRP.RotVelocity = Vector3.zero
                myHRP.Anchored = false
                if humanoid then
                    humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                end
            end)
            if walkFlingInstance then
                walkFlingInstance:Destroy()
                for _, part in ipairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                    end
                end
            end
            -- Desativar o toggle automaticamente
            if flingToggle then
                flingToggle:SetValue(false)
            end
        end
    end)
end

-- Função para fling com ônibus
local function flingWithBus(targetPlayer)
    if not targetPlayer or not targetPlayer.Character or not LocalPlayer.Character then
        warn("Selecione um jogador válido antes de iniciar!")
        return
    end
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local myHRP = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not myHRP then
        warn("Seu personagem ainda não está totalmente carregado.")
        return
    end
    savedPosition = myHRP.Position
    pcall(function()
        myHRP.Anchored = true
        myHRP.CFrame = CFrame.new(Vector3.new(1181.83, 76.08, -1158.83))
        task.wait(0.2)
        myHRP.Velocity = Vector3.zero
        myHRP.RotVelocity = Vector3.zero
        myHRP.Anchored = false
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
        end
    end)
    task.wait(0.5)
    
    -- Desativar CarClient antes de deletar veículos
    disableCarClient()
    
    local args = { [1] = "DeleteAllVehicles" }
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
    end)
    args = { [1] = "PickingCar", [2] = "SchoolBus" }
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
    end)
    task.wait(1)
    local vehiclesFolder = Workspace:FindFirstChild("Vehicles")
    if not vehiclesFolder then
        warn("Pasta Vehicles não encontrada no Workspace!")
        return
    end
    local busName = LocalPlayer.Name .. "Car"
    local bus = vehiclesFolder:FindFirstChild(busName)
    if not bus then
        warn("Ônibus não encontrado em Workspace.Vehicles com o nome: " .. busName)
        return
    end
    pcall(function()
        myHRP.Anchored = true
        myHRP.CFrame = CFrame.new(Vector3.new(1171.15, 79.45, -1166.2))
        task.wait(0.2)
        myHRP.Velocity = Vector3.zero
        myHRP.RotVelocity = Vector3.zero
        myHRP.Anchored = false
        humanoid:ChangeState(Enum.HumanoidStateType.Seated)
    end)
    local sitStart = tick()
    repeat
        task.wait()
        if tick() - sitStart > 10 then
            warn("Timeout: Jogador local não foi detectado como sentado!")
            return
        end
    until humanoid.Sit
    for _, part in ipairs(bus:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
            pcall(function() part:SetNetworkOwner(nil) end)
        end
    end
    running = true
    connection = RunService.Stepped:Connect(function()
        if not running then return end
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end)
    local startTime = tick()
    local walkFlingInstancePlayer = nil
    flingConnection = RunService.Heartbeat:Connect(function()
        if not running then return end
        if not targetPlayer or not targetPlayer.Character then
            running = false
            return
        end
        local newTargetHRP = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        local newTargetHumanoid = targetPlayer.Character:FindFirstChild("Humanoid")
        if not newTargetHRP or not newTargetHumanoid then
            running = false
            return
        end
        if not myHRP or not humanoid then
            running = false
            return
        end
        local offset = Vector3.new(math.random(-10, 10), 0, math.random(-10, 10))
        pcall(function()
            local targetPosition = newTargetHRP.Position + offset
            bus:PivotTo(
                CFrame.new(targetPosition) * CFrame.Angles(
                    math.rad(Workspace.DistributedGameTime * 12000),
                    math.rad(Workspace.DistributedGameTime * 15000),
                    math.rad(Workspace.DistributedGameTime * 18000)
                )
            )
        end)
        local playerSeated = false
        for _, seat in ipairs(bus:GetDescendants()) do
            if (seat:IsA("Seat") or seat:IsA("VehicleSeat")) and seat.Name ~= "VehicleSeat" then
                if seat.Occupant == newTargetHumanoid then
                    playerSeated = true
                    break
                end
            end
        end
        if playerSeated or tick() - startTime > 10 then
            running = false
            flingConnection:Disconnect()
            flingConnection = nil
            pcall(function()
                bus:PivotTo(CFrame.new(Vector3.new(-59599.73, 2040070.50, -293391.16)))
            end)
            
            walkFlingInstancePlayer = Instance.new("BodyVelocity")
            walkFlingInstancePlayer.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            walkFlingInstancePlayer.Velocity = Vector3.new(math.random(-5, 5), 5, math.random(-5, 5)).Unit * 1000000 + Vector3.new(0, 1000000, 0)
            walkFlingInstancePlayer.Parent = myHRP
            task.wait(0.5)
            
            -- Desativar CarClient antes de deletar veículos
            disableCarClient()
            
            local args = { [1] = "DeleteAllVehicles" }
            pcall(function()
                ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
            end)
            if walkFlingInstancePlayer then
                walkFlingInstancePlayer:Destroy()
                for _, part in ipairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                    end
                end
            end
            pcall(function()
                myHRP.Anchored = true
                myHRP.CFrame = CFrame.new(savedPosition + Vector3.new(0, 5, 0))
                task.wait(0.2)
                myHRP.Velocity = Vector3.zero
                myHRP.RotVelocity = Vector3.zero
                myHRP.Anchored = false
                if humanoid then
                    humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                end
            end)
            -- Desativar o toggle automaticamente
            if flingToggle then
                flingToggle:SetValue(false)
            end
        end
    end)
end

-- Função para fling com barco (sem limite de tempo)
local function flingWithBoat(targetPlayer)
    if not targetPlayer or not targetPlayer.Character or not LocalPlayer.Character then return end
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local myHRP = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not myHRP then return end
    savedPosition = myHRP.Position
    pcall(function()
        myHRP.Anchored = true
        myHRP.CFrame = CFrame.new(Vector3.new(-3359.52, -5.05, -501.94))
        task.wait(0.2)
        myHRP.Velocity = Vector3.zero
        myHRP.RotVelocity = Vector3.zero
        myHRP.Anchored = false
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
        end
    end)
    
    -- Desativar CarClient antes de deletar veículos
    disableCarClient()
    
    local args = { [1] = "DeleteAllVehicles" }
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
    end)
    task.wait(0.4)
    args = { [1] = "PickingBoat", [2] = "MilitaryBoatFree" }
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
    end)
    task.wait(1.5)
    local vehiclesFolder = Workspace:FindFirstChild("Vehicles")
    if not vehiclesFolder then
        warn("Pasta Vehicles não encontrada no Workspace!")
        return
    end
    local boatName = LocalPlayer.Name .. "Car"
    local boat = vehiclesFolder:FindFirstChild(boatName)
    if not boat then
        warn("Barco não encontrado em Workspace.Vehicles com o nome: " .. boatName)
        return
    end
    pcall(function()
        myHRP.Anchored = true
        myHRP.CFrame = CFrame.new(Vector3.new(-3358.85, 5.25, -521.95))
        task.wait(0.2)
        myHRP.Velocity = Vector3.zero
        myHRP.RotVelocity = Vector3.zero
        myHRP.Anchored = false
        humanoid:ChangeState(Enum.HumanoidStateType.Seated)
    end)
    local sitStart = tick()
    repeat
        task.wait()
        if tick() - sitStart > 10 then
            warn("Timeout: Jogador local não foi detectado como sentado!")
            return
        end
    until humanoid.Sit
    for _, part in ipairs(boat:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = true
            pcall(function() part:SetNetworkOwner(nil) end)
        end
    end
    running = true
    connection = RunService.Stepped:Connect(function()
        if not running then return end
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end)
    local touchedConnections = {}
    local mainPart = boat:FindFirstChild("Body")
    if mainPart and mainPart:IsA("BasePart") then
        local conn = mainPart.Touched:Connect(function(hit)
            if not running then return end
            local hitPlayer = Players:GetPlayerFromCharacter(hit.Parent)
            if hitPlayer and hitPlayer == targetPlayer then
                local targetHRP = hit.Parent:FindFirstChild("HumanoidRootPart")
                if targetHRP then
                    local flingForce = Instance.new("BodyVelocity")
                    flingForce.MaxForce = Vector3.new(1e12, 1e12, 1e12)
                    flingForce.Velocity = Vector3.new(math.random(-5, 5), 5, math.random(-5, 5)).Unit * 2000000 + Vector3.new(0, 2000000, 0)
                    flingForce.Parent = targetHRP
                    task.defer(function()
                        task.wait(1)
                        flingForce:Destroy()
                    end)
                end
            end
        end)
        table.insert(touchedConnections, conn)
    else
        warn("Parte 'Body' não encontrada no barco! Usando todas as partes...")
        for _, part in ipairs(boat:GetDescendants()) do
            if part:IsA("BasePart") then
                local conn = part.Touched:Connect(function(hit)
                    if not running then return end
                    local hitPlayer = Players:GetPlayerFromCharacter(hit.Parent)
                    if hitPlayer and hitPlayer == targetPlayer then
                        local targetHRP = hit.Parent:FindFirstChild("HumanoidRootPart")
                        if targetHRP then
                            local flingForce = Instance.new("BodyVelocity")
                            flingForce.MaxForce = Vector3.new(1e12, 1e12, 1e12)
                            flingForce.Velocity = Vector3.new(math.random(-5, 5), 5, math.random(-5, 5)).Unit * 2000000 + Vector3.new(0, 2000000, 0)
                            flingForce.Parent = targetHRP
                            task.defer(function()
                                task.wait(1)
                                flingForce:Destroy()
                            end)
                        end
                    end
                end)
                table.insert(touchedConnections, conn)
            end
        end
    end
    local lastUpdate = tick()
    local updateInterval = 0.05
    flingConnection = RunService.Heartbeat:Connect(function()
        if not running then
            for _, conn in ipairs(touchedConnections) do
                conn:Disconnect()
            end
            touchedConnections = {}
            return
        end
        local targetCharacter = targetPlayer.Character or targetPlayer.CharacterAdded:Wait()
        local newTargetHRP = targetCharacter:FindFirstChild("HumanoidRootPart")
        local newTargetHumanoid = targetCharacter:FindFirstChild("Humanoid")
        if not newTargetHRP or not newTargetHumanoid then return end
        if not myHRP or not humanoid then
            running = false
            for _, conn in ipairs(touchedConnections) do
                conn:Disconnect()
            end
            touchedConnections = {}
            return
        end
        if tick() - lastUpdate < updateInterval then return end
        lastUpdate = tick()
        pcall(function()
            local targetPosition = newTargetHRP.Position
            local time = Workspace.DistributedGameTime
            local rotationX = math.rad(time * 20000)
            local rotationY = math.rad(time * 25000)
            local rotationZ = math.rad(time * 30000)
            boat:PivotTo(
                CFrame.new(targetPosition) * CFrame.Angles(rotationX, rotationY, rotationZ)
            )
        end)
    end)
end

-- Função para parar o fling (usada pelo toggle) com teleporte seguro
local function stopFling()
    running = false
    if connection then
        connection:Disconnect()
        connection = nil
    end
    if flingConnection then
        flingConnection:Disconnect()
        flingConnection = nil
    end
    if soccerBall then
        soccerBall.Anchored = originalProperties.Anchored
        soccerBall.CanCollide = originalProperties.CanCollide
        soccerBall.CanTouch = originalProperties.CanTouch
    end
    if couch and couch:IsA("BasePart") then
        couch.Anchored = originalProperties.Anchored
        couch.CanCollide = originalProperties.CanCollide
        couch.CanTouch = originalProperties.CanTouch
    end
    
    -- Desativar CarClient antes de deletar veículos
    disableCarClient()
    
    local args = { [1] = "DeleteAllVehicles" }
    pcall(function()
        ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(args))
    end)
    task.wait(0.2)
    local character = LocalPlayer.Character
    if character then
        -- Zerar a física de todas as partes do personagem
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
                part.Velocity = Vector3.zero
                part.RotVelocity = Vector3.zero
                part.Anchored = true -- Ancorar temporariamente para evitar movimento
            end
        end
        -- Zerar estados do Humanoid
        local myHumanoid = character:FindFirstChild("Humanoid")
        if myHumanoid then
            myHumanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
            myHumanoid.Sit = false
            myHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
        end
        -- Restaurar cadeiras no Workspace
        for _, seat in ipairs(Workspace:GetDescendants()) do
            if seat:IsA("Seat") or seat:IsA("VehicleSeat") then
                seat.Disabled = false
            end
        end
        -- Restaurar o tamanho do personagem
        pcall(function()
            ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Clothe1s"):FireServer("CharacterSizeUp", 1)
        end)
        -- Teleportar de volta para a posição original com segurança
        if savedPosition then
            local myHRP = character:FindFirstChild("HumanoidRootPart")
            if myHRP then
                pcall(function()
                    -- Garantir que o personagem esteja ancorado durante o teleporte
                    myHRP.Anchored = true
                    myHRP.CFrame = CFrame.new(savedPosition + Vector3.new(0, 5, 0))
                    task.wait(0.2)
                    myHRP.Velocity = Vector3.zero
                    myHRP.RotVelocity = Vector3.zero
                    myHRP.Anchored = false
                    if myHumanoid then
                        myHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                    end
                end)
            end
        else
            warn("savedPosition não está definida para teleporte de volta!")
        end
        -- Desancorar todas as partes do personagem após o teleporte
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Anchored = false
            end
        end
    end
end

-- Toggle para ativar/desativar o fling
print("Criando o toggle para ativar/desativar o fling...")
flingToggle = Tab1:Toggle({
    Title = "Ativar Fling",
    Desc = "Ativa ou desativa o fling com o método selecionado",
    Default = false,
    Callback = function(state)
        if state then
            if isFollowingKill or isFollowingPull or running then
                warn("Uma ação já está ativa. Use o botão Parar (Matar ou Puxar) primeiro.")
                flingToggle:SetValue(false)
                return
            end
            if not selectedPlayer then
                warn("Nenhum jogador selecionado!")
                flingToggle:SetValue(false)
                return
            end
            if not selectedFlingMethod then
                warn("Nenhum método de fling selecionado!")
                flingToggle:SetValue(false)
                return
            end
            if selectedFlingMethod == "Bola" then
                flingWithBall(selectedPlayer)
            elseif selectedFlingMethod == "Sofá" then
                flingWithSofa(selectedPlayer)
            elseif selectedFlingMethod == "Ônibus" then
                flingWithBus(selectedPlayer)
            elseif selectedFlingMethod == "Barco" then
                flingWithBoat(selectedPlayer)
            end
        else
            stopFling()
        end
    end
})
print("Toggle para ativar/desativar o fling criado com sucesso!")

print("Script inicializado com sucesso! A UI deve estar visível agora.")
