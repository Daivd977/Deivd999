local WindUI = loadstring(game:HttpGet("https://tree-hub.vercel.app/api/UI/WindUI"))()
local Version = "1.4.0"

local Window = WindUI:CreateWindow({
    Title = "Lolyta troll 666",
    Icon = "door-open",
    Author = "Lolycon666",
    Folder = "Lolyta 666",
    Size = UDim2.fromOffset(580, 460),
    KeySystem = {
        Key = "666",
        Note = "pode nao man",
        URL = "",
        SaveKey = true,
    },
    Transparent = true,
    Theme = "Dark",
    SideBarWidth = 200,
    HasOutline = false,
})

Window:EditOpenButton({
    Title = "Lolyta troll",
    Icon = "align-justify",
    CornerRadius = UDim.new(0, 10),
    StrokeThickness = 3,
    Color = ColorSequence.new(Color3.fromHex("FF0F7B"), Color3.fromHex("F89B29"))
})

-- === Abas da Interface === --
local Tab1 = Window:Tab({ Title = "troll", Icon = "Ball" })

-----------------------------------------------------------------------------------------------------------------------------------------
                                          -- === Tab 1: Troll === --
-----------------------------------------------------------------------------------------------------------------------------------------

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

-- Variáveis compartilhadas
local selectedPlayer = nil
local isFollowingKill = false
local isFollowingPull = false
local originalPosition = nil
local isSpectating = false
local spectatedPlayer = nil
local characterConnection = nil
local soccerBall = nil
local running = false
local connection, flingConnection
local originalProperties = {}
local savedPosition = nil

-- Cria um RemoteEvent para comunicação com o servidor
local SetNetworkOwnerEvent = Instance.new("RemoteEvent")
SetNetworkOwnerEvent.Name = "SetNetworkOwnerEvent_" .. tostring(math.random(1000, 9999))
SetNetworkOwnerEvent.Parent = ReplicatedStorage

-- Cria um script no servidor para lidar com o RemoteEvent
local serverScriptCode = [[
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local event = ReplicatedStorage:WaitForChild("]] .. SetNetworkOwnerEvent.Name .. [[")
    
    event.OnServerEvent:Connect(function(player, part, networkOwner)
        if part and part:IsA("BasePart") then
            pcall(function()
                part:SetNetworkOwner(networkOwner)
                part.Anchored = false
                part.CanCollide = true
                part.CanTouch = true
            end)
        end
    end)
]]

local success, errorMessage = pcall(function()
    loadstring(serverScriptCode)()
end)
if not success then
    warn("Erro ao criar script no servidor: " .. tostring(errorMessage))
end

-- Função para obter os nomes dos jogadores, excluindo o jogador local
local function getPlayerNames()
    local playerNames = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playerNames, player.Name)
        end
    end
    return playerNames
end

-- Função para atualizar o dropdown
local function updateDropdown(dropdown)
    local success, errorMessage = pcall(function()
        local playerNames = getPlayerNames()
        dropdown:Refresh(playerNames)
        if selectedPlayer and not table.find(playerNames, selectedPlayer.Name) then
            dropdown:SetValue("")
            selectedPlayer = nil
            print("Jogador anterior saiu do jogo. Seleção resetada.")
        end
    end)
    if not success then
        warn("Erro ao atualizar dropdown: " .. tostring(errorMessage))
    end
end

-- Função para visualizar um jogador
local function spectatePlayer(playerName)
    if characterConnection then
        characterConnection:Disconnect()
        characterConnection = nil
    end

    local targetPlayer = Players:FindFirstChild(playerName)
    if targetPlayer and targetPlayer ~= LocalPlayer then
        spectatedPlayer = targetPlayer
        isSpectating = true
        print("Visualizando jogador: " .. targetPlayer.Name)

        local function updateCamera()
            if not isSpectating or not spectatedPlayer then
                return
            end
            if spectatedPlayer.Character and spectatedPlayer.Character:FindFirstChild("Humanoid") then
                Workspace.CurrentCamera.CameraSubject = spectatedPlayer.Character.Humanoid
            else
                Workspace.CurrentCamera.CameraSubject = nil
            end
        end

        updateCamera()

        characterConnection = RunService.Heartbeat:Connect(function()
            if not isSpectating then
                characterConnection:Disconnect()
                characterConnection = nil
                return
            end
            local success, errorMessage = pcall(updateCamera)
            if not success then
                warn("Erro ao atualizar câmera no modo visualização: " .. tostring(errorMessage))
                stopSpectating()
            end
        end)

        spectatedPlayer.CharacterAdded:Connect(function()
            if isSpectating then
                updateCamera()
            end
        end)
    else
        print("Jogador inválido ou não encontrado para modo visualização.")
        isSpectating = false
        spectatedPlayer = nil
    end
end

-- Função para parar de visualizar
local function stopSpectating()
    if characterConnection then
        characterConnection:Disconnect()
        characterConnection = nil
    end

    isSpectating = false
    spectatedPlayer = nil

    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        Workspace.CurrentCamera.CameraSubject = LocalPlayer.Character.Humanoid
        Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
        print("Parando de visualizar. Voltando à visão do jogador local.")
    else
        Workspace.CurrentCamera.CameraSubject = nil
        Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
        print("Nenhum personagem local encontrado. Câmera redefinida.")
    end
end

-- Detecta quando o jogador local morre e reseta a câmera
LocalPlayer.CharacterAdded:Connect(function(character)
    if isSpectating then
        stopSpectating()
        print("Você morreu. Câmera voltou para o seu personagem.")
    end
end)

-- Botão System Broken
Tab1:Button({
    Title = "System Broken",
    Desc = "Universal",
    Callback = function()
        local success, errorMessage = pcall(function()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/H20CalibreYT/SystemBroken/main/script"))()
        end)
        if not success then
            warn("Erro ao carregar System Broken: " .. tostring(errorMessage))
        end
    end,
})

Tab1:Paragraph({ 
    Title = "Execute o System Broken e ative o VoidProtection", 
    Desc = "Faça isso antes de usar as funções abaixo!!!"
})

-- Dropdown para selecionar jogador
local DropdownPlayer = Tab1:Dropdown({
    Title = "Selecionar Jogador",
    Desc = "Escolha um jogador para matar, puxar ou aplicar fling",
    Value = "",
    Multi = false,
    AllowNone = true,
    Values = getPlayerNames(),
    Callback = function(selectedPlayerName)
        if selectedPlayerName == "" or selectedPlayerName == nil then
            selectedPlayer = nil
            print("Nenhum jogador selecionado.")
            if running then
                running = false
                if connection then connection:Disconnect() end
                if flingConnection then flingConnection:Disconnect() end
                stopSpectating()
            end
            isFollowingKill = false
            isFollowingPull = false
        else
            selectedPlayer = Players:FindFirstChild(selectedPlayerName)
            print("Jogador selecionado: " .. selectedPlayerName)
            if isSpectating then
                stopSpectating()
                spectatePlayer(selectedPlayerName)
            end
            if running then
                print("Jogador do fling atualizado para: " .. selectedPlayerName)
            end
        end
    end,
})

-- Botão para atualizar a lista de jogadores
Tab1:Button({
    Title = "Atualizar Lista de Jogadores",
    Desc = "Atualiza a lista de jogadores no dropdown",
    Callback = function()
        updateDropdown(DropdownPlayer)
        print("Lista de jogadores atualizada!")
    end,
})

-- Toggle para visualizar jogador
local SpectateToggle = Tab1:Toggle({
    Title = "Visualizar Jogador",
    Desc = "Ativa/desativa a visualização do jogador selecionado",
    Default = false,
    Callback = function(state)
        if state then
            if selectedPlayer then
                local success, errorMessage = pcall(spectatePlayer, selectedPlayer.Name)
                if not success then
                    warn("Erro ao ativar modo visualização: " .. tostring(errorMessage))
                    SpectateToggle:SetValue(false)
                end
            else
                print("Selecione um jogador antes de ativar a visualização.")
                SpectateToggle:SetValue(false)
            end
        else
            local success, errorMessage = pcall(stopSpectating)
            if not success then
                warn("Erro ao desativar modo visualização: " .. tostring(errorMessage))
            end
        end
    end,
})

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-- BOTÃO INICIAR FLING COM SOFÁ
Tab1:Button({
    Title = "Iniciar Fling com Sofá",
    Desc = "Inicia o fling no jogador selecionado usando o sofá",
    Callback = function()
        if running then
            print("O fling já está ativo. Use o botão 'Parar Fling' primeiro.")
            return
        end
        if not selectedPlayer or not selectedPlayer.Character or not LocalPlayer.Character then
            warn("Selecione um jogador válido antes de iniciar!")
            return
        end

        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local myHRP = character:FindFirstChild("HumanoidRootPart")
        if not humanoid or not myHRP then
            warn("Seu personagem ainda não está totalmente carregado.")
            return
        end

        -- Salva a posição inicial
        savedPosition = myHRP.Position

        -- Função para equipar o sofá
        local function equipSofa()
            local backpack = LocalPlayer:WaitForChild("Backpack")
            local sofa = backpack:FindFirstChild("Couch") or character:FindFirstChild("Couch")

            if not sofa then
                -- Pega o sofá se não estiver no inventário ou equipado
                local args = {
                    [1] = "PickingTools",
                    [2] = "Couch"
                }
                local success, err = pcall(function()
                    ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Too1l"):InvokeServer(unpack(args))
                end)
                if not success then
                    warn("Erro ao pegar o sofá: " .. tostring(err))
                    return false
                end

                -- Espera o sofá aparecer na mochila
                repeat
                    sofa = backpack:FindFirstChild("Couch")
                    task.wait()
                until sofa or task.wait(5) -- Timeout de 5 segundos
                if not sofa then
                    warn("Falha ao pegar o sofá!")
                    return false
                end
            end

            -- Se o sofá não estiver equipado, equipa
            if sofa.Parent ~= character then
                sofa.Parent = character
                print("Sofá equipado!")
            else
                print("Sofá já está equipado!")
            end
            return true
        end

        -- Equipa o sofá
        if not equipSofa() then
            return
        end

        -- Espera 0.5 segundos
        task.wait(0.5)

        -- Procura o sofá no Workspace ou no personagem
        local couch
        for _, obj in ipairs(Workspace:GetDescendants()) do
            if obj.Name == "Couch" or obj.Name == "Couch" .. LocalPlayer.Name then
                couch = obj
                break
            end
        end
        if not couch then
            couch = character:FindFirstChild("Couch")
        end
        if not couch then
            warn("Sofá não encontrado no Workspace ou no personagem!")
            print("Procurando sofá... Objetos no Workspace com 'Couch' no nome:")
            for _, obj in ipairs(Workspace:GetDescendants()) do
                if obj.Name:find("Couch") then
                    print(" - " .. obj.Name .. " (Path: " .. obj:GetFullName() .. ")")
                end
            end
            return
        end
        print("Sofá encontrado: " .. couch.Name .. " (Path: " .. couch:GetFullName() .. ")")

        -- Configura o sofá
        originalProperties = {
            Anchored = couch.Anchored,
            CanCollide = couch.CanCollide,
            CanTouch = couch.CanTouch
        }
        couch.Anchored = false
        couch.CanCollide = true
        couch.CanTouch = true
        pcall(function() couch:SetNetworkOwner(nil) end)

        -- Ativa o NoClip
        running = true
        connection = RunService.Stepped:Connect(function()
            if not running then return end
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)

        -- Segue o jogador selecionado com backflips rápidos
        print("Iniciando acompanhamento de " .. selectedPlayer.Name .. " com backflips!")
        local startTime = tick()
        flingConnection = RunService.Heartbeat:Connect(function()
            if not running then
                print("Loop de acompanhamento interrompido: running = false")
                return
            end
            if not selectedPlayer or not selectedPlayer.Character then
                warn("Jogador selecionado não está mais disponível!")
                running = false
                return
            end
            local newTargetHRP = selectedPlayer.Character:FindFirstChild("HumanoidRootPart")
            local newTargetHumanoid = selectedPlayer.Character:FindFirstChild("Humanoid")
            if not newTargetHRP or not newTargetHumanoid then
                warn("HumanoidRootPart ou Humanoid do jogador selecionado não encontrado!")
                running = false
                return
            end
            if not myHRP or not humanoid then
                warn("HumanoidRootPart ou Humanoid do jogador local não encontrado!")
                running = false
                return
            end

            -- Teleporta para o jogador selecionado
            pcall(function()
                myHRP.Anchored = true
                myHRP.CFrame = newTargetHRP.CFrame * CFrame.new(0, 0, -2) -- 2 unidades atrás
                myHRP.Anchored = false
            end)
            print("Teleportado para " .. selectedPlayer.Name .. " (Posição: " .. tostring(newTargetHRP.Position) .. ")")

            -- Aplica backflips rápidos
            pcall(function()
                myHRP.CFrame = myHRP.CFrame * CFrame.Angles(0, 0, math.rad(360 * 5 * task.wait())) -- 5 rotações por segundo
            end)
            print("Aplicando backflips para " .. selectedPlayer.Name)

            -- Verifica se o jogador selecionado está sentado ou se o tempo limite foi atingido
            print("Jogador " .. selectedPlayer.Name .. " sentado: " .. tostring(newTargetHumanoid.Sit) .. " | Tempo decorrido: " .. tostring(tick() - startTime))
            if newTargetHumanoid.Sit or tick() - startTime > 10 then
                running = false
                flingConnection:Disconnect()
                flingConnection = nil

                -- Deleta o sofá do inventário
                local args = {
                    [1] = "PlayerWantsToDeleteTool",
                    [2] = "Couch"
                }
                pcall(function()
                    ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Clea1rTool1s"):FireServer(unpack(args))
                end)
                print("Sofá removido do inventário!")

                -- Aplica o fling extremamente forte no jogador selecionado
                for _, part in ipairs(selectedPlayer.Character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end

                local fling = Instance.new("BodyVelocity")
                fling.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                fling.Velocity = Vector3.new(math.random(-5, 5), 5, math.random(-5, 5)).Unit * 100000 + Vector3.new(0, 100000, 0)
                fling.Parent = newTargetHRP

                task.delay(0.5, function()
                    fling:Destroy()
                    for _, part in ipairs(selectedPlayer.Character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = true
                        end
                    end
                end)
                print("Fling extremamente forte aplicado em " .. selectedPlayer.Name .. "!")

                -- Teleporta o jogador local de volta à posição inicial
                pcall(function()
                    myHRP.Anchored = true
                    myHRP.CFrame = CFrame.new(savedPosition + Vector3.new(0, 5, 0))
                    task.wait(0.2)
                    myHRP.Velocity = Vector3.zero
                    myHRP.RotVelocity = Vector3.zero
                    myHRP.Anchored = false
                    if humanoid then
                        humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                    end
                end)
                print("Jogador local retornado à posição inicial!")
            end
        end)
    end,
})

-- BOTÃO PARAR FLING
Tab1:Button({
    Title = "Parar Fling",
    Desc = "Para o fling no jogador selecionado",
    Callback = function()
        running = false
        if connection then
            connection:Disconnect()
            connection = nil
        end
        if flingConnection then
            flingConnection:Disconnect()
            flingConnection = nil
        end

        -- Restaura as propriedades do sofá
        if couch then
            couch.Anchored = originalProperties.Anchored
            couch.CanCollide = originalProperties.CanCollide
            couch.CanTouch = originalProperties.CanTouch
        end

        -- Desativa o NoClip
        local character = LocalPlayer.Character
        if character then
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = true
                    part.Velocity = Vector3.zero
                    part.RotVelocity = Vector3.zero
                end
            end
        end

        -- Restaura a capacidade de sentar
        local myHumanoid = character and character:FindFirstChild("Humanoid")
        if myHumanoid then
            myHumanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        end

        -- Reativa assentos
        for _, seat in ipairs(Workspace:GetDescendants()) do
            if seat:IsA("Seat") or seat:IsA("VehicleSeat") then
                seat.Disabled = false
            end
        end

        -- Restaura o tamanho do personagem
        pcall(function()
            ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Clothe1s"):FireServer("CharacterSizeUp", 1)
        end)

        -- Teleporta com segurança
        if savedPosition then
            local myHRP = character and character:FindFirstChild("HumanoidRootPart")
            if myHRP then
                myHRP.Anchored = true
                myHRP.CFrame = CFrame.new(savedPosition + Vector3.new(0, 5, 0))
                task.wait(0.2)
                myHRP.Velocity = Vector3.zero
                myHRP.RotVelocity = Vector3.zero
                myHRP.Anchored = false
                if myHumanoid then
                    myHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                end
            end
        end
        print("Fling parado. Personagem voltou à posição original.")
    end,
})
